// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/shuTwT/hoshikuzu/ent/album"
	"github.com/shuTwT/hoshikuzu/ent/albumphoto"
	"github.com/shuTwT/hoshikuzu/ent/apiperms"
	"github.com/shuTwT/hoshikuzu/ent/category"
	"github.com/shuTwT/hoshikuzu/ent/comment"
	"github.com/shuTwT/hoshikuzu/ent/coupon"
	"github.com/shuTwT/hoshikuzu/ent/couponusage"
	"github.com/shuTwT/hoshikuzu/ent/doclibrary"
	"github.com/shuTwT/hoshikuzu/ent/doclibrarydetail"
	"github.com/shuTwT/hoshikuzu/ent/essay"
	"github.com/shuTwT/hoshikuzu/ent/file"
	"github.com/shuTwT/hoshikuzu/ent/flink"
	"github.com/shuTwT/hoshikuzu/ent/flinkapplication"
	"github.com/shuTwT/hoshikuzu/ent/flinkgroup"
	"github.com/shuTwT/hoshikuzu/ent/friendcirclerecord"
	"github.com/shuTwT/hoshikuzu/ent/knowledgebase"
	"github.com/shuTwT/hoshikuzu/ent/license"
	"github.com/shuTwT/hoshikuzu/ent/member"
	"github.com/shuTwT/hoshikuzu/ent/memberlevel"
	"github.com/shuTwT/hoshikuzu/ent/notification"
	"github.com/shuTwT/hoshikuzu/ent/oauth2accesstoken"
	"github.com/shuTwT/hoshikuzu/ent/oauth2code"
	"github.com/shuTwT/hoshikuzu/ent/oauth2refreshtoken"
	"github.com/shuTwT/hoshikuzu/ent/payorder"
	"github.com/shuTwT/hoshikuzu/ent/personalaccesstoken"
	"github.com/shuTwT/hoshikuzu/ent/plugin"
	"github.com/shuTwT/hoshikuzu/ent/post"
	"github.com/shuTwT/hoshikuzu/ent/predicate"
	"github.com/shuTwT/hoshikuzu/ent/product"
	"github.com/shuTwT/hoshikuzu/ent/role"
	"github.com/shuTwT/hoshikuzu/ent/schedulejob"
	"github.com/shuTwT/hoshikuzu/ent/setting"
	"github.com/shuTwT/hoshikuzu/ent/storagestrategy"
	"github.com/shuTwT/hoshikuzu/ent/tag"
	"github.com/shuTwT/hoshikuzu/ent/theme"
	"github.com/shuTwT/hoshikuzu/ent/user"
	"github.com/shuTwT/hoshikuzu/ent/visitlog"
	"github.com/shuTwT/hoshikuzu/ent/wallet"
	"github.com/shuTwT/hoshikuzu/ent/webhook"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlbum               = "Album"
	TypeAlbumPhoto          = "AlbumPhoto"
	TypeApiPerms            = "ApiPerms"
	TypeCategory            = "Category"
	TypeComment             = "Comment"
	TypeCoupon              = "Coupon"
	TypeCouponUsage         = "CouponUsage"
	TypeDocLibrary          = "DocLibrary"
	TypeDocLibraryDetail    = "DocLibraryDetail"
	TypeEssay               = "Essay"
	TypeFLink               = "FLink"
	TypeFLinkApplication    = "FLinkApplication"
	TypeFLinkGroup          = "FLinkGroup"
	TypeFile                = "File"
	TypeFriendCircleRecord  = "FriendCircleRecord"
	TypeKnowledgeBase       = "KnowledgeBase"
	TypeLicense             = "License"
	TypeMember              = "Member"
	TypeMemberLevel         = "MemberLevel"
	TypeNotification        = "Notification"
	TypeOauth2AccessToken   = "Oauth2AccessToken"
	TypeOauth2Code          = "Oauth2Code"
	TypeOauth2RefreshToken  = "Oauth2RefreshToken"
	TypePayOrder            = "PayOrder"
	TypePersonalAccessToken = "PersonalAccessToken"
	TypePlugin              = "Plugin"
	TypePost                = "Post"
	TypeProduct             = "Product"
	TypeRole                = "Role"
	TypeScheduleJob         = "ScheduleJob"
	TypeSetting             = "Setting"
	TypeStorageStrategy     = "StorageStrategy"
	TypeTag                 = "Tag"
	TypeTheme               = "Theme"
	TypeUser                = "User"
	TypeVisitLog            = "VisitLog"
	TypeWallet              = "Wallet"
	TypeWebHook             = "WebHook"
)

// AlbumMutation represents an operation that mutates the Album nodes in the graph.
type AlbumMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	description   *string
	sort          *int
	addsort       *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Album, error)
	predicates    []predicate.Album
}

var _ ent.Mutation = (*AlbumMutation)(nil)

// albumOption allows management of the mutation configuration using functional options.
type albumOption func(*AlbumMutation)

// newAlbumMutation creates new mutation for the Album entity.
func newAlbumMutation(c config, op Op, opts ...albumOption) *AlbumMutation {
	m := &AlbumMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumID sets the ID field of the mutation.
func withAlbumID(id int) albumOption {
	return func(m *AlbumMutation) {
		var (
			err   error
			once  sync.Once
			value *Album
		)
		m.oldValue = func(ctx context.Context) (*Album, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Album.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbum sets the old Album of the mutation.
func withAlbum(node *Album) albumOption {
	return func(m *AlbumMutation) {
		m.oldValue = func(context.Context) (*Album, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Album entities.
func (m *AlbumMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Album.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AlbumMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlbumMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlbumMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlbumMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlbumMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlbumMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *AlbumMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlbumMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlbumMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AlbumMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlbumMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AlbumMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[album.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AlbumMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[album.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AlbumMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, album.FieldDescription)
}

// SetSort sets the "sort" field.
func (m *AlbumMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AlbumMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Album entity.
// If the Album object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *AlbumMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *AlbumMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *AlbumMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[album.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *AlbumMutation) SortCleared() bool {
	_, ok := m.clearedFields[album.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *AlbumMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, album.FieldSort)
}

// Where appends a list predicates to the AlbumMutation builder.
func (m *AlbumMutation) Where(ps ...predicate.Album) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Album, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Album).
func (m *AlbumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, album.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, album.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, album.FieldName)
	}
	if m.description != nil {
		fields = append(fields, album.FieldDescription)
	}
	if m.sort != nil {
		fields = append(fields, album.FieldSort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case album.FieldCreatedAt:
		return m.CreatedAt()
	case album.FieldUpdatedAt:
		return m.UpdatedAt()
	case album.FieldName:
		return m.Name()
	case album.FieldDescription:
		return m.Description()
	case album.FieldSort:
		return m.Sort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case album.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case album.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case album.FieldName:
		return m.OldName(ctx)
	case album.FieldDescription:
		return m.OldDescription(ctx)
	case album.FieldSort:
		return m.OldSort(ctx)
	}
	return nil, fmt.Errorf("unknown Album field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) SetField(name string, value ent.Value) error {
	switch name {
	case album.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case album.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case album.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case album.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case album.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, album.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case album.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumMutation) AddField(name string, value ent.Value) error {
	switch name {
	case album.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Album numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(album.FieldDescription) {
		fields = append(fields, album.FieldDescription)
	}
	if m.FieldCleared(album.FieldSort) {
		fields = append(fields, album.FieldSort)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumMutation) ClearField(name string) error {
	switch name {
	case album.FieldDescription:
		m.ClearDescription()
		return nil
	case album.FieldSort:
		m.ClearSort()
		return nil
	}
	return fmt.Errorf("unknown Album nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumMutation) ResetField(name string) error {
	switch name {
	case album.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case album.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case album.FieldName:
		m.ResetName()
		return nil
	case album.FieldDescription:
		m.ResetDescription()
		return nil
	case album.FieldSort:
		m.ResetSort()
		return nil
	}
	return fmt.Errorf("unknown Album field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Album unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Album edge %s", name)
}

// AlbumPhotoMutation represents an operation that mutates the AlbumPhoto nodes in the graph.
type AlbumPhotoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	image_url     *string
	description   *string
	view_count    *int
	addview_count *int
	album_id      *int
	addalbum_id   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AlbumPhoto, error)
	predicates    []predicate.AlbumPhoto
}

var _ ent.Mutation = (*AlbumPhotoMutation)(nil)

// albumphotoOption allows management of the mutation configuration using functional options.
type albumphotoOption func(*AlbumPhotoMutation)

// newAlbumPhotoMutation creates new mutation for the AlbumPhoto entity.
func newAlbumPhotoMutation(c config, op Op, opts ...albumphotoOption) *AlbumPhotoMutation {
	m := &AlbumPhotoMutation{
		config:        c,
		op:            op,
		typ:           TypeAlbumPhoto,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlbumPhotoID sets the ID field of the mutation.
func withAlbumPhotoID(id int) albumphotoOption {
	return func(m *AlbumPhotoMutation) {
		var (
			err   error
			once  sync.Once
			value *AlbumPhoto
		)
		m.oldValue = func(ctx context.Context) (*AlbumPhoto, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlbumPhoto.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlbumPhoto sets the old AlbumPhoto of the mutation.
func withAlbumPhoto(node *AlbumPhoto) albumphotoOption {
	return func(m *AlbumPhotoMutation) {
		m.oldValue = func(context.Context) (*AlbumPhoto, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlbumPhotoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlbumPhotoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlbumPhoto entities.
func (m *AlbumPhotoMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlbumPhotoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlbumPhotoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlbumPhoto.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AlbumPhotoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AlbumPhotoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AlbumPhoto entity.
// If the AlbumPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPhotoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AlbumPhotoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AlbumPhotoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AlbumPhotoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AlbumPhoto entity.
// If the AlbumPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPhotoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AlbumPhotoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *AlbumPhotoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AlbumPhotoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AlbumPhoto entity.
// If the AlbumPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPhotoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AlbumPhotoMutation) ResetName() {
	m.name = nil
}

// SetImageURL sets the "image_url" field.
func (m *AlbumPhotoMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *AlbumPhotoMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the AlbumPhoto entity.
// If the AlbumPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPhotoMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *AlbumPhotoMutation) ResetImageURL() {
	m.image_url = nil
}

// SetDescription sets the "description" field.
func (m *AlbumPhotoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AlbumPhotoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AlbumPhoto entity.
// If the AlbumPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPhotoMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AlbumPhotoMutation) ResetDescription() {
	m.description = nil
}

// SetViewCount sets the "view_count" field.
func (m *AlbumPhotoMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *AlbumPhotoMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the AlbumPhoto entity.
// If the AlbumPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPhotoMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *AlbumPhotoMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *AlbumPhotoMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *AlbumPhotoMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetAlbumID sets the "album_id" field.
func (m *AlbumPhotoMutation) SetAlbumID(i int) {
	m.album_id = &i
	m.addalbum_id = nil
}

// AlbumID returns the value of the "album_id" field in the mutation.
func (m *AlbumPhotoMutation) AlbumID() (r int, exists bool) {
	v := m.album_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAlbumID returns the old "album_id" field's value of the AlbumPhoto entity.
// If the AlbumPhoto object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlbumPhotoMutation) OldAlbumID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlbumID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlbumID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlbumID: %w", err)
	}
	return oldValue.AlbumID, nil
}

// AddAlbumID adds i to the "album_id" field.
func (m *AlbumPhotoMutation) AddAlbumID(i int) {
	if m.addalbum_id != nil {
		*m.addalbum_id += i
	} else {
		m.addalbum_id = &i
	}
}

// AddedAlbumID returns the value that was added to the "album_id" field in this mutation.
func (m *AlbumPhotoMutation) AddedAlbumID() (r int, exists bool) {
	v := m.addalbum_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlbumID resets all changes to the "album_id" field.
func (m *AlbumPhotoMutation) ResetAlbumID() {
	m.album_id = nil
	m.addalbum_id = nil
}

// Where appends a list predicates to the AlbumPhotoMutation builder.
func (m *AlbumPhotoMutation) Where(ps ...predicate.AlbumPhoto) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlbumPhotoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlbumPhotoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlbumPhoto, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlbumPhotoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlbumPhotoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlbumPhoto).
func (m *AlbumPhotoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlbumPhotoMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, albumphoto.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, albumphoto.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, albumphoto.FieldName)
	}
	if m.image_url != nil {
		fields = append(fields, albumphoto.FieldImageURL)
	}
	if m.description != nil {
		fields = append(fields, albumphoto.FieldDescription)
	}
	if m.view_count != nil {
		fields = append(fields, albumphoto.FieldViewCount)
	}
	if m.album_id != nil {
		fields = append(fields, albumphoto.FieldAlbumID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlbumPhotoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case albumphoto.FieldCreatedAt:
		return m.CreatedAt()
	case albumphoto.FieldUpdatedAt:
		return m.UpdatedAt()
	case albumphoto.FieldName:
		return m.Name()
	case albumphoto.FieldImageURL:
		return m.ImageURL()
	case albumphoto.FieldDescription:
		return m.Description()
	case albumphoto.FieldViewCount:
		return m.ViewCount()
	case albumphoto.FieldAlbumID:
		return m.AlbumID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlbumPhotoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case albumphoto.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case albumphoto.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case albumphoto.FieldName:
		return m.OldName(ctx)
	case albumphoto.FieldImageURL:
		return m.OldImageURL(ctx)
	case albumphoto.FieldDescription:
		return m.OldDescription(ctx)
	case albumphoto.FieldViewCount:
		return m.OldViewCount(ctx)
	case albumphoto.FieldAlbumID:
		return m.OldAlbumID(ctx)
	}
	return nil, fmt.Errorf("unknown AlbumPhoto field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumPhotoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case albumphoto.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case albumphoto.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case albumphoto.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case albumphoto.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case albumphoto.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case albumphoto.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case albumphoto.FieldAlbumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlbumID(v)
		return nil
	}
	return fmt.Errorf("unknown AlbumPhoto field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlbumPhotoMutation) AddedFields() []string {
	var fields []string
	if m.addview_count != nil {
		fields = append(fields, albumphoto.FieldViewCount)
	}
	if m.addalbum_id != nil {
		fields = append(fields, albumphoto.FieldAlbumID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlbumPhotoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case albumphoto.FieldViewCount:
		return m.AddedViewCount()
	case albumphoto.FieldAlbumID:
		return m.AddedAlbumID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlbumPhotoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case albumphoto.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case albumphoto.FieldAlbumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlbumID(v)
		return nil
	}
	return fmt.Errorf("unknown AlbumPhoto numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlbumPhotoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlbumPhotoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlbumPhotoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AlbumPhoto nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlbumPhotoMutation) ResetField(name string) error {
	switch name {
	case albumphoto.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case albumphoto.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case albumphoto.FieldName:
		m.ResetName()
		return nil
	case albumphoto.FieldImageURL:
		m.ResetImageURL()
		return nil
	case albumphoto.FieldDescription:
		m.ResetDescription()
		return nil
	case albumphoto.FieldViewCount:
		m.ResetViewCount()
		return nil
	case albumphoto.FieldAlbumID:
		m.ResetAlbumID()
		return nil
	}
	return fmt.Errorf("unknown AlbumPhoto field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlbumPhotoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlbumPhotoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlbumPhotoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlbumPhotoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlbumPhotoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlbumPhotoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlbumPhotoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AlbumPhoto unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlbumPhotoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AlbumPhoto edge %s", name)
}

// ApiPermsMutation represents an operation that mutates the ApiPerms nodes in the graph.
type ApiPermsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	_path           *string
	method          *string
	desc            *string
	permission_type *string
	roles           *[]string
	appendroles     []string
	status          *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ApiPerms, error)
	predicates      []predicate.ApiPerms
}

var _ ent.Mutation = (*ApiPermsMutation)(nil)

// apipermsOption allows management of the mutation configuration using functional options.
type apipermsOption func(*ApiPermsMutation)

// newApiPermsMutation creates new mutation for the ApiPerms entity.
func newApiPermsMutation(c config, op Op, opts ...apipermsOption) *ApiPermsMutation {
	m := &ApiPermsMutation{
		config:        c,
		op:            op,
		typ:           TypeApiPerms,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiPermsID sets the ID field of the mutation.
func withApiPermsID(id int) apipermsOption {
	return func(m *ApiPermsMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiPerms
		)
		m.oldValue = func(ctx context.Context) (*ApiPerms, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiPerms.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiPerms sets the old ApiPerms of the mutation.
func withApiPerms(node *ApiPerms) apipermsOption {
	return func(m *ApiPermsMutation) {
		m.oldValue = func(context.Context) (*ApiPerms, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiPermsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiPermsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiPerms entities.
func (m *ApiPermsMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiPermsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiPermsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiPerms.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiPermsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiPermsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiPerms entity.
// If the ApiPerms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiPermsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiPermsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApiPermsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApiPermsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApiPerms entity.
// If the ApiPerms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiPermsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApiPermsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ApiPermsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApiPermsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApiPerms entity.
// If the ApiPerms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiPermsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApiPermsMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *ApiPermsMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ApiPermsMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the ApiPerms entity.
// If the ApiPerms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiPermsMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *ApiPermsMutation) ResetPath() {
	m._path = nil
}

// SetMethod sets the "method" field.
func (m *ApiPermsMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *ApiPermsMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the ApiPerms entity.
// If the ApiPerms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiPermsMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *ApiPermsMutation) ResetMethod() {
	m.method = nil
}

// SetDesc sets the "desc" field.
func (m *ApiPermsMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *ApiPermsMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the ApiPerms entity.
// If the ApiPerms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiPermsMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *ApiPermsMutation) ResetDesc() {
	m.desc = nil
}

// SetPermissionType sets the "permission_type" field.
func (m *ApiPermsMutation) SetPermissionType(s string) {
	m.permission_type = &s
}

// PermissionType returns the value of the "permission_type" field in the mutation.
func (m *ApiPermsMutation) PermissionType() (r string, exists bool) {
	v := m.permission_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionType returns the old "permission_type" field's value of the ApiPerms entity.
// If the ApiPerms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiPermsMutation) OldPermissionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionType: %w", err)
	}
	return oldValue.PermissionType, nil
}

// ResetPermissionType resets all changes to the "permission_type" field.
func (m *ApiPermsMutation) ResetPermissionType() {
	m.permission_type = nil
}

// SetRoles sets the "roles" field.
func (m *ApiPermsMutation) SetRoles(s []string) {
	m.roles = &s
	m.appendroles = nil
}

// Roles returns the value of the "roles" field in the mutation.
func (m *ApiPermsMutation) Roles() (r []string, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoles returns the old "roles" field's value of the ApiPerms entity.
// If the ApiPerms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiPermsMutation) OldRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoles: %w", err)
	}
	return oldValue.Roles, nil
}

// AppendRoles adds s to the "roles" field.
func (m *ApiPermsMutation) AppendRoles(s []string) {
	m.appendroles = append(m.appendroles, s...)
}

// AppendedRoles returns the list of values that were appended to the "roles" field in this mutation.
func (m *ApiPermsMutation) AppendedRoles() ([]string, bool) {
	if len(m.appendroles) == 0 {
		return nil, false
	}
	return m.appendroles, true
}

// ResetRoles resets all changes to the "roles" field.
func (m *ApiPermsMutation) ResetRoles() {
	m.roles = nil
	m.appendroles = nil
}

// SetStatus sets the "status" field.
func (m *ApiPermsMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ApiPermsMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ApiPerms entity.
// If the ApiPerms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiPermsMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ApiPermsMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the ApiPermsMutation builder.
func (m *ApiPermsMutation) Where(ps ...predicate.ApiPerms) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiPermsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiPermsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiPerms, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiPermsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiPermsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiPerms).
func (m *ApiPermsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiPermsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, apiperms.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apiperms.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, apiperms.FieldName)
	}
	if m._path != nil {
		fields = append(fields, apiperms.FieldPath)
	}
	if m.method != nil {
		fields = append(fields, apiperms.FieldMethod)
	}
	if m.desc != nil {
		fields = append(fields, apiperms.FieldDesc)
	}
	if m.permission_type != nil {
		fields = append(fields, apiperms.FieldPermissionType)
	}
	if m.roles != nil {
		fields = append(fields, apiperms.FieldRoles)
	}
	if m.status != nil {
		fields = append(fields, apiperms.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiPermsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apiperms.FieldCreatedAt:
		return m.CreatedAt()
	case apiperms.FieldUpdatedAt:
		return m.UpdatedAt()
	case apiperms.FieldName:
		return m.Name()
	case apiperms.FieldPath:
		return m.Path()
	case apiperms.FieldMethod:
		return m.Method()
	case apiperms.FieldDesc:
		return m.Desc()
	case apiperms.FieldPermissionType:
		return m.PermissionType()
	case apiperms.FieldRoles:
		return m.Roles()
	case apiperms.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiPermsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apiperms.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apiperms.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apiperms.FieldName:
		return m.OldName(ctx)
	case apiperms.FieldPath:
		return m.OldPath(ctx)
	case apiperms.FieldMethod:
		return m.OldMethod(ctx)
	case apiperms.FieldDesc:
		return m.OldDesc(ctx)
	case apiperms.FieldPermissionType:
		return m.OldPermissionType(ctx)
	case apiperms.FieldRoles:
		return m.OldRoles(ctx)
	case apiperms.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ApiPerms field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiPermsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apiperms.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apiperms.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apiperms.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apiperms.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case apiperms.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case apiperms.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case apiperms.FieldPermissionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionType(v)
		return nil
	case apiperms.FieldRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoles(v)
		return nil
	case apiperms.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ApiPerms field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiPermsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiPermsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiPermsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiPerms numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiPermsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiPermsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiPermsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApiPerms nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiPermsMutation) ResetField(name string) error {
	switch name {
	case apiperms.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apiperms.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apiperms.FieldName:
		m.ResetName()
		return nil
	case apiperms.FieldPath:
		m.ResetPath()
		return nil
	case apiperms.FieldMethod:
		m.ResetMethod()
		return nil
	case apiperms.FieldDesc:
		m.ResetDesc()
		return nil
	case apiperms.FieldPermissionType:
		m.ResetPermissionType()
		return nil
	case apiperms.FieldRoles:
		m.ResetRoles()
		return nil
	case apiperms.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ApiPerms field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiPermsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiPermsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiPermsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiPermsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiPermsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiPermsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiPermsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApiPerms unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiPermsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApiPerms edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	description   *string
	slug          *string
	sort_order    *int
	addsort_order *int
	active        *bool
	clearedFields map[string]struct{}
	posts         map[int]struct{}
	removedposts  map[int]struct{}
	clearedposts  bool
	done          bool
	oldValue      func(context.Context) (*Category, error)
	predicates    []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[category.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[category.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, category.FieldDescription)
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *CategoryMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[category.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *CategoryMutation) SlugCleared() bool {
	_, ok := m.clearedFields[category.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, category.FieldSlug)
}

// SetSortOrder sets the "sort_order" field.
func (m *CategoryMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *CategoryMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *CategoryMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *CategoryMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *CategoryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetActive sets the "active" field.
func (m *CategoryMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *CategoryMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *CategoryMutation) ResetActive() {
	m.active = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *CategoryMutation) AddPostIDs(ids ...int) {
	if m.posts == nil {
		m.posts = make(map[int]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *CategoryMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *CategoryMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *CategoryMutation) RemovePostIDs(ids ...int) {
	if m.removedposts == nil {
		m.removedposts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *CategoryMutation) RemovedPostsIDs() (ids []int) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *CategoryMutation) PostsIDs() (ids []int) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *CategoryMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.sort_order != nil {
		fields = append(fields, category.FieldSortOrder)
	}
	if m.active != nil {
		fields = append(fields, category.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	case category.FieldName:
		return m.Name()
	case category.FieldDescription:
		return m.Description()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldSortOrder:
		return m.SortOrder()
	case category.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case category.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case category.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, category.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldDescription) {
		fields = append(fields, category.FieldDescription)
	}
	if m.FieldCleared(category.FieldSlug) {
		fields = append(fields, category.FieldSlug)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldDescription:
		m.ClearDescription()
		return nil
	case category.FieldSlug:
		m.ClearSlug()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case category.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.posts != nil {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedposts != nil {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedposts {
		edges = append(edges, category.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	post_id       *int
	addpost_id    *int
	page_id       *int
	addpage_id    *int
	url           *string
	parent_id     *int
	addparent_id  *int
	content       *string
	user_id       *int
	adduser_id    *int
	status        *int
	addstatus     *int
	user_agent    *string
	ip_address    *string
	ip_location   *string
	pinned        *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Comment, error)
	predicates    []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPostID sets the "post_id" field.
func (m *CommentMutation) SetPostID(i int) {
	m.post_id = &i
	m.addpost_id = nil
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *CommentMutation) PostID() (r int, exists bool) {
	v := m.post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPostID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// AddPostID adds i to the "post_id" field.
func (m *CommentMutation) AddPostID(i int) {
	if m.addpost_id != nil {
		*m.addpost_id += i
	} else {
		m.addpost_id = &i
	}
}

// AddedPostID returns the value that was added to the "post_id" field in this mutation.
func (m *CommentMutation) AddedPostID() (r int, exists bool) {
	v := m.addpost_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPostID clears the value of the "post_id" field.
func (m *CommentMutation) ClearPostID() {
	m.post_id = nil
	m.addpost_id = nil
	m.clearedFields[comment.FieldPostID] = struct{}{}
}

// PostIDCleared returns if the "post_id" field was cleared in this mutation.
func (m *CommentMutation) PostIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldPostID]
	return ok
}

// ResetPostID resets all changes to the "post_id" field.
func (m *CommentMutation) ResetPostID() {
	m.post_id = nil
	m.addpost_id = nil
	delete(m.clearedFields, comment.FieldPostID)
}

// SetPageID sets the "page_id" field.
func (m *CommentMutation) SetPageID(i int) {
	m.page_id = &i
	m.addpage_id = nil
}

// PageID returns the value of the "page_id" field in the mutation.
func (m *CommentMutation) PageID() (r int, exists bool) {
	v := m.page_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPageID returns the old "page_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPageID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageID: %w", err)
	}
	return oldValue.PageID, nil
}

// AddPageID adds i to the "page_id" field.
func (m *CommentMutation) AddPageID(i int) {
	if m.addpage_id != nil {
		*m.addpage_id += i
	} else {
		m.addpage_id = &i
	}
}

// AddedPageID returns the value that was added to the "page_id" field in this mutation.
func (m *CommentMutation) AddedPageID() (r int, exists bool) {
	v := m.addpage_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPageID clears the value of the "page_id" field.
func (m *CommentMutation) ClearPageID() {
	m.page_id = nil
	m.addpage_id = nil
	m.clearedFields[comment.FieldPageID] = struct{}{}
}

// PageIDCleared returns if the "page_id" field was cleared in this mutation.
func (m *CommentMutation) PageIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldPageID]
	return ok
}

// ResetPageID resets all changes to the "page_id" field.
func (m *CommentMutation) ResetPageID() {
	m.page_id = nil
	m.addpage_id = nil
	delete(m.clearedFields, comment.FieldPageID)
}

// SetURL sets the "url" field.
func (m *CommentMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *CommentMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *CommentMutation) ClearURL() {
	m.url = nil
	m.clearedFields[comment.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *CommentMutation) URLCleared() bool {
	_, ok := m.clearedFields[comment.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *CommentMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, comment.FieldURL)
}

// SetParentID sets the "parent_id" field.
func (m *CommentMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CommentMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *CommentMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *CommentMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CommentMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CommentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CommentMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, comment.FieldParentID)
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *CommentMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CommentMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *CommentMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[comment.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CommentMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, comment.FieldUserID)
}

// SetStatus sets the "status" field.
func (m *CommentMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CommentMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CommentMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CommentMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CommentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *CommentMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *CommentMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *CommentMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[comment.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *CommentMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[comment.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *CommentMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, comment.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *CommentMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *CommentMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *CommentMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetIPLocation sets the "ip_location" field.
func (m *CommentMutation) SetIPLocation(s string) {
	m.ip_location = &s
}

// IPLocation returns the value of the "ip_location" field in the mutation.
func (m *CommentMutation) IPLocation() (r string, exists bool) {
	v := m.ip_location
	if v == nil {
		return
	}
	return *v, true
}

// OldIPLocation returns the old "ip_location" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldIPLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPLocation: %w", err)
	}
	return oldValue.IPLocation, nil
}

// ClearIPLocation clears the value of the "ip_location" field.
func (m *CommentMutation) ClearIPLocation() {
	m.ip_location = nil
	m.clearedFields[comment.FieldIPLocation] = struct{}{}
}

// IPLocationCleared returns if the "ip_location" field was cleared in this mutation.
func (m *CommentMutation) IPLocationCleared() bool {
	_, ok := m.clearedFields[comment.FieldIPLocation]
	return ok
}

// ResetIPLocation resets all changes to the "ip_location" field.
func (m *CommentMutation) ResetIPLocation() {
	m.ip_location = nil
	delete(m.clearedFields, comment.FieldIPLocation)
}

// SetPinned sets the "pinned" field.
func (m *CommentMutation) SetPinned(b bool) {
	m.pinned = &b
}

// Pinned returns the value of the "pinned" field in the mutation.
func (m *CommentMutation) Pinned() (r bool, exists bool) {
	v := m.pinned
	if v == nil {
		return
	}
	return *v, true
}

// OldPinned returns the old "pinned" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPinned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinned: %w", err)
	}
	return oldValue.Pinned, nil
}

// ResetPinned resets all changes to the "pinned" field.
func (m *CommentMutation) ResetPinned() {
	m.pinned = nil
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.post_id != nil {
		fields = append(fields, comment.FieldPostID)
	}
	if m.page_id != nil {
		fields = append(fields, comment.FieldPageID)
	}
	if m.url != nil {
		fields = append(fields, comment.FieldURL)
	}
	if m.parent_id != nil {
		fields = append(fields, comment.FieldParentID)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.user_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.status != nil {
		fields = append(fields, comment.FieldStatus)
	}
	if m.user_agent != nil {
		fields = append(fields, comment.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, comment.FieldIPAddress)
	}
	if m.ip_location != nil {
		fields = append(fields, comment.FieldIPLocation)
	}
	if m.pinned != nil {
		fields = append(fields, comment.FieldPinned)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldPostID:
		return m.PostID()
	case comment.FieldPageID:
		return m.PageID()
	case comment.FieldURL:
		return m.URL()
	case comment.FieldParentID:
		return m.ParentID()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldStatus:
		return m.Status()
	case comment.FieldUserAgent:
		return m.UserAgent()
	case comment.FieldIPAddress:
		return m.IPAddress()
	case comment.FieldIPLocation:
		return m.IPLocation()
	case comment.FieldPinned:
		return m.Pinned()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldPostID:
		return m.OldPostID(ctx)
	case comment.FieldPageID:
		return m.OldPageID(ctx)
	case comment.FieldURL:
		return m.OldURL(ctx)
	case comment.FieldParentID:
		return m.OldParentID(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldStatus:
		return m.OldStatus(ctx)
	case comment.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case comment.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case comment.FieldIPLocation:
		return m.OldIPLocation(ctx)
	case comment.FieldPinned:
		return m.OldPinned(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case comment.FieldPageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageID(v)
		return nil
	case comment.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case comment.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case comment.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case comment.FieldIPLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPLocation(v)
		return nil
	case comment.FieldPinned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinned(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addpost_id != nil {
		fields = append(fields, comment.FieldPostID)
	}
	if m.addpage_id != nil {
		fields = append(fields, comment.FieldPageID)
	}
	if m.addparent_id != nil {
		fields = append(fields, comment.FieldParentID)
	}
	if m.adduser_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.addstatus != nil {
		fields = append(fields, comment.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldPostID:
		return m.AddedPostID()
	case comment.FieldPageID:
		return m.AddedPageID()
	case comment.FieldParentID:
		return m.AddedParentID()
	case comment.FieldUserID:
		return m.AddedUserID()
	case comment.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostID(v)
		return nil
	case comment.FieldPageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPageID(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case comment.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldPostID) {
		fields = append(fields, comment.FieldPostID)
	}
	if m.FieldCleared(comment.FieldPageID) {
		fields = append(fields, comment.FieldPageID)
	}
	if m.FieldCleared(comment.FieldURL) {
		fields = append(fields, comment.FieldURL)
	}
	if m.FieldCleared(comment.FieldParentID) {
		fields = append(fields, comment.FieldParentID)
	}
	if m.FieldCleared(comment.FieldUserID) {
		fields = append(fields, comment.FieldUserID)
	}
	if m.FieldCleared(comment.FieldUserAgent) {
		fields = append(fields, comment.FieldUserAgent)
	}
	if m.FieldCleared(comment.FieldIPLocation) {
		fields = append(fields, comment.FieldIPLocation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldPostID:
		m.ClearPostID()
		return nil
	case comment.FieldPageID:
		m.ClearPageID()
		return nil
	case comment.FieldURL:
		m.ClearURL()
		return nil
	case comment.FieldParentID:
		m.ClearParentID()
		return nil
	case comment.FieldUserID:
		m.ClearUserID()
		return nil
	case comment.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case comment.FieldIPLocation:
		m.ClearIPLocation()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldPostID:
		m.ResetPostID()
		return nil
	case comment.FieldPageID:
		m.ResetPageID()
		return nil
	case comment.FieldURL:
		m.ResetURL()
		return nil
	case comment.FieldParentID:
		m.ResetParentID()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldStatus:
		m.ResetStatus()
		return nil
	case comment.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case comment.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case comment.FieldIPLocation:
		m.ResetIPLocation()
		return nil
	case comment.FieldPinned:
		m.ResetPinned()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Comment edge %s", name)
}

// CouponMutation represents an operation that mutates the Coupon nodes in the graph.
type CouponMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	code               *string
	description        *string
	_type              *int
	add_type           *int
	value              *int
	addvalue           *int
	min_amount         *int
	addmin_amount      *int
	max_discount       *int
	addmax_discount    *int
	total_count        *int
	addtotal_count     *int
	used_count         *int
	addused_count      *int
	per_user_limit     *int
	addper_user_limit  *int
	start_time         *time.Time
	end_time           *time.Time
	active             *bool
	image              *string
	product_ids        *[]int
	appendproduct_ids  []int
	category_ids       *[]int
	appendcategory_ids []int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Coupon, error)
	predicates         []predicate.Coupon
}

var _ ent.Mutation = (*CouponMutation)(nil)

// couponOption allows management of the mutation configuration using functional options.
type couponOption func(*CouponMutation)

// newCouponMutation creates new mutation for the Coupon entity.
func newCouponMutation(c config, op Op, opts ...couponOption) *CouponMutation {
	m := &CouponMutation{
		config:        c,
		op:            op,
		typ:           TypeCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponID sets the ID field of the mutation.
func withCouponID(id int) couponOption {
	return func(m *CouponMutation) {
		var (
			err   error
			once  sync.Once
			value *Coupon
		)
		m.oldValue = func(ctx context.Context) (*Coupon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoupon sets the old Coupon of the mutation.
func withCoupon(node *Coupon) couponOption {
	return func(m *CouponMutation) {
		m.oldValue = func(context.Context) (*Coupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Coupon entities.
func (m *CouponMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Coupon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CouponMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CouponMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CouponMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *CouponMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CouponMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CouponMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *CouponMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CouponMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CouponMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[coupon.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CouponMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[coupon.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CouponMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, coupon.FieldDescription)
}

// SetType sets the "type" field.
func (m *CouponMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *CouponMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *CouponMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *CouponMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *CouponMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetValue sets the "value" field.
func (m *CouponMutation) SetValue(i int) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *CouponMutation) Value() (r int, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to the "value" field.
func (m *CouponMutation) AddValue(i int) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *CouponMutation) AddedValue() (r int, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *CouponMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetMinAmount sets the "min_amount" field.
func (m *CouponMutation) SetMinAmount(i int) {
	m.min_amount = &i
	m.addmin_amount = nil
}

// MinAmount returns the value of the "min_amount" field in the mutation.
func (m *CouponMutation) MinAmount() (r int, exists bool) {
	v := m.min_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldMinAmount returns the old "min_amount" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldMinAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinAmount: %w", err)
	}
	return oldValue.MinAmount, nil
}

// AddMinAmount adds i to the "min_amount" field.
func (m *CouponMutation) AddMinAmount(i int) {
	if m.addmin_amount != nil {
		*m.addmin_amount += i
	} else {
		m.addmin_amount = &i
	}
}

// AddedMinAmount returns the value that was added to the "min_amount" field in this mutation.
func (m *CouponMutation) AddedMinAmount() (r int, exists bool) {
	v := m.addmin_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinAmount resets all changes to the "min_amount" field.
func (m *CouponMutation) ResetMinAmount() {
	m.min_amount = nil
	m.addmin_amount = nil
}

// SetMaxDiscount sets the "max_discount" field.
func (m *CouponMutation) SetMaxDiscount(i int) {
	m.max_discount = &i
	m.addmax_discount = nil
}

// MaxDiscount returns the value of the "max_discount" field in the mutation.
func (m *CouponMutation) MaxDiscount() (r int, exists bool) {
	v := m.max_discount
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxDiscount returns the old "max_discount" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldMaxDiscount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxDiscount: %w", err)
	}
	return oldValue.MaxDiscount, nil
}

// AddMaxDiscount adds i to the "max_discount" field.
func (m *CouponMutation) AddMaxDiscount(i int) {
	if m.addmax_discount != nil {
		*m.addmax_discount += i
	} else {
		m.addmax_discount = &i
	}
}

// AddedMaxDiscount returns the value that was added to the "max_discount" field in this mutation.
func (m *CouponMutation) AddedMaxDiscount() (r int, exists bool) {
	v := m.addmax_discount
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxDiscount resets all changes to the "max_discount" field.
func (m *CouponMutation) ResetMaxDiscount() {
	m.max_discount = nil
	m.addmax_discount = nil
}

// SetTotalCount sets the "total_count" field.
func (m *CouponMutation) SetTotalCount(i int) {
	m.total_count = &i
	m.addtotal_count = nil
}

// TotalCount returns the value of the "total_count" field in the mutation.
func (m *CouponMutation) TotalCount() (r int, exists bool) {
	v := m.total_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCount returns the old "total_count" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldTotalCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCount: %w", err)
	}
	return oldValue.TotalCount, nil
}

// AddTotalCount adds i to the "total_count" field.
func (m *CouponMutation) AddTotalCount(i int) {
	if m.addtotal_count != nil {
		*m.addtotal_count += i
	} else {
		m.addtotal_count = &i
	}
}

// AddedTotalCount returns the value that was added to the "total_count" field in this mutation.
func (m *CouponMutation) AddedTotalCount() (r int, exists bool) {
	v := m.addtotal_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCount resets all changes to the "total_count" field.
func (m *CouponMutation) ResetTotalCount() {
	m.total_count = nil
	m.addtotal_count = nil
}

// SetUsedCount sets the "used_count" field.
func (m *CouponMutation) SetUsedCount(i int) {
	m.used_count = &i
	m.addused_count = nil
}

// UsedCount returns the value of the "used_count" field in the mutation.
func (m *CouponMutation) UsedCount() (r int, exists bool) {
	v := m.used_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedCount returns the old "used_count" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUsedCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedCount: %w", err)
	}
	return oldValue.UsedCount, nil
}

// AddUsedCount adds i to the "used_count" field.
func (m *CouponMutation) AddUsedCount(i int) {
	if m.addused_count != nil {
		*m.addused_count += i
	} else {
		m.addused_count = &i
	}
}

// AddedUsedCount returns the value that was added to the "used_count" field in this mutation.
func (m *CouponMutation) AddedUsedCount() (r int, exists bool) {
	v := m.addused_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsedCount resets all changes to the "used_count" field.
func (m *CouponMutation) ResetUsedCount() {
	m.used_count = nil
	m.addused_count = nil
}

// SetPerUserLimit sets the "per_user_limit" field.
func (m *CouponMutation) SetPerUserLimit(i int) {
	m.per_user_limit = &i
	m.addper_user_limit = nil
}

// PerUserLimit returns the value of the "per_user_limit" field in the mutation.
func (m *CouponMutation) PerUserLimit() (r int, exists bool) {
	v := m.per_user_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldPerUserLimit returns the old "per_user_limit" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldPerUserLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerUserLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerUserLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerUserLimit: %w", err)
	}
	return oldValue.PerUserLimit, nil
}

// AddPerUserLimit adds i to the "per_user_limit" field.
func (m *CouponMutation) AddPerUserLimit(i int) {
	if m.addper_user_limit != nil {
		*m.addper_user_limit += i
	} else {
		m.addper_user_limit = &i
	}
}

// AddedPerUserLimit returns the value that was added to the "per_user_limit" field in this mutation.
func (m *CouponMutation) AddedPerUserLimit() (r int, exists bool) {
	v := m.addper_user_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetPerUserLimit resets all changes to the "per_user_limit" field.
func (m *CouponMutation) ResetPerUserLimit() {
	m.per_user_limit = nil
	m.addper_user_limit = nil
}

// SetStartTime sets the "start_time" field.
func (m *CouponMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CouponMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CouponMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *CouponMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *CouponMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *CouponMutation) ResetEndTime() {
	m.end_time = nil
}

// SetActive sets the "active" field.
func (m *CouponMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *CouponMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *CouponMutation) ResetActive() {
	m.active = nil
}

// SetImage sets the "image" field.
func (m *CouponMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *CouponMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *CouponMutation) ClearImage() {
	m.image = nil
	m.clearedFields[coupon.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *CouponMutation) ImageCleared() bool {
	_, ok := m.clearedFields[coupon.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *CouponMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, coupon.FieldImage)
}

// SetProductIds sets the "product_ids" field.
func (m *CouponMutation) SetProductIds(i []int) {
	m.product_ids = &i
	m.appendproduct_ids = nil
}

// ProductIds returns the value of the "product_ids" field in the mutation.
func (m *CouponMutation) ProductIds() (r []int, exists bool) {
	v := m.product_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldProductIds returns the old "product_ids" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldProductIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductIds: %w", err)
	}
	return oldValue.ProductIds, nil
}

// AppendProductIds adds i to the "product_ids" field.
func (m *CouponMutation) AppendProductIds(i []int) {
	m.appendproduct_ids = append(m.appendproduct_ids, i...)
}

// AppendedProductIds returns the list of values that were appended to the "product_ids" field in this mutation.
func (m *CouponMutation) AppendedProductIds() ([]int, bool) {
	if len(m.appendproduct_ids) == 0 {
		return nil, false
	}
	return m.appendproduct_ids, true
}

// ClearProductIds clears the value of the "product_ids" field.
func (m *CouponMutation) ClearProductIds() {
	m.product_ids = nil
	m.appendproduct_ids = nil
	m.clearedFields[coupon.FieldProductIds] = struct{}{}
}

// ProductIdsCleared returns if the "product_ids" field was cleared in this mutation.
func (m *CouponMutation) ProductIdsCleared() bool {
	_, ok := m.clearedFields[coupon.FieldProductIds]
	return ok
}

// ResetProductIds resets all changes to the "product_ids" field.
func (m *CouponMutation) ResetProductIds() {
	m.product_ids = nil
	m.appendproduct_ids = nil
	delete(m.clearedFields, coupon.FieldProductIds)
}

// SetCategoryIds sets the "category_ids" field.
func (m *CouponMutation) SetCategoryIds(i []int) {
	m.category_ids = &i
	m.appendcategory_ids = nil
}

// CategoryIds returns the value of the "category_ids" field in the mutation.
func (m *CouponMutation) CategoryIds() (r []int, exists bool) {
	v := m.category_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryIds returns the old "category_ids" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCategoryIds(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryIds: %w", err)
	}
	return oldValue.CategoryIds, nil
}

// AppendCategoryIds adds i to the "category_ids" field.
func (m *CouponMutation) AppendCategoryIds(i []int) {
	m.appendcategory_ids = append(m.appendcategory_ids, i...)
}

// AppendedCategoryIds returns the list of values that were appended to the "category_ids" field in this mutation.
func (m *CouponMutation) AppendedCategoryIds() ([]int, bool) {
	if len(m.appendcategory_ids) == 0 {
		return nil, false
	}
	return m.appendcategory_ids, true
}

// ClearCategoryIds clears the value of the "category_ids" field.
func (m *CouponMutation) ClearCategoryIds() {
	m.category_ids = nil
	m.appendcategory_ids = nil
	m.clearedFields[coupon.FieldCategoryIds] = struct{}{}
}

// CategoryIdsCleared returns if the "category_ids" field was cleared in this mutation.
func (m *CouponMutation) CategoryIdsCleared() bool {
	_, ok := m.clearedFields[coupon.FieldCategoryIds]
	return ok
}

// ResetCategoryIds resets all changes to the "category_ids" field.
func (m *CouponMutation) ResetCategoryIds() {
	m.category_ids = nil
	m.appendcategory_ids = nil
	delete(m.clearedFields, coupon.FieldCategoryIds)
}

// Where appends a list predicates to the CouponMutation builder.
func (m *CouponMutation) Where(ps ...predicate.Coupon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CouponMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CouponMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Coupon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CouponMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CouponMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Coupon).
func (m *CouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, coupon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coupon.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, coupon.FieldName)
	}
	if m.code != nil {
		fields = append(fields, coupon.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, coupon.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, coupon.FieldType)
	}
	if m.value != nil {
		fields = append(fields, coupon.FieldValue)
	}
	if m.min_amount != nil {
		fields = append(fields, coupon.FieldMinAmount)
	}
	if m.max_discount != nil {
		fields = append(fields, coupon.FieldMaxDiscount)
	}
	if m.total_count != nil {
		fields = append(fields, coupon.FieldTotalCount)
	}
	if m.used_count != nil {
		fields = append(fields, coupon.FieldUsedCount)
	}
	if m.per_user_limit != nil {
		fields = append(fields, coupon.FieldPerUserLimit)
	}
	if m.start_time != nil {
		fields = append(fields, coupon.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, coupon.FieldEndTime)
	}
	if m.active != nil {
		fields = append(fields, coupon.FieldActive)
	}
	if m.image != nil {
		fields = append(fields, coupon.FieldImage)
	}
	if m.product_ids != nil {
		fields = append(fields, coupon.FieldProductIds)
	}
	if m.category_ids != nil {
		fields = append(fields, coupon.FieldCategoryIds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldCreatedAt:
		return m.CreatedAt()
	case coupon.FieldUpdatedAt:
		return m.UpdatedAt()
	case coupon.FieldName:
		return m.Name()
	case coupon.FieldCode:
		return m.Code()
	case coupon.FieldDescription:
		return m.Description()
	case coupon.FieldType:
		return m.GetType()
	case coupon.FieldValue:
		return m.Value()
	case coupon.FieldMinAmount:
		return m.MinAmount()
	case coupon.FieldMaxDiscount:
		return m.MaxDiscount()
	case coupon.FieldTotalCount:
		return m.TotalCount()
	case coupon.FieldUsedCount:
		return m.UsedCount()
	case coupon.FieldPerUserLimit:
		return m.PerUserLimit()
	case coupon.FieldStartTime:
		return m.StartTime()
	case coupon.FieldEndTime:
		return m.EndTime()
	case coupon.FieldActive:
		return m.Active()
	case coupon.FieldImage:
		return m.Image()
	case coupon.FieldProductIds:
		return m.ProductIds()
	case coupon.FieldCategoryIds:
		return m.CategoryIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coupon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coupon.FieldName:
		return m.OldName(ctx)
	case coupon.FieldCode:
		return m.OldCode(ctx)
	case coupon.FieldDescription:
		return m.OldDescription(ctx)
	case coupon.FieldType:
		return m.OldType(ctx)
	case coupon.FieldValue:
		return m.OldValue(ctx)
	case coupon.FieldMinAmount:
		return m.OldMinAmount(ctx)
	case coupon.FieldMaxDiscount:
		return m.OldMaxDiscount(ctx)
	case coupon.FieldTotalCount:
		return m.OldTotalCount(ctx)
	case coupon.FieldUsedCount:
		return m.OldUsedCount(ctx)
	case coupon.FieldPerUserLimit:
		return m.OldPerUserLimit(ctx)
	case coupon.FieldStartTime:
		return m.OldStartTime(ctx)
	case coupon.FieldEndTime:
		return m.OldEndTime(ctx)
	case coupon.FieldActive:
		return m.OldActive(ctx)
	case coupon.FieldImage:
		return m.OldImage(ctx)
	case coupon.FieldProductIds:
		return m.OldProductIds(ctx)
	case coupon.FieldCategoryIds:
		return m.OldCategoryIds(ctx)
	}
	return nil, fmt.Errorf("unknown Coupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coupon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coupon.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coupon.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case coupon.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case coupon.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case coupon.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case coupon.FieldMinAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinAmount(v)
		return nil
	case coupon.FieldMaxDiscount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxDiscount(v)
		return nil
	case coupon.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCount(v)
		return nil
	case coupon.FieldUsedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedCount(v)
		return nil
	case coupon.FieldPerUserLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerUserLimit(v)
		return nil
	case coupon.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case coupon.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case coupon.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case coupon.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case coupon.FieldProductIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductIds(v)
		return nil
	case coupon.FieldCategoryIds:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryIds(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, coupon.FieldType)
	}
	if m.addvalue != nil {
		fields = append(fields, coupon.FieldValue)
	}
	if m.addmin_amount != nil {
		fields = append(fields, coupon.FieldMinAmount)
	}
	if m.addmax_discount != nil {
		fields = append(fields, coupon.FieldMaxDiscount)
	}
	if m.addtotal_count != nil {
		fields = append(fields, coupon.FieldTotalCount)
	}
	if m.addused_count != nil {
		fields = append(fields, coupon.FieldUsedCount)
	}
	if m.addper_user_limit != nil {
		fields = append(fields, coupon.FieldPerUserLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldType:
		return m.AddedType()
	case coupon.FieldValue:
		return m.AddedValue()
	case coupon.FieldMinAmount:
		return m.AddedMinAmount()
	case coupon.FieldMaxDiscount:
		return m.AddedMaxDiscount()
	case coupon.FieldTotalCount:
		return m.AddedTotalCount()
	case coupon.FieldUsedCount:
		return m.AddedUsedCount()
	case coupon.FieldPerUserLimit:
		return m.AddedPerUserLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case coupon.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case coupon.FieldMinAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinAmount(v)
		return nil
	case coupon.FieldMaxDiscount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxDiscount(v)
		return nil
	case coupon.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCount(v)
		return nil
	case coupon.FieldUsedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedCount(v)
		return nil
	case coupon.FieldPerUserLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPerUserLimit(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupon.FieldDescription) {
		fields = append(fields, coupon.FieldDescription)
	}
	if m.FieldCleared(coupon.FieldImage) {
		fields = append(fields, coupon.FieldImage)
	}
	if m.FieldCleared(coupon.FieldProductIds) {
		fields = append(fields, coupon.FieldProductIds)
	}
	if m.FieldCleared(coupon.FieldCategoryIds) {
		fields = append(fields, coupon.FieldCategoryIds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponMutation) ClearField(name string) error {
	switch name {
	case coupon.FieldDescription:
		m.ClearDescription()
		return nil
	case coupon.FieldImage:
		m.ClearImage()
		return nil
	case coupon.FieldProductIds:
		m.ClearProductIds()
		return nil
	case coupon.FieldCategoryIds:
		m.ClearCategoryIds()
		return nil
	}
	return fmt.Errorf("unknown Coupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponMutation) ResetField(name string) error {
	switch name {
	case coupon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coupon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coupon.FieldName:
		m.ResetName()
		return nil
	case coupon.FieldCode:
		m.ResetCode()
		return nil
	case coupon.FieldDescription:
		m.ResetDescription()
		return nil
	case coupon.FieldType:
		m.ResetType()
		return nil
	case coupon.FieldValue:
		m.ResetValue()
		return nil
	case coupon.FieldMinAmount:
		m.ResetMinAmount()
		return nil
	case coupon.FieldMaxDiscount:
		m.ResetMaxDiscount()
		return nil
	case coupon.FieldTotalCount:
		m.ResetTotalCount()
		return nil
	case coupon.FieldUsedCount:
		m.ResetUsedCount()
		return nil
	case coupon.FieldPerUserLimit:
		m.ResetPerUserLimit()
		return nil
	case coupon.FieldStartTime:
		m.ResetStartTime()
		return nil
	case coupon.FieldEndTime:
		m.ResetEndTime()
		return nil
	case coupon.FieldActive:
		m.ResetActive()
		return nil
	case coupon.FieldImage:
		m.ResetImage()
		return nil
	case coupon.FieldProductIds:
		m.ResetProductIds()
		return nil
	case coupon.FieldCategoryIds:
		m.ResetCategoryIds()
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Coupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Coupon edge %s", name)
}

// CouponUsageMutation represents an operation that mutates the CouponUsage nodes in the graph.
type CouponUsageMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	coupon_code        *string
	user_id            *int
	adduser_id         *int
	order_id           *int
	addorder_id        *int
	status             *int
	addstatus          *int
	used_at            *time.Time
	discount_amount    *int
	adddiscount_amount *int
	expire_at          *time.Time
	remark             *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*CouponUsage, error)
	predicates         []predicate.CouponUsage
}

var _ ent.Mutation = (*CouponUsageMutation)(nil)

// couponusageOption allows management of the mutation configuration using functional options.
type couponusageOption func(*CouponUsageMutation)

// newCouponUsageMutation creates new mutation for the CouponUsage entity.
func newCouponUsageMutation(c config, op Op, opts ...couponusageOption) *CouponUsageMutation {
	m := &CouponUsageMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponUsage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponUsageID sets the ID field of the mutation.
func withCouponUsageID(id int) couponusageOption {
	return func(m *CouponUsageMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponUsage
		)
		m.oldValue = func(ctx context.Context) (*CouponUsage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponUsage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponUsage sets the old CouponUsage of the mutation.
func withCouponUsage(node *CouponUsage) couponusageOption {
	return func(m *CouponUsageMutation) {
		m.oldValue = func(context.Context) (*CouponUsage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponUsageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponUsageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CouponUsage entities.
func (m *CouponUsageMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponUsageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponUsageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CouponUsage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponUsageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponUsageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CouponUsage entity.
// If the CouponUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponUsageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponUsageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponUsageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponUsageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CouponUsage entity.
// If the CouponUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponUsageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponUsageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCouponCode sets the "coupon_code" field.
func (m *CouponUsageMutation) SetCouponCode(s string) {
	m.coupon_code = &s
}

// CouponCode returns the value of the "coupon_code" field in the mutation.
func (m *CouponUsageMutation) CouponCode() (r string, exists bool) {
	v := m.coupon_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponCode returns the old "coupon_code" field's value of the CouponUsage entity.
// If the CouponUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponUsageMutation) OldCouponCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponCode: %w", err)
	}
	return oldValue.CouponCode, nil
}

// ResetCouponCode resets all changes to the "coupon_code" field.
func (m *CouponUsageMutation) ResetCouponCode() {
	m.coupon_code = nil
}

// SetUserID sets the "user_id" field.
func (m *CouponUsageMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CouponUsageMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CouponUsage entity.
// If the CouponUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponUsageMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *CouponUsageMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CouponUsageMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CouponUsageMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOrderID sets the "order_id" field.
func (m *CouponUsageMutation) SetOrderID(i int) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *CouponUsageMutation) OrderID() (r int, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the CouponUsage entity.
// If the CouponUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponUsageMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *CouponUsageMutation) AddOrderID(i int) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *CouponUsageMutation) AddedOrderID() (r int, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *CouponUsageMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[couponusage.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *CouponUsageMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[couponusage.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *CouponUsageMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, couponusage.FieldOrderID)
}

// SetStatus sets the "status" field.
func (m *CouponUsageMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CouponUsageMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CouponUsage entity.
// If the CouponUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponUsageMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CouponUsageMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CouponUsageMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CouponUsageMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetUsedAt sets the "used_at" field.
func (m *CouponUsageMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *CouponUsageMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the CouponUsage entity.
// If the CouponUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponUsageMutation) OldUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *CouponUsageMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[couponusage.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *CouponUsageMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[couponusage.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *CouponUsageMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, couponusage.FieldUsedAt)
}

// SetDiscountAmount sets the "discount_amount" field.
func (m *CouponUsageMutation) SetDiscountAmount(i int) {
	m.discount_amount = &i
	m.adddiscount_amount = nil
}

// DiscountAmount returns the value of the "discount_amount" field in the mutation.
func (m *CouponUsageMutation) DiscountAmount() (r int, exists bool) {
	v := m.discount_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountAmount returns the old "discount_amount" field's value of the CouponUsage entity.
// If the CouponUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponUsageMutation) OldDiscountAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountAmount: %w", err)
	}
	return oldValue.DiscountAmount, nil
}

// AddDiscountAmount adds i to the "discount_amount" field.
func (m *CouponUsageMutation) AddDiscountAmount(i int) {
	if m.adddiscount_amount != nil {
		*m.adddiscount_amount += i
	} else {
		m.adddiscount_amount = &i
	}
}

// AddedDiscountAmount returns the value that was added to the "discount_amount" field in this mutation.
func (m *CouponUsageMutation) AddedDiscountAmount() (r int, exists bool) {
	v := m.adddiscount_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountAmount resets all changes to the "discount_amount" field.
func (m *CouponUsageMutation) ResetDiscountAmount() {
	m.discount_amount = nil
	m.adddiscount_amount = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *CouponUsageMutation) SetExpireAt(t time.Time) {
	m.expire_at = &t
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *CouponUsageMutation) ExpireAt() (r time.Time, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the CouponUsage entity.
// If the CouponUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponUsageMutation) OldExpireAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *CouponUsageMutation) ResetExpireAt() {
	m.expire_at = nil
}

// SetRemark sets the "remark" field.
func (m *CouponUsageMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CouponUsageMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CouponUsage entity.
// If the CouponUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponUsageMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CouponUsageMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[couponusage.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CouponUsageMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[couponusage.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CouponUsageMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, couponusage.FieldRemark)
}

// Where appends a list predicates to the CouponUsageMutation builder.
func (m *CouponUsageMutation) Where(ps ...predicate.CouponUsage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CouponUsageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CouponUsageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CouponUsage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CouponUsageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CouponUsageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CouponUsage).
func (m *CouponUsageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponUsageMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, couponusage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, couponusage.FieldUpdatedAt)
	}
	if m.coupon_code != nil {
		fields = append(fields, couponusage.FieldCouponCode)
	}
	if m.user_id != nil {
		fields = append(fields, couponusage.FieldUserID)
	}
	if m.order_id != nil {
		fields = append(fields, couponusage.FieldOrderID)
	}
	if m.status != nil {
		fields = append(fields, couponusage.FieldStatus)
	}
	if m.used_at != nil {
		fields = append(fields, couponusage.FieldUsedAt)
	}
	if m.discount_amount != nil {
		fields = append(fields, couponusage.FieldDiscountAmount)
	}
	if m.expire_at != nil {
		fields = append(fields, couponusage.FieldExpireAt)
	}
	if m.remark != nil {
		fields = append(fields, couponusage.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponUsageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case couponusage.FieldCreatedAt:
		return m.CreatedAt()
	case couponusage.FieldUpdatedAt:
		return m.UpdatedAt()
	case couponusage.FieldCouponCode:
		return m.CouponCode()
	case couponusage.FieldUserID:
		return m.UserID()
	case couponusage.FieldOrderID:
		return m.OrderID()
	case couponusage.FieldStatus:
		return m.Status()
	case couponusage.FieldUsedAt:
		return m.UsedAt()
	case couponusage.FieldDiscountAmount:
		return m.DiscountAmount()
	case couponusage.FieldExpireAt:
		return m.ExpireAt()
	case couponusage.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponUsageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case couponusage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case couponusage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case couponusage.FieldCouponCode:
		return m.OldCouponCode(ctx)
	case couponusage.FieldUserID:
		return m.OldUserID(ctx)
	case couponusage.FieldOrderID:
		return m.OldOrderID(ctx)
	case couponusage.FieldStatus:
		return m.OldStatus(ctx)
	case couponusage.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case couponusage.FieldDiscountAmount:
		return m.OldDiscountAmount(ctx)
	case couponusage.FieldExpireAt:
		return m.OldExpireAt(ctx)
	case couponusage.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown CouponUsage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponUsageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case couponusage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case couponusage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case couponusage.FieldCouponCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponCode(v)
		return nil
	case couponusage.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case couponusage.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case couponusage.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case couponusage.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case couponusage.FieldDiscountAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountAmount(v)
		return nil
	case couponusage.FieldExpireAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	case couponusage.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown CouponUsage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponUsageMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, couponusage.FieldUserID)
	}
	if m.addorder_id != nil {
		fields = append(fields, couponusage.FieldOrderID)
	}
	if m.addstatus != nil {
		fields = append(fields, couponusage.FieldStatus)
	}
	if m.adddiscount_amount != nil {
		fields = append(fields, couponusage.FieldDiscountAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponUsageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case couponusage.FieldUserID:
		return m.AddedUserID()
	case couponusage.FieldOrderID:
		return m.AddedOrderID()
	case couponusage.FieldStatus:
		return m.AddedStatus()
	case couponusage.FieldDiscountAmount:
		return m.AddedDiscountAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponUsageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case couponusage.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case couponusage.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case couponusage.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case couponusage.FieldDiscountAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountAmount(v)
		return nil
	}
	return fmt.Errorf("unknown CouponUsage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponUsageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(couponusage.FieldOrderID) {
		fields = append(fields, couponusage.FieldOrderID)
	}
	if m.FieldCleared(couponusage.FieldUsedAt) {
		fields = append(fields, couponusage.FieldUsedAt)
	}
	if m.FieldCleared(couponusage.FieldRemark) {
		fields = append(fields, couponusage.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponUsageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponUsageMutation) ClearField(name string) error {
	switch name {
	case couponusage.FieldOrderID:
		m.ClearOrderID()
		return nil
	case couponusage.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	case couponusage.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown CouponUsage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponUsageMutation) ResetField(name string) error {
	switch name {
	case couponusage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case couponusage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case couponusage.FieldCouponCode:
		m.ResetCouponCode()
		return nil
	case couponusage.FieldUserID:
		m.ResetUserID()
		return nil
	case couponusage.FieldOrderID:
		m.ResetOrderID()
		return nil
	case couponusage.FieldStatus:
		m.ResetStatus()
		return nil
	case couponusage.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case couponusage.FieldDiscountAmount:
		m.ResetDiscountAmount()
		return nil
	case couponusage.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	case couponusage.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown CouponUsage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponUsageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponUsageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponUsageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponUsageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponUsageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponUsageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponUsageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponUsage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponUsageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponUsage edge %s", name)
}

// DocLibraryMutation represents an operation that mutates the DocLibrary nodes in the graph.
type DocLibraryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	name           *string
	alias          *string
	description    *string
	source         *doclibrary.Source
	url            *string
	clearedFields  map[string]struct{}
	details        map[int]struct{}
	removeddetails map[int]struct{}
	cleareddetails bool
	done           bool
	oldValue       func(context.Context) (*DocLibrary, error)
	predicates     []predicate.DocLibrary
}

var _ ent.Mutation = (*DocLibraryMutation)(nil)

// doclibraryOption allows management of the mutation configuration using functional options.
type doclibraryOption func(*DocLibraryMutation)

// newDocLibraryMutation creates new mutation for the DocLibrary entity.
func newDocLibraryMutation(c config, op Op, opts ...doclibraryOption) *DocLibraryMutation {
	m := &DocLibraryMutation{
		config:        c,
		op:            op,
		typ:           TypeDocLibrary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocLibraryID sets the ID field of the mutation.
func withDocLibraryID(id int) doclibraryOption {
	return func(m *DocLibraryMutation) {
		var (
			err   error
			once  sync.Once
			value *DocLibrary
		)
		m.oldValue = func(ctx context.Context) (*DocLibrary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocLibrary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocLibrary sets the old DocLibrary of the mutation.
func withDocLibrary(node *DocLibrary) doclibraryOption {
	return func(m *DocLibraryMutation) {
		m.oldValue = func(context.Context) (*DocLibrary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocLibraryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocLibraryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocLibrary entities.
func (m *DocLibraryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocLibraryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocLibraryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocLibrary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DocLibraryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocLibraryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DocLibrary entity.
// If the DocLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocLibraryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocLibraryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocLibraryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DocLibrary entity.
// If the DocLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocLibraryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *DocLibraryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DocLibraryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DocLibrary entity.
// If the DocLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DocLibraryMutation) ResetName() {
	m.name = nil
}

// SetAlias sets the "alias" field.
func (m *DocLibraryMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *DocLibraryMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the DocLibrary entity.
// If the DocLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *DocLibraryMutation) ResetAlias() {
	m.alias = nil
}

// SetDescription sets the "description" field.
func (m *DocLibraryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DocLibraryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DocLibrary entity.
// If the DocLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DocLibraryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[doclibrary.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DocLibraryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[doclibrary.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DocLibraryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, doclibrary.FieldDescription)
}

// SetSource sets the "source" field.
func (m *DocLibraryMutation) SetSource(d doclibrary.Source) {
	m.source = &d
}

// Source returns the value of the "source" field in the mutation.
func (m *DocLibraryMutation) Source() (r doclibrary.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the DocLibrary entity.
// If the DocLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryMutation) OldSource(ctx context.Context) (v doclibrary.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *DocLibraryMutation) ResetSource() {
	m.source = nil
}

// SetURL sets the "url" field.
func (m *DocLibraryMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *DocLibraryMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the DocLibrary entity.
// If the DocLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *DocLibraryMutation) ResetURL() {
	m.url = nil
}

// AddDetailIDs adds the "details" edge to the DocLibraryDetail entity by ids.
func (m *DocLibraryMutation) AddDetailIDs(ids ...int) {
	if m.details == nil {
		m.details = make(map[int]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// ClearDetails clears the "details" edge to the DocLibraryDetail entity.
func (m *DocLibraryMutation) ClearDetails() {
	m.cleareddetails = true
}

// DetailsCleared reports if the "details" edge to the DocLibraryDetail entity was cleared.
func (m *DocLibraryMutation) DetailsCleared() bool {
	return m.cleareddetails
}

// RemoveDetailIDs removes the "details" edge to the DocLibraryDetail entity by IDs.
func (m *DocLibraryMutation) RemoveDetailIDs(ids ...int) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.details, ids[i])
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed IDs of the "details" edge to the DocLibraryDetail entity.
func (m *DocLibraryMutation) RemovedDetailsIDs() (ids []int) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the "details" edge IDs in the mutation.
func (m *DocLibraryMutation) DetailsIDs() (ids []int) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails resets all changes to the "details" edge.
func (m *DocLibraryMutation) ResetDetails() {
	m.details = nil
	m.cleareddetails = false
	m.removeddetails = nil
}

// Where appends a list predicates to the DocLibraryMutation builder.
func (m *DocLibraryMutation) Where(ps ...predicate.DocLibrary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocLibraryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocLibraryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocLibrary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocLibraryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocLibraryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocLibrary).
func (m *DocLibraryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocLibraryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, doclibrary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, doclibrary.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, doclibrary.FieldName)
	}
	if m.alias != nil {
		fields = append(fields, doclibrary.FieldAlias)
	}
	if m.description != nil {
		fields = append(fields, doclibrary.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, doclibrary.FieldSource)
	}
	if m.url != nil {
		fields = append(fields, doclibrary.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocLibraryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doclibrary.FieldCreatedAt:
		return m.CreatedAt()
	case doclibrary.FieldUpdatedAt:
		return m.UpdatedAt()
	case doclibrary.FieldName:
		return m.Name()
	case doclibrary.FieldAlias:
		return m.Alias()
	case doclibrary.FieldDescription:
		return m.Description()
	case doclibrary.FieldSource:
		return m.Source()
	case doclibrary.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocLibraryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doclibrary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case doclibrary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case doclibrary.FieldName:
		return m.OldName(ctx)
	case doclibrary.FieldAlias:
		return m.OldAlias(ctx)
	case doclibrary.FieldDescription:
		return m.OldDescription(ctx)
	case doclibrary.FieldSource:
		return m.OldSource(ctx)
	case doclibrary.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown DocLibrary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocLibraryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doclibrary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case doclibrary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case doclibrary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case doclibrary.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case doclibrary.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case doclibrary.FieldSource:
		v, ok := value.(doclibrary.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case doclibrary.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown DocLibrary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocLibraryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocLibraryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocLibraryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DocLibrary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocLibraryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(doclibrary.FieldDescription) {
		fields = append(fields, doclibrary.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocLibraryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocLibraryMutation) ClearField(name string) error {
	switch name {
	case doclibrary.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DocLibrary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocLibraryMutation) ResetField(name string) error {
	switch name {
	case doclibrary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case doclibrary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case doclibrary.FieldName:
		m.ResetName()
		return nil
	case doclibrary.FieldAlias:
		m.ResetAlias()
		return nil
	case doclibrary.FieldDescription:
		m.ResetDescription()
		return nil
	case doclibrary.FieldSource:
		m.ResetSource()
		return nil
	case doclibrary.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown DocLibrary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocLibraryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.details != nil {
		edges = append(edges, doclibrary.EdgeDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocLibraryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doclibrary.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocLibraryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddetails != nil {
		edges = append(edges, doclibrary.EdgeDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocLibraryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case doclibrary.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocLibraryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddetails {
		edges = append(edges, doclibrary.EdgeDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocLibraryMutation) EdgeCleared(name string) bool {
	switch name {
	case doclibrary.EdgeDetails:
		return m.cleareddetails
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocLibraryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DocLibrary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocLibraryMutation) ResetEdge(name string) error {
	switch name {
	case doclibrary.EdgeDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown DocLibrary edge %s", name)
}

// DocLibraryDetailMutation represents an operation that mutates the DocLibraryDetail nodes in the graph.
type DocLibraryDetailMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	title          *string
	version        *string
	content        *string
	parent_id      *int
	addparent_id   *int
	_path          *string
	url            *string
	language       *string
	clearedFields  map[string]struct{}
	library        *int
	clearedlibrary bool
	done           bool
	oldValue       func(context.Context) (*DocLibraryDetail, error)
	predicates     []predicate.DocLibraryDetail
}

var _ ent.Mutation = (*DocLibraryDetailMutation)(nil)

// doclibrarydetailOption allows management of the mutation configuration using functional options.
type doclibrarydetailOption func(*DocLibraryDetailMutation)

// newDocLibraryDetailMutation creates new mutation for the DocLibraryDetail entity.
func newDocLibraryDetailMutation(c config, op Op, opts ...doclibrarydetailOption) *DocLibraryDetailMutation {
	m := &DocLibraryDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeDocLibraryDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocLibraryDetailID sets the ID field of the mutation.
func withDocLibraryDetailID(id int) doclibrarydetailOption {
	return func(m *DocLibraryDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *DocLibraryDetail
		)
		m.oldValue = func(ctx context.Context) (*DocLibraryDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocLibraryDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocLibraryDetail sets the old DocLibraryDetail of the mutation.
func withDocLibraryDetail(node *DocLibraryDetail) doclibrarydetailOption {
	return func(m *DocLibraryDetailMutation) {
		m.oldValue = func(context.Context) (*DocLibraryDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocLibraryDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocLibraryDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocLibraryDetail entities.
func (m *DocLibraryDetailMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocLibraryDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocLibraryDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocLibraryDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DocLibraryDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocLibraryDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DocLibraryDetail entity.
// If the DocLibraryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocLibraryDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocLibraryDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocLibraryDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DocLibraryDetail entity.
// If the DocLibraryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocLibraryDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *DocLibraryDetailMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DocLibraryDetailMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the DocLibraryDetail entity.
// If the DocLibraryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryDetailMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DocLibraryDetailMutation) ResetTitle() {
	m.title = nil
}

// SetVersion sets the "version" field.
func (m *DocLibraryDetailMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *DocLibraryDetailMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the DocLibraryDetail entity.
// If the DocLibraryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryDetailMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *DocLibraryDetailMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[doclibrarydetail.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *DocLibraryDetailMutation) VersionCleared() bool {
	_, ok := m.clearedFields[doclibrarydetail.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *DocLibraryDetailMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, doclibrarydetail.FieldVersion)
}

// SetContent sets the "content" field.
func (m *DocLibraryDetailMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *DocLibraryDetailMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the DocLibraryDetail entity.
// If the DocLibraryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryDetailMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *DocLibraryDetailMutation) ResetContent() {
	m.content = nil
}

// SetParentID sets the "parent_id" field.
func (m *DocLibraryDetailMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *DocLibraryDetailMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the DocLibraryDetail entity.
// If the DocLibraryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryDetailMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *DocLibraryDetailMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *DocLibraryDetailMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *DocLibraryDetailMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[doclibrarydetail.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *DocLibraryDetailMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[doclibrarydetail.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *DocLibraryDetailMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, doclibrarydetail.FieldParentID)
}

// SetPath sets the "path" field.
func (m *DocLibraryDetailMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *DocLibraryDetailMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the DocLibraryDetail entity.
// If the DocLibraryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryDetailMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *DocLibraryDetailMutation) ClearPath() {
	m._path = nil
	m.clearedFields[doclibrarydetail.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *DocLibraryDetailMutation) PathCleared() bool {
	_, ok := m.clearedFields[doclibrarydetail.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *DocLibraryDetailMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, doclibrarydetail.FieldPath)
}

// SetURL sets the "url" field.
func (m *DocLibraryDetailMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *DocLibraryDetailMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the DocLibraryDetail entity.
// If the DocLibraryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryDetailMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *DocLibraryDetailMutation) ClearURL() {
	m.url = nil
	m.clearedFields[doclibrarydetail.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *DocLibraryDetailMutation) URLCleared() bool {
	_, ok := m.clearedFields[doclibrarydetail.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *DocLibraryDetailMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, doclibrarydetail.FieldURL)
}

// SetLanguage sets the "language" field.
func (m *DocLibraryDetailMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *DocLibraryDetailMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the DocLibraryDetail entity.
// If the DocLibraryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryDetailMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *DocLibraryDetailMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[doclibrarydetail.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *DocLibraryDetailMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[doclibrarydetail.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *DocLibraryDetailMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, doclibrarydetail.FieldLanguage)
}

// SetLibraryID sets the "library_id" field.
func (m *DocLibraryDetailMutation) SetLibraryID(i int) {
	m.library = &i
}

// LibraryID returns the value of the "library_id" field in the mutation.
func (m *DocLibraryDetailMutation) LibraryID() (r int, exists bool) {
	v := m.library
	if v == nil {
		return
	}
	return *v, true
}

// OldLibraryID returns the old "library_id" field's value of the DocLibraryDetail entity.
// If the DocLibraryDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocLibraryDetailMutation) OldLibraryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLibraryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLibraryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLibraryID: %w", err)
	}
	return oldValue.LibraryID, nil
}

// ClearLibraryID clears the value of the "library_id" field.
func (m *DocLibraryDetailMutation) ClearLibraryID() {
	m.library = nil
	m.clearedFields[doclibrarydetail.FieldLibraryID] = struct{}{}
}

// LibraryIDCleared returns if the "library_id" field was cleared in this mutation.
func (m *DocLibraryDetailMutation) LibraryIDCleared() bool {
	_, ok := m.clearedFields[doclibrarydetail.FieldLibraryID]
	return ok
}

// ResetLibraryID resets all changes to the "library_id" field.
func (m *DocLibraryDetailMutation) ResetLibraryID() {
	m.library = nil
	delete(m.clearedFields, doclibrarydetail.FieldLibraryID)
}

// ClearLibrary clears the "library" edge to the DocLibrary entity.
func (m *DocLibraryDetailMutation) ClearLibrary() {
	m.clearedlibrary = true
	m.clearedFields[doclibrarydetail.FieldLibraryID] = struct{}{}
}

// LibraryCleared reports if the "library" edge to the DocLibrary entity was cleared.
func (m *DocLibraryDetailMutation) LibraryCleared() bool {
	return m.LibraryIDCleared() || m.clearedlibrary
}

// LibraryIDs returns the "library" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LibraryID instead. It exists only for internal usage by the builders.
func (m *DocLibraryDetailMutation) LibraryIDs() (ids []int) {
	if id := m.library; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLibrary resets all changes to the "library" edge.
func (m *DocLibraryDetailMutation) ResetLibrary() {
	m.library = nil
	m.clearedlibrary = false
}

// Where appends a list predicates to the DocLibraryDetailMutation builder.
func (m *DocLibraryDetailMutation) Where(ps ...predicate.DocLibraryDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocLibraryDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocLibraryDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocLibraryDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocLibraryDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocLibraryDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocLibraryDetail).
func (m *DocLibraryDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocLibraryDetailMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, doclibrarydetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, doclibrarydetail.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, doclibrarydetail.FieldTitle)
	}
	if m.version != nil {
		fields = append(fields, doclibrarydetail.FieldVersion)
	}
	if m.content != nil {
		fields = append(fields, doclibrarydetail.FieldContent)
	}
	if m.parent_id != nil {
		fields = append(fields, doclibrarydetail.FieldParentID)
	}
	if m._path != nil {
		fields = append(fields, doclibrarydetail.FieldPath)
	}
	if m.url != nil {
		fields = append(fields, doclibrarydetail.FieldURL)
	}
	if m.language != nil {
		fields = append(fields, doclibrarydetail.FieldLanguage)
	}
	if m.library != nil {
		fields = append(fields, doclibrarydetail.FieldLibraryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocLibraryDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doclibrarydetail.FieldCreatedAt:
		return m.CreatedAt()
	case doclibrarydetail.FieldUpdatedAt:
		return m.UpdatedAt()
	case doclibrarydetail.FieldTitle:
		return m.Title()
	case doclibrarydetail.FieldVersion:
		return m.Version()
	case doclibrarydetail.FieldContent:
		return m.Content()
	case doclibrarydetail.FieldParentID:
		return m.ParentID()
	case doclibrarydetail.FieldPath:
		return m.Path()
	case doclibrarydetail.FieldURL:
		return m.URL()
	case doclibrarydetail.FieldLanguage:
		return m.Language()
	case doclibrarydetail.FieldLibraryID:
		return m.LibraryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocLibraryDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doclibrarydetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case doclibrarydetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case doclibrarydetail.FieldTitle:
		return m.OldTitle(ctx)
	case doclibrarydetail.FieldVersion:
		return m.OldVersion(ctx)
	case doclibrarydetail.FieldContent:
		return m.OldContent(ctx)
	case doclibrarydetail.FieldParentID:
		return m.OldParentID(ctx)
	case doclibrarydetail.FieldPath:
		return m.OldPath(ctx)
	case doclibrarydetail.FieldURL:
		return m.OldURL(ctx)
	case doclibrarydetail.FieldLanguage:
		return m.OldLanguage(ctx)
	case doclibrarydetail.FieldLibraryID:
		return m.OldLibraryID(ctx)
	}
	return nil, fmt.Errorf("unknown DocLibraryDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocLibraryDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doclibrarydetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case doclibrarydetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case doclibrarydetail.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case doclibrarydetail.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case doclibrarydetail.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case doclibrarydetail.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case doclibrarydetail.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case doclibrarydetail.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case doclibrarydetail.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case doclibrarydetail.FieldLibraryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLibraryID(v)
		return nil
	}
	return fmt.Errorf("unknown DocLibraryDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocLibraryDetailMutation) AddedFields() []string {
	var fields []string
	if m.addparent_id != nil {
		fields = append(fields, doclibrarydetail.FieldParentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocLibraryDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case doclibrarydetail.FieldParentID:
		return m.AddedParentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocLibraryDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case doclibrarydetail.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	}
	return fmt.Errorf("unknown DocLibraryDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocLibraryDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(doclibrarydetail.FieldVersion) {
		fields = append(fields, doclibrarydetail.FieldVersion)
	}
	if m.FieldCleared(doclibrarydetail.FieldParentID) {
		fields = append(fields, doclibrarydetail.FieldParentID)
	}
	if m.FieldCleared(doclibrarydetail.FieldPath) {
		fields = append(fields, doclibrarydetail.FieldPath)
	}
	if m.FieldCleared(doclibrarydetail.FieldURL) {
		fields = append(fields, doclibrarydetail.FieldURL)
	}
	if m.FieldCleared(doclibrarydetail.FieldLanguage) {
		fields = append(fields, doclibrarydetail.FieldLanguage)
	}
	if m.FieldCleared(doclibrarydetail.FieldLibraryID) {
		fields = append(fields, doclibrarydetail.FieldLibraryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocLibraryDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocLibraryDetailMutation) ClearField(name string) error {
	switch name {
	case doclibrarydetail.FieldVersion:
		m.ClearVersion()
		return nil
	case doclibrarydetail.FieldParentID:
		m.ClearParentID()
		return nil
	case doclibrarydetail.FieldPath:
		m.ClearPath()
		return nil
	case doclibrarydetail.FieldURL:
		m.ClearURL()
		return nil
	case doclibrarydetail.FieldLanguage:
		m.ClearLanguage()
		return nil
	case doclibrarydetail.FieldLibraryID:
		m.ClearLibraryID()
		return nil
	}
	return fmt.Errorf("unknown DocLibraryDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocLibraryDetailMutation) ResetField(name string) error {
	switch name {
	case doclibrarydetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case doclibrarydetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case doclibrarydetail.FieldTitle:
		m.ResetTitle()
		return nil
	case doclibrarydetail.FieldVersion:
		m.ResetVersion()
		return nil
	case doclibrarydetail.FieldContent:
		m.ResetContent()
		return nil
	case doclibrarydetail.FieldParentID:
		m.ResetParentID()
		return nil
	case doclibrarydetail.FieldPath:
		m.ResetPath()
		return nil
	case doclibrarydetail.FieldURL:
		m.ResetURL()
		return nil
	case doclibrarydetail.FieldLanguage:
		m.ResetLanguage()
		return nil
	case doclibrarydetail.FieldLibraryID:
		m.ResetLibraryID()
		return nil
	}
	return fmt.Errorf("unknown DocLibraryDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocLibraryDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.library != nil {
		edges = append(edges, doclibrarydetail.EdgeLibrary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocLibraryDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doclibrarydetail.EdgeLibrary:
		if id := m.library; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocLibraryDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocLibraryDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocLibraryDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlibrary {
		edges = append(edges, doclibrarydetail.EdgeLibrary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocLibraryDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case doclibrarydetail.EdgeLibrary:
		return m.clearedlibrary
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocLibraryDetailMutation) ClearEdge(name string) error {
	switch name {
	case doclibrarydetail.EdgeLibrary:
		m.ClearLibrary()
		return nil
	}
	return fmt.Errorf("unknown DocLibraryDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocLibraryDetailMutation) ResetEdge(name string) error {
	switch name {
	case doclibrarydetail.EdgeLibrary:
		m.ResetLibrary()
		return nil
	}
	return fmt.Errorf("unknown DocLibraryDetail edge %s", name)
}

// EssayMutation represents an operation that mutates the Essay nodes in the graph.
type EssayMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	user_id          *int
	adduser_id       *int
	content          *string
	draft            *bool
	images           *[]string
	appendimages     []string
	like_count       *int
	addlike_count    *int
	comment_count    *int
	addcomment_count *int
	share_count      *int
	addshare_count   *int
	public           *bool
	location         *string
	tags             *[]string
	appendtags       []string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Essay, error)
	predicates       []predicate.Essay
}

var _ ent.Mutation = (*EssayMutation)(nil)

// essayOption allows management of the mutation configuration using functional options.
type essayOption func(*EssayMutation)

// newEssayMutation creates new mutation for the Essay entity.
func newEssayMutation(c config, op Op, opts ...essayOption) *EssayMutation {
	m := &EssayMutation{
		config:        c,
		op:            op,
		typ:           TypeEssay,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEssayID sets the ID field of the mutation.
func withEssayID(id int) essayOption {
	return func(m *EssayMutation) {
		var (
			err   error
			once  sync.Once
			value *Essay
		)
		m.oldValue = func(ctx context.Context) (*Essay, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Essay.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEssay sets the old Essay of the mutation.
func withEssay(node *Essay) essayOption {
	return func(m *EssayMutation) {
		m.oldValue = func(context.Context) (*Essay, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EssayMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EssayMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Essay entities.
func (m *EssayMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EssayMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EssayMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Essay.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EssayMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EssayMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EssayMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EssayMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EssayMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EssayMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *EssayMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EssayMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *EssayMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *EssayMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EssayMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetContent sets the "content" field.
func (m *EssayMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *EssayMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *EssayMutation) ResetContent() {
	m.content = nil
}

// SetDraft sets the "draft" field.
func (m *EssayMutation) SetDraft(b bool) {
	m.draft = &b
}

// Draft returns the value of the "draft" field in the mutation.
func (m *EssayMutation) Draft() (r bool, exists bool) {
	v := m.draft
	if v == nil {
		return
	}
	return *v, true
}

// OldDraft returns the old "draft" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldDraft(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDraft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDraft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDraft: %w", err)
	}
	return oldValue.Draft, nil
}

// ResetDraft resets all changes to the "draft" field.
func (m *EssayMutation) ResetDraft() {
	m.draft = nil
}

// SetImages sets the "images" field.
func (m *EssayMutation) SetImages(s []string) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *EssayMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *EssayMutation) AppendImages(s []string) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *EssayMutation) AppendedImages() ([]string, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *EssayMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[essay.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *EssayMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[essay.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *EssayMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, essay.FieldImages)
}

// SetLikeCount sets the "like_count" field.
func (m *EssayMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *EssayMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *EssayMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *EssayMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *EssayMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetCommentCount sets the "comment_count" field.
func (m *EssayMutation) SetCommentCount(i int) {
	m.comment_count = &i
	m.addcomment_count = nil
}

// CommentCount returns the value of the "comment_count" field in the mutation.
func (m *EssayMutation) CommentCount() (r int, exists bool) {
	v := m.comment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "comment_count" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldCommentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds i to the "comment_count" field.
func (m *EssayMutation) AddCommentCount(i int) {
	if m.addcomment_count != nil {
		*m.addcomment_count += i
	} else {
		m.addcomment_count = &i
	}
}

// AddedCommentCount returns the value that was added to the "comment_count" field in this mutation.
func (m *EssayMutation) AddedCommentCount() (r int, exists bool) {
	v := m.addcomment_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentCount resets all changes to the "comment_count" field.
func (m *EssayMutation) ResetCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
}

// SetShareCount sets the "share_count" field.
func (m *EssayMutation) SetShareCount(i int) {
	m.share_count = &i
	m.addshare_count = nil
}

// ShareCount returns the value of the "share_count" field in the mutation.
func (m *EssayMutation) ShareCount() (r int, exists bool) {
	v := m.share_count
	if v == nil {
		return
	}
	return *v, true
}

// OldShareCount returns the old "share_count" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldShareCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShareCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShareCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShareCount: %w", err)
	}
	return oldValue.ShareCount, nil
}

// AddShareCount adds i to the "share_count" field.
func (m *EssayMutation) AddShareCount(i int) {
	if m.addshare_count != nil {
		*m.addshare_count += i
	} else {
		m.addshare_count = &i
	}
}

// AddedShareCount returns the value that was added to the "share_count" field in this mutation.
func (m *EssayMutation) AddedShareCount() (r int, exists bool) {
	v := m.addshare_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetShareCount resets all changes to the "share_count" field.
func (m *EssayMutation) ResetShareCount() {
	m.share_count = nil
	m.addshare_count = nil
}

// SetPublic sets the "public" field.
func (m *EssayMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *EssayMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *EssayMutation) ResetPublic() {
	m.public = nil
}

// SetLocation sets the "location" field.
func (m *EssayMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *EssayMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *EssayMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[essay.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *EssayMutation) LocationCleared() bool {
	_, ok := m.clearedFields[essay.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *EssayMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, essay.FieldLocation)
}

// SetTags sets the "tags" field.
func (m *EssayMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EssayMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Essay entity.
// If the Essay object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EssayMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *EssayMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *EssayMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *EssayMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[essay.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *EssayMutation) TagsCleared() bool {
	_, ok := m.clearedFields[essay.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *EssayMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, essay.FieldTags)
}

// Where appends a list predicates to the EssayMutation builder.
func (m *EssayMutation) Where(ps ...predicate.Essay) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EssayMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EssayMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Essay, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EssayMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EssayMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Essay).
func (m *EssayMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EssayMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, essay.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, essay.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, essay.FieldUserID)
	}
	if m.content != nil {
		fields = append(fields, essay.FieldContent)
	}
	if m.draft != nil {
		fields = append(fields, essay.FieldDraft)
	}
	if m.images != nil {
		fields = append(fields, essay.FieldImages)
	}
	if m.like_count != nil {
		fields = append(fields, essay.FieldLikeCount)
	}
	if m.comment_count != nil {
		fields = append(fields, essay.FieldCommentCount)
	}
	if m.share_count != nil {
		fields = append(fields, essay.FieldShareCount)
	}
	if m.public != nil {
		fields = append(fields, essay.FieldPublic)
	}
	if m.location != nil {
		fields = append(fields, essay.FieldLocation)
	}
	if m.tags != nil {
		fields = append(fields, essay.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EssayMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case essay.FieldCreatedAt:
		return m.CreatedAt()
	case essay.FieldUpdatedAt:
		return m.UpdatedAt()
	case essay.FieldUserID:
		return m.UserID()
	case essay.FieldContent:
		return m.Content()
	case essay.FieldDraft:
		return m.Draft()
	case essay.FieldImages:
		return m.Images()
	case essay.FieldLikeCount:
		return m.LikeCount()
	case essay.FieldCommentCount:
		return m.CommentCount()
	case essay.FieldShareCount:
		return m.ShareCount()
	case essay.FieldPublic:
		return m.Public()
	case essay.FieldLocation:
		return m.Location()
	case essay.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EssayMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case essay.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case essay.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case essay.FieldUserID:
		return m.OldUserID(ctx)
	case essay.FieldContent:
		return m.OldContent(ctx)
	case essay.FieldDraft:
		return m.OldDraft(ctx)
	case essay.FieldImages:
		return m.OldImages(ctx)
	case essay.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case essay.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case essay.FieldShareCount:
		return m.OldShareCount(ctx)
	case essay.FieldPublic:
		return m.OldPublic(ctx)
	case essay.FieldLocation:
		return m.OldLocation(ctx)
	case essay.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Essay field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EssayMutation) SetField(name string, value ent.Value) error {
	switch name {
	case essay.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case essay.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case essay.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case essay.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case essay.FieldDraft:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDraft(v)
		return nil
	case essay.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case essay.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case essay.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case essay.FieldShareCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShareCount(v)
		return nil
	case essay.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case essay.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case essay.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Essay field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EssayMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, essay.FieldUserID)
	}
	if m.addlike_count != nil {
		fields = append(fields, essay.FieldLikeCount)
	}
	if m.addcomment_count != nil {
		fields = append(fields, essay.FieldCommentCount)
	}
	if m.addshare_count != nil {
		fields = append(fields, essay.FieldShareCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EssayMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case essay.FieldUserID:
		return m.AddedUserID()
	case essay.FieldLikeCount:
		return m.AddedLikeCount()
	case essay.FieldCommentCount:
		return m.AddedCommentCount()
	case essay.FieldShareCount:
		return m.AddedShareCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EssayMutation) AddField(name string, value ent.Value) error {
	switch name {
	case essay.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case essay.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case essay.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	case essay.FieldShareCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShareCount(v)
		return nil
	}
	return fmt.Errorf("unknown Essay numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EssayMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(essay.FieldImages) {
		fields = append(fields, essay.FieldImages)
	}
	if m.FieldCleared(essay.FieldLocation) {
		fields = append(fields, essay.FieldLocation)
	}
	if m.FieldCleared(essay.FieldTags) {
		fields = append(fields, essay.FieldTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EssayMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EssayMutation) ClearField(name string) error {
	switch name {
	case essay.FieldImages:
		m.ClearImages()
		return nil
	case essay.FieldLocation:
		m.ClearLocation()
		return nil
	case essay.FieldTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown Essay nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EssayMutation) ResetField(name string) error {
	switch name {
	case essay.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case essay.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case essay.FieldUserID:
		m.ResetUserID()
		return nil
	case essay.FieldContent:
		m.ResetContent()
		return nil
	case essay.FieldDraft:
		m.ResetDraft()
		return nil
	case essay.FieldImages:
		m.ResetImages()
		return nil
	case essay.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case essay.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case essay.FieldShareCount:
		m.ResetShareCount()
		return nil
	case essay.FieldPublic:
		m.ResetPublic()
		return nil
	case essay.FieldLocation:
		m.ResetLocation()
		return nil
	case essay.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Essay field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EssayMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EssayMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EssayMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EssayMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EssayMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EssayMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EssayMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Essay unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EssayMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Essay edge %s", name)
}

// FLinkMutation represents an operation that mutates the FLink nodes in the graph.
type FLinkMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	name                     *string
	url                      *string
	avatar_url               *string
	description              *string
	status                   *int
	addstatus                *int
	snapshot_url             *string
	cover_url                *string
	email                    *string
	enable_friend_circle     *bool
	friend_circle_rule_id    *int
	addfriend_circle_rule_id *int
	clearedFields            map[string]struct{}
	group                    *int
	clearedgroup             bool
	done                     bool
	oldValue                 func(context.Context) (*FLink, error)
	predicates               []predicate.FLink
}

var _ ent.Mutation = (*FLinkMutation)(nil)

// flinkOption allows management of the mutation configuration using functional options.
type flinkOption func(*FLinkMutation)

// newFLinkMutation creates new mutation for the FLink entity.
func newFLinkMutation(c config, op Op, opts ...flinkOption) *FLinkMutation {
	m := &FLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeFLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFLinkID sets the ID field of the mutation.
func withFLinkID(id int) flinkOption {
	return func(m *FLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *FLink
		)
		m.oldValue = func(ctx context.Context) (*FLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFLink sets the old FLink of the mutation.
func withFLink(node *FLink) flinkOption {
	return func(m *FLinkMutation) {
		m.oldValue = func(context.Context) (*FLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FLink entities.
func (m *FLinkMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FLinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FLinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FLinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FLinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *FLinkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FLinkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FLinkMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *FLinkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *FLinkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *FLinkMutation) ResetURL() {
	m.url = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *FLinkMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *FLinkMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *FLinkMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[flink.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *FLinkMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[flink.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *FLinkMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, flink.FieldAvatarURL)
}

// SetDescription sets the "description" field.
func (m *FLinkMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FLinkMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FLinkMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[flink.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FLinkMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[flink.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FLinkMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, flink.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *FLinkMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FLinkMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *FLinkMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FLinkMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *FLinkMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetSnapshotURL sets the "snapshot_url" field.
func (m *FLinkMutation) SetSnapshotURL(s string) {
	m.snapshot_url = &s
}

// SnapshotURL returns the value of the "snapshot_url" field in the mutation.
func (m *FLinkMutation) SnapshotURL() (r string, exists bool) {
	v := m.snapshot_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshotURL returns the old "snapshot_url" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldSnapshotURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshotURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshotURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshotURL: %w", err)
	}
	return oldValue.SnapshotURL, nil
}

// ClearSnapshotURL clears the value of the "snapshot_url" field.
func (m *FLinkMutation) ClearSnapshotURL() {
	m.snapshot_url = nil
	m.clearedFields[flink.FieldSnapshotURL] = struct{}{}
}

// SnapshotURLCleared returns if the "snapshot_url" field was cleared in this mutation.
func (m *FLinkMutation) SnapshotURLCleared() bool {
	_, ok := m.clearedFields[flink.FieldSnapshotURL]
	return ok
}

// ResetSnapshotURL resets all changes to the "snapshot_url" field.
func (m *FLinkMutation) ResetSnapshotURL() {
	m.snapshot_url = nil
	delete(m.clearedFields, flink.FieldSnapshotURL)
}

// SetCoverURL sets the "cover_url" field.
func (m *FLinkMutation) SetCoverURL(s string) {
	m.cover_url = &s
}

// CoverURL returns the value of the "cover_url" field in the mutation.
func (m *FLinkMutation) CoverURL() (r string, exists bool) {
	v := m.cover_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverURL returns the old "cover_url" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldCoverURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverURL: %w", err)
	}
	return oldValue.CoverURL, nil
}

// ClearCoverURL clears the value of the "cover_url" field.
func (m *FLinkMutation) ClearCoverURL() {
	m.cover_url = nil
	m.clearedFields[flink.FieldCoverURL] = struct{}{}
}

// CoverURLCleared returns if the "cover_url" field was cleared in this mutation.
func (m *FLinkMutation) CoverURLCleared() bool {
	_, ok := m.clearedFields[flink.FieldCoverURL]
	return ok
}

// ResetCoverURL resets all changes to the "cover_url" field.
func (m *FLinkMutation) ResetCoverURL() {
	m.cover_url = nil
	delete(m.clearedFields, flink.FieldCoverURL)
}

// SetEmail sets the "email" field.
func (m *FLinkMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *FLinkMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *FLinkMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[flink.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *FLinkMutation) EmailCleared() bool {
	_, ok := m.clearedFields[flink.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *FLinkMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, flink.FieldEmail)
}

// SetGroupID sets the "group_id" field.
func (m *FLinkMutation) SetGroupID(i int) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *FLinkMutation) GroupID() (r int, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldGroupID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *FLinkMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[flink.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *FLinkMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[flink.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *FLinkMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, flink.FieldGroupID)
}

// SetEnableFriendCircle sets the "enable_friend_circle" field.
func (m *FLinkMutation) SetEnableFriendCircle(b bool) {
	m.enable_friend_circle = &b
}

// EnableFriendCircle returns the value of the "enable_friend_circle" field in the mutation.
func (m *FLinkMutation) EnableFriendCircle() (r bool, exists bool) {
	v := m.enable_friend_circle
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableFriendCircle returns the old "enable_friend_circle" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldEnableFriendCircle(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableFriendCircle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableFriendCircle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableFriendCircle: %w", err)
	}
	return oldValue.EnableFriendCircle, nil
}

// ResetEnableFriendCircle resets all changes to the "enable_friend_circle" field.
func (m *FLinkMutation) ResetEnableFriendCircle() {
	m.enable_friend_circle = nil
}

// SetFriendCircleRuleID sets the "friend_circle_rule_id" field.
func (m *FLinkMutation) SetFriendCircleRuleID(i int) {
	m.friend_circle_rule_id = &i
	m.addfriend_circle_rule_id = nil
}

// FriendCircleRuleID returns the value of the "friend_circle_rule_id" field in the mutation.
func (m *FLinkMutation) FriendCircleRuleID() (r int, exists bool) {
	v := m.friend_circle_rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendCircleRuleID returns the old "friend_circle_rule_id" field's value of the FLink entity.
// If the FLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkMutation) OldFriendCircleRuleID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendCircleRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendCircleRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendCircleRuleID: %w", err)
	}
	return oldValue.FriendCircleRuleID, nil
}

// AddFriendCircleRuleID adds i to the "friend_circle_rule_id" field.
func (m *FLinkMutation) AddFriendCircleRuleID(i int) {
	if m.addfriend_circle_rule_id != nil {
		*m.addfriend_circle_rule_id += i
	} else {
		m.addfriend_circle_rule_id = &i
	}
}

// AddedFriendCircleRuleID returns the value that was added to the "friend_circle_rule_id" field in this mutation.
func (m *FLinkMutation) AddedFriendCircleRuleID() (r int, exists bool) {
	v := m.addfriend_circle_rule_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFriendCircleRuleID clears the value of the "friend_circle_rule_id" field.
func (m *FLinkMutation) ClearFriendCircleRuleID() {
	m.friend_circle_rule_id = nil
	m.addfriend_circle_rule_id = nil
	m.clearedFields[flink.FieldFriendCircleRuleID] = struct{}{}
}

// FriendCircleRuleIDCleared returns if the "friend_circle_rule_id" field was cleared in this mutation.
func (m *FLinkMutation) FriendCircleRuleIDCleared() bool {
	_, ok := m.clearedFields[flink.FieldFriendCircleRuleID]
	return ok
}

// ResetFriendCircleRuleID resets all changes to the "friend_circle_rule_id" field.
func (m *FLinkMutation) ResetFriendCircleRuleID() {
	m.friend_circle_rule_id = nil
	m.addfriend_circle_rule_id = nil
	delete(m.clearedFields, flink.FieldFriendCircleRuleID)
}

// ClearGroup clears the "group" edge to the FLinkGroup entity.
func (m *FLinkMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[flink.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the FLinkGroup entity was cleared.
func (m *FLinkMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *FLinkMutation) GroupIDs() (ids []int) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *FLinkMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the FLinkMutation builder.
func (m *FLinkMutation) Where(ps ...predicate.FLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FLink).
func (m *FLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FLinkMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, flink.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flink.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, flink.FieldName)
	}
	if m.url != nil {
		fields = append(fields, flink.FieldURL)
	}
	if m.avatar_url != nil {
		fields = append(fields, flink.FieldAvatarURL)
	}
	if m.description != nil {
		fields = append(fields, flink.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, flink.FieldStatus)
	}
	if m.snapshot_url != nil {
		fields = append(fields, flink.FieldSnapshotURL)
	}
	if m.cover_url != nil {
		fields = append(fields, flink.FieldCoverURL)
	}
	if m.email != nil {
		fields = append(fields, flink.FieldEmail)
	}
	if m.group != nil {
		fields = append(fields, flink.FieldGroupID)
	}
	if m.enable_friend_circle != nil {
		fields = append(fields, flink.FieldEnableFriendCircle)
	}
	if m.friend_circle_rule_id != nil {
		fields = append(fields, flink.FieldFriendCircleRuleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flink.FieldCreatedAt:
		return m.CreatedAt()
	case flink.FieldUpdatedAt:
		return m.UpdatedAt()
	case flink.FieldName:
		return m.Name()
	case flink.FieldURL:
		return m.URL()
	case flink.FieldAvatarURL:
		return m.AvatarURL()
	case flink.FieldDescription:
		return m.Description()
	case flink.FieldStatus:
		return m.Status()
	case flink.FieldSnapshotURL:
		return m.SnapshotURL()
	case flink.FieldCoverURL:
		return m.CoverURL()
	case flink.FieldEmail:
		return m.Email()
	case flink.FieldGroupID:
		return m.GroupID()
	case flink.FieldEnableFriendCircle:
		return m.EnableFriendCircle()
	case flink.FieldFriendCircleRuleID:
		return m.FriendCircleRuleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flink.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case flink.FieldName:
		return m.OldName(ctx)
	case flink.FieldURL:
		return m.OldURL(ctx)
	case flink.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case flink.FieldDescription:
		return m.OldDescription(ctx)
	case flink.FieldStatus:
		return m.OldStatus(ctx)
	case flink.FieldSnapshotURL:
		return m.OldSnapshotURL(ctx)
	case flink.FieldCoverURL:
		return m.OldCoverURL(ctx)
	case flink.FieldEmail:
		return m.OldEmail(ctx)
	case flink.FieldGroupID:
		return m.OldGroupID(ctx)
	case flink.FieldEnableFriendCircle:
		return m.OldEnableFriendCircle(ctx)
	case flink.FieldFriendCircleRuleID:
		return m.OldFriendCircleRuleID(ctx)
	}
	return nil, fmt.Errorf("unknown FLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flink.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case flink.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case flink.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case flink.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case flink.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case flink.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case flink.FieldSnapshotURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshotURL(v)
		return nil
	case flink.FieldCoverURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverURL(v)
		return nil
	case flink.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case flink.FieldGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case flink.FieldEnableFriendCircle:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableFriendCircle(v)
		return nil
	case flink.FieldFriendCircleRuleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendCircleRuleID(v)
		return nil
	}
	return fmt.Errorf("unknown FLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FLinkMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, flink.FieldStatus)
	}
	if m.addfriend_circle_rule_id != nil {
		fields = append(fields, flink.FieldFriendCircleRuleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flink.FieldStatus:
		return m.AddedStatus()
	case flink.FieldFriendCircleRuleID:
		return m.AddedFriendCircleRuleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flink.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case flink.FieldFriendCircleRuleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFriendCircleRuleID(v)
		return nil
	}
	return fmt.Errorf("unknown FLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flink.FieldAvatarURL) {
		fields = append(fields, flink.FieldAvatarURL)
	}
	if m.FieldCleared(flink.FieldDescription) {
		fields = append(fields, flink.FieldDescription)
	}
	if m.FieldCleared(flink.FieldSnapshotURL) {
		fields = append(fields, flink.FieldSnapshotURL)
	}
	if m.FieldCleared(flink.FieldCoverURL) {
		fields = append(fields, flink.FieldCoverURL)
	}
	if m.FieldCleared(flink.FieldEmail) {
		fields = append(fields, flink.FieldEmail)
	}
	if m.FieldCleared(flink.FieldGroupID) {
		fields = append(fields, flink.FieldGroupID)
	}
	if m.FieldCleared(flink.FieldFriendCircleRuleID) {
		fields = append(fields, flink.FieldFriendCircleRuleID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FLinkMutation) ClearField(name string) error {
	switch name {
	case flink.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case flink.FieldDescription:
		m.ClearDescription()
		return nil
	case flink.FieldSnapshotURL:
		m.ClearSnapshotURL()
		return nil
	case flink.FieldCoverURL:
		m.ClearCoverURL()
		return nil
	case flink.FieldEmail:
		m.ClearEmail()
		return nil
	case flink.FieldGroupID:
		m.ClearGroupID()
		return nil
	case flink.FieldFriendCircleRuleID:
		m.ClearFriendCircleRuleID()
		return nil
	}
	return fmt.Errorf("unknown FLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FLinkMutation) ResetField(name string) error {
	switch name {
	case flink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flink.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case flink.FieldName:
		m.ResetName()
		return nil
	case flink.FieldURL:
		m.ResetURL()
		return nil
	case flink.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case flink.FieldDescription:
		m.ResetDescription()
		return nil
	case flink.FieldStatus:
		m.ResetStatus()
		return nil
	case flink.FieldSnapshotURL:
		m.ResetSnapshotURL()
		return nil
	case flink.FieldCoverURL:
		m.ResetCoverURL()
		return nil
	case flink.FieldEmail:
		m.ResetEmail()
		return nil
	case flink.FieldGroupID:
		m.ResetGroupID()
		return nil
	case flink.FieldEnableFriendCircle:
		m.ResetEnableFriendCircle()
		return nil
	case flink.FieldFriendCircleRuleID:
		m.ResetFriendCircleRuleID()
		return nil
	}
	return fmt.Errorf("unknown FLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.group != nil {
		edges = append(edges, flink.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flink.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgroup {
		edges = append(edges, flink.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case flink.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FLinkMutation) ClearEdge(name string) error {
	switch name {
	case flink.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown FLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FLinkMutation) ResetEdge(name string) error {
	switch name {
	case flink.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown FLink edge %s", name)
}

// FLinkApplicationMutation represents an operation that mutates the FLinkApplication nodes in the graph.
type FLinkApplicationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	website_url          *string
	application_type     *string
	website_name         *string
	website_logo         *string
	website_description  *string
	contact_email        *string
	snapshot_url         *string
	original_website_url *string
	modification_reason  *string
	status               *int
	addstatus            *int
	reject_reason        *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*FLinkApplication, error)
	predicates           []predicate.FLinkApplication
}

var _ ent.Mutation = (*FLinkApplicationMutation)(nil)

// flinkapplicationOption allows management of the mutation configuration using functional options.
type flinkapplicationOption func(*FLinkApplicationMutation)

// newFLinkApplicationMutation creates new mutation for the FLinkApplication entity.
func newFLinkApplicationMutation(c config, op Op, opts ...flinkapplicationOption) *FLinkApplicationMutation {
	m := &FLinkApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeFLinkApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFLinkApplicationID sets the ID field of the mutation.
func withFLinkApplicationID(id int) flinkapplicationOption {
	return func(m *FLinkApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *FLinkApplication
		)
		m.oldValue = func(ctx context.Context) (*FLinkApplication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FLinkApplication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFLinkApplication sets the old FLinkApplication of the mutation.
func withFLinkApplication(node *FLinkApplication) flinkapplicationOption {
	return func(m *FLinkApplicationMutation) {
		m.oldValue = func(context.Context) (*FLinkApplication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FLinkApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FLinkApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FLinkApplication entities.
func (m *FLinkApplicationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FLinkApplicationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FLinkApplicationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FLinkApplication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FLinkApplicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FLinkApplicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FLinkApplicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FLinkApplicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FLinkApplicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FLinkApplicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWebsiteURL sets the "website_url" field.
func (m *FLinkApplicationMutation) SetWebsiteURL(s string) {
	m.website_url = &s
}

// WebsiteURL returns the value of the "website_url" field in the mutation.
func (m *FLinkApplicationMutation) WebsiteURL() (r string, exists bool) {
	v := m.website_url
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsiteURL returns the old "website_url" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldWebsiteURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsiteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsiteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsiteURL: %w", err)
	}
	return oldValue.WebsiteURL, nil
}

// ResetWebsiteURL resets all changes to the "website_url" field.
func (m *FLinkApplicationMutation) ResetWebsiteURL() {
	m.website_url = nil
}

// SetApplicationType sets the "application_type" field.
func (m *FLinkApplicationMutation) SetApplicationType(s string) {
	m.application_type = &s
}

// ApplicationType returns the value of the "application_type" field in the mutation.
func (m *FLinkApplicationMutation) ApplicationType() (r string, exists bool) {
	v := m.application_type
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationType returns the old "application_type" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldApplicationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationType: %w", err)
	}
	return oldValue.ApplicationType, nil
}

// ResetApplicationType resets all changes to the "application_type" field.
func (m *FLinkApplicationMutation) ResetApplicationType() {
	m.application_type = nil
}

// SetWebsiteName sets the "website_name" field.
func (m *FLinkApplicationMutation) SetWebsiteName(s string) {
	m.website_name = &s
}

// WebsiteName returns the value of the "website_name" field in the mutation.
func (m *FLinkApplicationMutation) WebsiteName() (r string, exists bool) {
	v := m.website_name
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsiteName returns the old "website_name" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldWebsiteName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsiteName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsiteName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsiteName: %w", err)
	}
	return oldValue.WebsiteName, nil
}

// ResetWebsiteName resets all changes to the "website_name" field.
func (m *FLinkApplicationMutation) ResetWebsiteName() {
	m.website_name = nil
}

// SetWebsiteLogo sets the "website_logo" field.
func (m *FLinkApplicationMutation) SetWebsiteLogo(s string) {
	m.website_logo = &s
}

// WebsiteLogo returns the value of the "website_logo" field in the mutation.
func (m *FLinkApplicationMutation) WebsiteLogo() (r string, exists bool) {
	v := m.website_logo
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsiteLogo returns the old "website_logo" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldWebsiteLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsiteLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsiteLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsiteLogo: %w", err)
	}
	return oldValue.WebsiteLogo, nil
}

// ResetWebsiteLogo resets all changes to the "website_logo" field.
func (m *FLinkApplicationMutation) ResetWebsiteLogo() {
	m.website_logo = nil
}

// SetWebsiteDescription sets the "website_description" field.
func (m *FLinkApplicationMutation) SetWebsiteDescription(s string) {
	m.website_description = &s
}

// WebsiteDescription returns the value of the "website_description" field in the mutation.
func (m *FLinkApplicationMutation) WebsiteDescription() (r string, exists bool) {
	v := m.website_description
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsiteDescription returns the old "website_description" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldWebsiteDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsiteDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsiteDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsiteDescription: %w", err)
	}
	return oldValue.WebsiteDescription, nil
}

// ResetWebsiteDescription resets all changes to the "website_description" field.
func (m *FLinkApplicationMutation) ResetWebsiteDescription() {
	m.website_description = nil
}

// SetContactEmail sets the "contact_email" field.
func (m *FLinkApplicationMutation) SetContactEmail(s string) {
	m.contact_email = &s
}

// ContactEmail returns the value of the "contact_email" field in the mutation.
func (m *FLinkApplicationMutation) ContactEmail() (r string, exists bool) {
	v := m.contact_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactEmail returns the old "contact_email" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldContactEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactEmail: %w", err)
	}
	return oldValue.ContactEmail, nil
}

// ResetContactEmail resets all changes to the "contact_email" field.
func (m *FLinkApplicationMutation) ResetContactEmail() {
	m.contact_email = nil
}

// SetSnapshotURL sets the "snapshot_url" field.
func (m *FLinkApplicationMutation) SetSnapshotURL(s string) {
	m.snapshot_url = &s
}

// SnapshotURL returns the value of the "snapshot_url" field in the mutation.
func (m *FLinkApplicationMutation) SnapshotURL() (r string, exists bool) {
	v := m.snapshot_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapshotURL returns the old "snapshot_url" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldSnapshotURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSnapshotURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSnapshotURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapshotURL: %w", err)
	}
	return oldValue.SnapshotURL, nil
}

// ClearSnapshotURL clears the value of the "snapshot_url" field.
func (m *FLinkApplicationMutation) ClearSnapshotURL() {
	m.snapshot_url = nil
	m.clearedFields[flinkapplication.FieldSnapshotURL] = struct{}{}
}

// SnapshotURLCleared returns if the "snapshot_url" field was cleared in this mutation.
func (m *FLinkApplicationMutation) SnapshotURLCleared() bool {
	_, ok := m.clearedFields[flinkapplication.FieldSnapshotURL]
	return ok
}

// ResetSnapshotURL resets all changes to the "snapshot_url" field.
func (m *FLinkApplicationMutation) ResetSnapshotURL() {
	m.snapshot_url = nil
	delete(m.clearedFields, flinkapplication.FieldSnapshotURL)
}

// SetOriginalWebsiteURL sets the "original_website_url" field.
func (m *FLinkApplicationMutation) SetOriginalWebsiteURL(s string) {
	m.original_website_url = &s
}

// OriginalWebsiteURL returns the value of the "original_website_url" field in the mutation.
func (m *FLinkApplicationMutation) OriginalWebsiteURL() (r string, exists bool) {
	v := m.original_website_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalWebsiteURL returns the old "original_website_url" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldOriginalWebsiteURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalWebsiteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalWebsiteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalWebsiteURL: %w", err)
	}
	return oldValue.OriginalWebsiteURL, nil
}

// ClearOriginalWebsiteURL clears the value of the "original_website_url" field.
func (m *FLinkApplicationMutation) ClearOriginalWebsiteURL() {
	m.original_website_url = nil
	m.clearedFields[flinkapplication.FieldOriginalWebsiteURL] = struct{}{}
}

// OriginalWebsiteURLCleared returns if the "original_website_url" field was cleared in this mutation.
func (m *FLinkApplicationMutation) OriginalWebsiteURLCleared() bool {
	_, ok := m.clearedFields[flinkapplication.FieldOriginalWebsiteURL]
	return ok
}

// ResetOriginalWebsiteURL resets all changes to the "original_website_url" field.
func (m *FLinkApplicationMutation) ResetOriginalWebsiteURL() {
	m.original_website_url = nil
	delete(m.clearedFields, flinkapplication.FieldOriginalWebsiteURL)
}

// SetModificationReason sets the "modification_reason" field.
func (m *FLinkApplicationMutation) SetModificationReason(s string) {
	m.modification_reason = &s
}

// ModificationReason returns the value of the "modification_reason" field in the mutation.
func (m *FLinkApplicationMutation) ModificationReason() (r string, exists bool) {
	v := m.modification_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldModificationReason returns the old "modification_reason" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldModificationReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModificationReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModificationReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModificationReason: %w", err)
	}
	return oldValue.ModificationReason, nil
}

// ClearModificationReason clears the value of the "modification_reason" field.
func (m *FLinkApplicationMutation) ClearModificationReason() {
	m.modification_reason = nil
	m.clearedFields[flinkapplication.FieldModificationReason] = struct{}{}
}

// ModificationReasonCleared returns if the "modification_reason" field was cleared in this mutation.
func (m *FLinkApplicationMutation) ModificationReasonCleared() bool {
	_, ok := m.clearedFields[flinkapplication.FieldModificationReason]
	return ok
}

// ResetModificationReason resets all changes to the "modification_reason" field.
func (m *FLinkApplicationMutation) ResetModificationReason() {
	m.modification_reason = nil
	delete(m.clearedFields, flinkapplication.FieldModificationReason)
}

// SetStatus sets the "status" field.
func (m *FLinkApplicationMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FLinkApplicationMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *FLinkApplicationMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FLinkApplicationMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *FLinkApplicationMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetRejectReason sets the "reject_reason" field.
func (m *FLinkApplicationMutation) SetRejectReason(s string) {
	m.reject_reason = &s
}

// RejectReason returns the value of the "reject_reason" field in the mutation.
func (m *FLinkApplicationMutation) RejectReason() (r string, exists bool) {
	v := m.reject_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectReason returns the old "reject_reason" field's value of the FLinkApplication entity.
// If the FLinkApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkApplicationMutation) OldRejectReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectReason: %w", err)
	}
	return oldValue.RejectReason, nil
}

// ClearRejectReason clears the value of the "reject_reason" field.
func (m *FLinkApplicationMutation) ClearRejectReason() {
	m.reject_reason = nil
	m.clearedFields[flinkapplication.FieldRejectReason] = struct{}{}
}

// RejectReasonCleared returns if the "reject_reason" field was cleared in this mutation.
func (m *FLinkApplicationMutation) RejectReasonCleared() bool {
	_, ok := m.clearedFields[flinkapplication.FieldRejectReason]
	return ok
}

// ResetRejectReason resets all changes to the "reject_reason" field.
func (m *FLinkApplicationMutation) ResetRejectReason() {
	m.reject_reason = nil
	delete(m.clearedFields, flinkapplication.FieldRejectReason)
}

// Where appends a list predicates to the FLinkApplicationMutation builder.
func (m *FLinkApplicationMutation) Where(ps ...predicate.FLinkApplication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FLinkApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FLinkApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FLinkApplication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FLinkApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FLinkApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FLinkApplication).
func (m *FLinkApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FLinkApplicationMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, flinkapplication.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flinkapplication.FieldUpdatedAt)
	}
	if m.website_url != nil {
		fields = append(fields, flinkapplication.FieldWebsiteURL)
	}
	if m.application_type != nil {
		fields = append(fields, flinkapplication.FieldApplicationType)
	}
	if m.website_name != nil {
		fields = append(fields, flinkapplication.FieldWebsiteName)
	}
	if m.website_logo != nil {
		fields = append(fields, flinkapplication.FieldWebsiteLogo)
	}
	if m.website_description != nil {
		fields = append(fields, flinkapplication.FieldWebsiteDescription)
	}
	if m.contact_email != nil {
		fields = append(fields, flinkapplication.FieldContactEmail)
	}
	if m.snapshot_url != nil {
		fields = append(fields, flinkapplication.FieldSnapshotURL)
	}
	if m.original_website_url != nil {
		fields = append(fields, flinkapplication.FieldOriginalWebsiteURL)
	}
	if m.modification_reason != nil {
		fields = append(fields, flinkapplication.FieldModificationReason)
	}
	if m.status != nil {
		fields = append(fields, flinkapplication.FieldStatus)
	}
	if m.reject_reason != nil {
		fields = append(fields, flinkapplication.FieldRejectReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FLinkApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flinkapplication.FieldCreatedAt:
		return m.CreatedAt()
	case flinkapplication.FieldUpdatedAt:
		return m.UpdatedAt()
	case flinkapplication.FieldWebsiteURL:
		return m.WebsiteURL()
	case flinkapplication.FieldApplicationType:
		return m.ApplicationType()
	case flinkapplication.FieldWebsiteName:
		return m.WebsiteName()
	case flinkapplication.FieldWebsiteLogo:
		return m.WebsiteLogo()
	case flinkapplication.FieldWebsiteDescription:
		return m.WebsiteDescription()
	case flinkapplication.FieldContactEmail:
		return m.ContactEmail()
	case flinkapplication.FieldSnapshotURL:
		return m.SnapshotURL()
	case flinkapplication.FieldOriginalWebsiteURL:
		return m.OriginalWebsiteURL()
	case flinkapplication.FieldModificationReason:
		return m.ModificationReason()
	case flinkapplication.FieldStatus:
		return m.Status()
	case flinkapplication.FieldRejectReason:
		return m.RejectReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FLinkApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flinkapplication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flinkapplication.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case flinkapplication.FieldWebsiteURL:
		return m.OldWebsiteURL(ctx)
	case flinkapplication.FieldApplicationType:
		return m.OldApplicationType(ctx)
	case flinkapplication.FieldWebsiteName:
		return m.OldWebsiteName(ctx)
	case flinkapplication.FieldWebsiteLogo:
		return m.OldWebsiteLogo(ctx)
	case flinkapplication.FieldWebsiteDescription:
		return m.OldWebsiteDescription(ctx)
	case flinkapplication.FieldContactEmail:
		return m.OldContactEmail(ctx)
	case flinkapplication.FieldSnapshotURL:
		return m.OldSnapshotURL(ctx)
	case flinkapplication.FieldOriginalWebsiteURL:
		return m.OldOriginalWebsiteURL(ctx)
	case flinkapplication.FieldModificationReason:
		return m.OldModificationReason(ctx)
	case flinkapplication.FieldStatus:
		return m.OldStatus(ctx)
	case flinkapplication.FieldRejectReason:
		return m.OldRejectReason(ctx)
	}
	return nil, fmt.Errorf("unknown FLinkApplication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FLinkApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flinkapplication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flinkapplication.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case flinkapplication.FieldWebsiteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsiteURL(v)
		return nil
	case flinkapplication.FieldApplicationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationType(v)
		return nil
	case flinkapplication.FieldWebsiteName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsiteName(v)
		return nil
	case flinkapplication.FieldWebsiteLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsiteLogo(v)
		return nil
	case flinkapplication.FieldWebsiteDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsiteDescription(v)
		return nil
	case flinkapplication.FieldContactEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactEmail(v)
		return nil
	case flinkapplication.FieldSnapshotURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapshotURL(v)
		return nil
	case flinkapplication.FieldOriginalWebsiteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalWebsiteURL(v)
		return nil
	case flinkapplication.FieldModificationReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModificationReason(v)
		return nil
	case flinkapplication.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case flinkapplication.FieldRejectReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectReason(v)
		return nil
	}
	return fmt.Errorf("unknown FLinkApplication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FLinkApplicationMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, flinkapplication.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FLinkApplicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flinkapplication.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FLinkApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flinkapplication.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown FLinkApplication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FLinkApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flinkapplication.FieldSnapshotURL) {
		fields = append(fields, flinkapplication.FieldSnapshotURL)
	}
	if m.FieldCleared(flinkapplication.FieldOriginalWebsiteURL) {
		fields = append(fields, flinkapplication.FieldOriginalWebsiteURL)
	}
	if m.FieldCleared(flinkapplication.FieldModificationReason) {
		fields = append(fields, flinkapplication.FieldModificationReason)
	}
	if m.FieldCleared(flinkapplication.FieldRejectReason) {
		fields = append(fields, flinkapplication.FieldRejectReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FLinkApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FLinkApplicationMutation) ClearField(name string) error {
	switch name {
	case flinkapplication.FieldSnapshotURL:
		m.ClearSnapshotURL()
		return nil
	case flinkapplication.FieldOriginalWebsiteURL:
		m.ClearOriginalWebsiteURL()
		return nil
	case flinkapplication.FieldModificationReason:
		m.ClearModificationReason()
		return nil
	case flinkapplication.FieldRejectReason:
		m.ClearRejectReason()
		return nil
	}
	return fmt.Errorf("unknown FLinkApplication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FLinkApplicationMutation) ResetField(name string) error {
	switch name {
	case flinkapplication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flinkapplication.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case flinkapplication.FieldWebsiteURL:
		m.ResetWebsiteURL()
		return nil
	case flinkapplication.FieldApplicationType:
		m.ResetApplicationType()
		return nil
	case flinkapplication.FieldWebsiteName:
		m.ResetWebsiteName()
		return nil
	case flinkapplication.FieldWebsiteLogo:
		m.ResetWebsiteLogo()
		return nil
	case flinkapplication.FieldWebsiteDescription:
		m.ResetWebsiteDescription()
		return nil
	case flinkapplication.FieldContactEmail:
		m.ResetContactEmail()
		return nil
	case flinkapplication.FieldSnapshotURL:
		m.ResetSnapshotURL()
		return nil
	case flinkapplication.FieldOriginalWebsiteURL:
		m.ResetOriginalWebsiteURL()
		return nil
	case flinkapplication.FieldModificationReason:
		m.ResetModificationReason()
		return nil
	case flinkapplication.FieldStatus:
		m.ResetStatus()
		return nil
	case flinkapplication.FieldRejectReason:
		m.ResetRejectReason()
		return nil
	}
	return fmt.Errorf("unknown FLinkApplication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FLinkApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FLinkApplicationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FLinkApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FLinkApplicationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FLinkApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FLinkApplicationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FLinkApplicationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FLinkApplication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FLinkApplicationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FLinkApplication edge %s", name)
}

// FLinkGroupMutation represents an operation that mutates the FLinkGroup nodes in the graph.
type FLinkGroupMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	description   *string
	clearedFields map[string]struct{}
	links         map[int]struct{}
	removedlinks  map[int]struct{}
	clearedlinks  bool
	done          bool
	oldValue      func(context.Context) (*FLinkGroup, error)
	predicates    []predicate.FLinkGroup
}

var _ ent.Mutation = (*FLinkGroupMutation)(nil)

// flinkgroupOption allows management of the mutation configuration using functional options.
type flinkgroupOption func(*FLinkGroupMutation)

// newFLinkGroupMutation creates new mutation for the FLinkGroup entity.
func newFLinkGroupMutation(c config, op Op, opts ...flinkgroupOption) *FLinkGroupMutation {
	m := &FLinkGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeFLinkGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFLinkGroupID sets the ID field of the mutation.
func withFLinkGroupID(id int) flinkgroupOption {
	return func(m *FLinkGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *FLinkGroup
		)
		m.oldValue = func(ctx context.Context) (*FLinkGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FLinkGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFLinkGroup sets the old FLinkGroup of the mutation.
func withFLinkGroup(node *FLinkGroup) flinkgroupOption {
	return func(m *FLinkGroupMutation) {
		m.oldValue = func(context.Context) (*FLinkGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FLinkGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FLinkGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FLinkGroup entities.
func (m *FLinkGroupMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FLinkGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FLinkGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FLinkGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FLinkGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FLinkGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FLinkGroup entity.
// If the FLinkGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FLinkGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FLinkGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FLinkGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FLinkGroup entity.
// If the FLinkGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FLinkGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *FLinkGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FLinkGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FLinkGroup entity.
// If the FLinkGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FLinkGroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *FLinkGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FLinkGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FLinkGroup entity.
// If the FLinkGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FLinkGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FLinkGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[flinkgroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FLinkGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[flinkgroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FLinkGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, flinkgroup.FieldDescription)
}

// AddLinkIDs adds the "links" edge to the FLink entity by ids.
func (m *FLinkGroupMutation) AddLinkIDs(ids ...int) {
	if m.links == nil {
		m.links = make(map[int]struct{})
	}
	for i := range ids {
		m.links[ids[i]] = struct{}{}
	}
}

// ClearLinks clears the "links" edge to the FLink entity.
func (m *FLinkGroupMutation) ClearLinks() {
	m.clearedlinks = true
}

// LinksCleared reports if the "links" edge to the FLink entity was cleared.
func (m *FLinkGroupMutation) LinksCleared() bool {
	return m.clearedlinks
}

// RemoveLinkIDs removes the "links" edge to the FLink entity by IDs.
func (m *FLinkGroupMutation) RemoveLinkIDs(ids ...int) {
	if m.removedlinks == nil {
		m.removedlinks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.links, ids[i])
		m.removedlinks[ids[i]] = struct{}{}
	}
}

// RemovedLinks returns the removed IDs of the "links" edge to the FLink entity.
func (m *FLinkGroupMutation) RemovedLinksIDs() (ids []int) {
	for id := range m.removedlinks {
		ids = append(ids, id)
	}
	return
}

// LinksIDs returns the "links" edge IDs in the mutation.
func (m *FLinkGroupMutation) LinksIDs() (ids []int) {
	for id := range m.links {
		ids = append(ids, id)
	}
	return
}

// ResetLinks resets all changes to the "links" edge.
func (m *FLinkGroupMutation) ResetLinks() {
	m.links = nil
	m.clearedlinks = false
	m.removedlinks = nil
}

// Where appends a list predicates to the FLinkGroupMutation builder.
func (m *FLinkGroupMutation) Where(ps ...predicate.FLinkGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FLinkGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FLinkGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FLinkGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FLinkGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FLinkGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FLinkGroup).
func (m *FLinkGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FLinkGroupMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, flinkgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flinkgroup.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, flinkgroup.FieldName)
	}
	if m.description != nil {
		fields = append(fields, flinkgroup.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FLinkGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flinkgroup.FieldCreatedAt:
		return m.CreatedAt()
	case flinkgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case flinkgroup.FieldName:
		return m.Name()
	case flinkgroup.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FLinkGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flinkgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flinkgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case flinkgroup.FieldName:
		return m.OldName(ctx)
	case flinkgroup.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown FLinkGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FLinkGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flinkgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flinkgroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case flinkgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case flinkgroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown FLinkGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FLinkGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FLinkGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FLinkGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FLinkGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FLinkGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flinkgroup.FieldDescription) {
		fields = append(fields, flinkgroup.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FLinkGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FLinkGroupMutation) ClearField(name string) error {
	switch name {
	case flinkgroup.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown FLinkGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FLinkGroupMutation) ResetField(name string) error {
	switch name {
	case flinkgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flinkgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case flinkgroup.FieldName:
		m.ResetName()
		return nil
	case flinkgroup.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown FLinkGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FLinkGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.links != nil {
		edges = append(edges, flinkgroup.EdgeLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FLinkGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flinkgroup.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.links))
		for id := range m.links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FLinkGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlinks != nil {
		edges = append(edges, flinkgroup.EdgeLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FLinkGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flinkgroup.EdgeLinks:
		ids := make([]ent.Value, 0, len(m.removedlinks))
		for id := range m.removedlinks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FLinkGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlinks {
		edges = append(edges, flinkgroup.EdgeLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FLinkGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case flinkgroup.EdgeLinks:
		return m.clearedlinks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FLinkGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FLinkGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FLinkGroupMutation) ResetEdge(name string) error {
	switch name {
	case flinkgroup.EdgeLinks:
		m.ResetLinks()
		return nil
	}
	return fmt.Errorf("unknown FLinkGroup edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	name                    *string
	_path                   *string
	url                     *string
	_type                   *string
	size                    *string
	clearedFields           map[string]struct{}
	storage_strategy        *int
	clearedstorage_strategy bool
	done                    bool
	oldValue                func(context.Context) (*File, error)
	predicates              []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *FileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileMutation) ResetPath() {
	m._path = nil
}

// SetURL sets the "url" field.
func (m *FileMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *FileMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *FileMutation) ResetURL() {
	m.url = nil
}

// SetType sets the "type" field.
func (m *FileMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
}

// SetStorageStrategyID sets the "storage_strategy_id" field.
func (m *FileMutation) SetStorageStrategyID(i int) {
	m.storage_strategy = &i
}

// StorageStrategyID returns the value of the "storage_strategy_id" field in the mutation.
func (m *FileMutation) StorageStrategyID() (r int, exists bool) {
	v := m.storage_strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageStrategyID returns the old "storage_strategy_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldStorageStrategyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageStrategyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageStrategyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageStrategyID: %w", err)
	}
	return oldValue.StorageStrategyID, nil
}

// ClearStorageStrategyID clears the value of the "storage_strategy_id" field.
func (m *FileMutation) ClearStorageStrategyID() {
	m.storage_strategy = nil
	m.clearedFields[file.FieldStorageStrategyID] = struct{}{}
}

// StorageStrategyIDCleared returns if the "storage_strategy_id" field was cleared in this mutation.
func (m *FileMutation) StorageStrategyIDCleared() bool {
	_, ok := m.clearedFields[file.FieldStorageStrategyID]
	return ok
}

// ResetStorageStrategyID resets all changes to the "storage_strategy_id" field.
func (m *FileMutation) ResetStorageStrategyID() {
	m.storage_strategy = nil
	delete(m.clearedFields, file.FieldStorageStrategyID)
}

// ClearStorageStrategy clears the "storage_strategy" edge to the StorageStrategy entity.
func (m *FileMutation) ClearStorageStrategy() {
	m.clearedstorage_strategy = true
	m.clearedFields[file.FieldStorageStrategyID] = struct{}{}
}

// StorageStrategyCleared reports if the "storage_strategy" edge to the StorageStrategy entity was cleared.
func (m *FileMutation) StorageStrategyCleared() bool {
	return m.StorageStrategyIDCleared() || m.clearedstorage_strategy
}

// StorageStrategyIDs returns the "storage_strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StorageStrategyID instead. It exists only for internal usage by the builders.
func (m *FileMutation) StorageStrategyIDs() (ids []int) {
	if id := m.storage_strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStorageStrategy resets all changes to the "storage_strategy" edge.
func (m *FileMutation) ResetStorageStrategy() {
	m.storage_strategy = nil
	m.clearedstorage_strategy = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m._path != nil {
		fields = append(fields, file.FieldPath)
	}
	if m.url != nil {
		fields = append(fields, file.FieldURL)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.storage_strategy != nil {
		fields = append(fields, file.FieldStorageStrategyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldName:
		return m.Name()
	case file.FieldPath:
		return m.Path()
	case file.FieldURL:
		return m.URL()
	case file.FieldType:
		return m.GetType()
	case file.FieldSize:
		return m.Size()
	case file.FieldStorageStrategyID:
		return m.StorageStrategyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldPath:
		return m.OldPath(ctx)
	case file.FieldURL:
		return m.OldURL(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldStorageStrategyID:
		return m.OldStorageStrategyID(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case file.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case file.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldStorageStrategyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageStrategyID(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldStorageStrategyID) {
		fields = append(fields, file.FieldStorageStrategyID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldStorageStrategyID:
		m.ClearStorageStrategyID()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldPath:
		m.ResetPath()
		return nil
	case file.FieldURL:
		m.ResetURL()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldStorageStrategyID:
		m.ResetStorageStrategyID()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.storage_strategy != nil {
		edges = append(edges, file.EdgeStorageStrategy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeStorageStrategy:
		if id := m.storage_strategy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstorage_strategy {
		edges = append(edges, file.EdgeStorageStrategy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeStorageStrategy:
		return m.clearedstorage_strategy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeStorageStrategy:
		m.ClearStorageStrategy()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeStorageStrategy:
		m.ResetStorageStrategy()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// FriendCircleRecordMutation represents an operation that mutates the FriendCircleRecord nodes in the graph.
type FriendCircleRecordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	author        *string
	title         *string
	link_url      *string
	avatar_url    *string
	site_url      *string
	published_at  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FriendCircleRecord, error)
	predicates    []predicate.FriendCircleRecord
}

var _ ent.Mutation = (*FriendCircleRecordMutation)(nil)

// friendcirclerecordOption allows management of the mutation configuration using functional options.
type friendcirclerecordOption func(*FriendCircleRecordMutation)

// newFriendCircleRecordMutation creates new mutation for the FriendCircleRecord entity.
func newFriendCircleRecordMutation(c config, op Op, opts ...friendcirclerecordOption) *FriendCircleRecordMutation {
	m := &FriendCircleRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeFriendCircleRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFriendCircleRecordID sets the ID field of the mutation.
func withFriendCircleRecordID(id int) friendcirclerecordOption {
	return func(m *FriendCircleRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *FriendCircleRecord
		)
		m.oldValue = func(ctx context.Context) (*FriendCircleRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FriendCircleRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFriendCircleRecord sets the old FriendCircleRecord of the mutation.
func withFriendCircleRecord(node *FriendCircleRecord) friendcirclerecordOption {
	return func(m *FriendCircleRecordMutation) {
		m.oldValue = func(context.Context) (*FriendCircleRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FriendCircleRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FriendCircleRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FriendCircleRecord entities.
func (m *FriendCircleRecordMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FriendCircleRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FriendCircleRecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FriendCircleRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FriendCircleRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FriendCircleRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FriendCircleRecord entity.
// If the FriendCircleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendCircleRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FriendCircleRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FriendCircleRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FriendCircleRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FriendCircleRecord entity.
// If the FriendCircleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendCircleRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FriendCircleRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAuthor sets the "author" field.
func (m *FriendCircleRecordMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *FriendCircleRecordMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the FriendCircleRecord entity.
// If the FriendCircleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendCircleRecordMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *FriendCircleRecordMutation) ResetAuthor() {
	m.author = nil
}

// SetTitle sets the "title" field.
func (m *FriendCircleRecordMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *FriendCircleRecordMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the FriendCircleRecord entity.
// If the FriendCircleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendCircleRecordMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *FriendCircleRecordMutation) ResetTitle() {
	m.title = nil
}

// SetLinkURL sets the "link_url" field.
func (m *FriendCircleRecordMutation) SetLinkURL(s string) {
	m.link_url = &s
}

// LinkURL returns the value of the "link_url" field in the mutation.
func (m *FriendCircleRecordMutation) LinkURL() (r string, exists bool) {
	v := m.link_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkURL returns the old "link_url" field's value of the FriendCircleRecord entity.
// If the FriendCircleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendCircleRecordMutation) OldLinkURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkURL: %w", err)
	}
	return oldValue.LinkURL, nil
}

// ResetLinkURL resets all changes to the "link_url" field.
func (m *FriendCircleRecordMutation) ResetLinkURL() {
	m.link_url = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *FriendCircleRecordMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *FriendCircleRecordMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the FriendCircleRecord entity.
// If the FriendCircleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendCircleRecordMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *FriendCircleRecordMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetSiteURL sets the "site_url" field.
func (m *FriendCircleRecordMutation) SetSiteURL(s string) {
	m.site_url = &s
}

// SiteURL returns the value of the "site_url" field in the mutation.
func (m *FriendCircleRecordMutation) SiteURL() (r string, exists bool) {
	v := m.site_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteURL returns the old "site_url" field's value of the FriendCircleRecord entity.
// If the FriendCircleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendCircleRecordMutation) OldSiteURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteURL: %w", err)
	}
	return oldValue.SiteURL, nil
}

// ClearSiteURL clears the value of the "site_url" field.
func (m *FriendCircleRecordMutation) ClearSiteURL() {
	m.site_url = nil
	m.clearedFields[friendcirclerecord.FieldSiteURL] = struct{}{}
}

// SiteURLCleared returns if the "site_url" field was cleared in this mutation.
func (m *FriendCircleRecordMutation) SiteURLCleared() bool {
	_, ok := m.clearedFields[friendcirclerecord.FieldSiteURL]
	return ok
}

// ResetSiteURL resets all changes to the "site_url" field.
func (m *FriendCircleRecordMutation) ResetSiteURL() {
	m.site_url = nil
	delete(m.clearedFields, friendcirclerecord.FieldSiteURL)
}

// SetPublishedAt sets the "published_at" field.
func (m *FriendCircleRecordMutation) SetPublishedAt(s string) {
	m.published_at = &s
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *FriendCircleRecordMutation) PublishedAt() (r string, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the FriendCircleRecord entity.
// If the FriendCircleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendCircleRecordMutation) OldPublishedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *FriendCircleRecordMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[friendcirclerecord.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *FriendCircleRecordMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[friendcirclerecord.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *FriendCircleRecordMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, friendcirclerecord.FieldPublishedAt)
}

// Where appends a list predicates to the FriendCircleRecordMutation builder.
func (m *FriendCircleRecordMutation) Where(ps ...predicate.FriendCircleRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FriendCircleRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FriendCircleRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FriendCircleRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FriendCircleRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FriendCircleRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FriendCircleRecord).
func (m *FriendCircleRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FriendCircleRecordMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, friendcirclerecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, friendcirclerecord.FieldUpdatedAt)
	}
	if m.author != nil {
		fields = append(fields, friendcirclerecord.FieldAuthor)
	}
	if m.title != nil {
		fields = append(fields, friendcirclerecord.FieldTitle)
	}
	if m.link_url != nil {
		fields = append(fields, friendcirclerecord.FieldLinkURL)
	}
	if m.avatar_url != nil {
		fields = append(fields, friendcirclerecord.FieldAvatarURL)
	}
	if m.site_url != nil {
		fields = append(fields, friendcirclerecord.FieldSiteURL)
	}
	if m.published_at != nil {
		fields = append(fields, friendcirclerecord.FieldPublishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FriendCircleRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case friendcirclerecord.FieldCreatedAt:
		return m.CreatedAt()
	case friendcirclerecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case friendcirclerecord.FieldAuthor:
		return m.Author()
	case friendcirclerecord.FieldTitle:
		return m.Title()
	case friendcirclerecord.FieldLinkURL:
		return m.LinkURL()
	case friendcirclerecord.FieldAvatarURL:
		return m.AvatarURL()
	case friendcirclerecord.FieldSiteURL:
		return m.SiteURL()
	case friendcirclerecord.FieldPublishedAt:
		return m.PublishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FriendCircleRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case friendcirclerecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case friendcirclerecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case friendcirclerecord.FieldAuthor:
		return m.OldAuthor(ctx)
	case friendcirclerecord.FieldTitle:
		return m.OldTitle(ctx)
	case friendcirclerecord.FieldLinkURL:
		return m.OldLinkURL(ctx)
	case friendcirclerecord.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case friendcirclerecord.FieldSiteURL:
		return m.OldSiteURL(ctx)
	case friendcirclerecord.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FriendCircleRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendCircleRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case friendcirclerecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case friendcirclerecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case friendcirclerecord.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case friendcirclerecord.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case friendcirclerecord.FieldLinkURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkURL(v)
		return nil
	case friendcirclerecord.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case friendcirclerecord.FieldSiteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteURL(v)
		return nil
	case friendcirclerecord.FieldPublishedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FriendCircleRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FriendCircleRecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FriendCircleRecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendCircleRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FriendCircleRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FriendCircleRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(friendcirclerecord.FieldSiteURL) {
		fields = append(fields, friendcirclerecord.FieldSiteURL)
	}
	if m.FieldCleared(friendcirclerecord.FieldPublishedAt) {
		fields = append(fields, friendcirclerecord.FieldPublishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FriendCircleRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FriendCircleRecordMutation) ClearField(name string) error {
	switch name {
	case friendcirclerecord.FieldSiteURL:
		m.ClearSiteURL()
		return nil
	case friendcirclerecord.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	}
	return fmt.Errorf("unknown FriendCircleRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FriendCircleRecordMutation) ResetField(name string) error {
	switch name {
	case friendcirclerecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case friendcirclerecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case friendcirclerecord.FieldAuthor:
		m.ResetAuthor()
		return nil
	case friendcirclerecord.FieldTitle:
		m.ResetTitle()
		return nil
	case friendcirclerecord.FieldLinkURL:
		m.ResetLinkURL()
		return nil
	case friendcirclerecord.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case friendcirclerecord.FieldSiteURL:
		m.ResetSiteURL()
		return nil
	case friendcirclerecord.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	}
	return fmt.Errorf("unknown FriendCircleRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FriendCircleRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FriendCircleRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FriendCircleRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FriendCircleRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FriendCircleRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FriendCircleRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FriendCircleRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FriendCircleRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FriendCircleRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FriendCircleRecord edge %s", name)
}

// KnowledgeBaseMutation represents an operation that mutates the KnowledgeBase nodes in the graph.
type KnowledgeBaseMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	created_at                  *time.Time
	updated_at                  *time.Time
	name                        *string
	model_provider              *knowledgebase.ModelProvider
	model                       *string
	vector_dimension            *int
	addvector_dimension         *int
	max_batch_document_count    *int
	addmax_batch_document_count *int
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*KnowledgeBase, error)
	predicates                  []predicate.KnowledgeBase
}

var _ ent.Mutation = (*KnowledgeBaseMutation)(nil)

// knowledgebaseOption allows management of the mutation configuration using functional options.
type knowledgebaseOption func(*KnowledgeBaseMutation)

// newKnowledgeBaseMutation creates new mutation for the KnowledgeBase entity.
func newKnowledgeBaseMutation(c config, op Op, opts ...knowledgebaseOption) *KnowledgeBaseMutation {
	m := &KnowledgeBaseMutation{
		config:        c,
		op:            op,
		typ:           TypeKnowledgeBase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKnowledgeBaseID sets the ID field of the mutation.
func withKnowledgeBaseID(id int) knowledgebaseOption {
	return func(m *KnowledgeBaseMutation) {
		var (
			err   error
			once  sync.Once
			value *KnowledgeBase
		)
		m.oldValue = func(ctx context.Context) (*KnowledgeBase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KnowledgeBase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKnowledgeBase sets the old KnowledgeBase of the mutation.
func withKnowledgeBase(node *KnowledgeBase) knowledgebaseOption {
	return func(m *KnowledgeBaseMutation) {
		m.oldValue = func(context.Context) (*KnowledgeBase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KnowledgeBaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KnowledgeBaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of KnowledgeBase entities.
func (m *KnowledgeBaseMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KnowledgeBaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KnowledgeBaseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KnowledgeBase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *KnowledgeBaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KnowledgeBaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KnowledgeBaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KnowledgeBaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KnowledgeBaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KnowledgeBaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *KnowledgeBaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *KnowledgeBaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *KnowledgeBaseMutation) ResetName() {
	m.name = nil
}

// SetModelProvider sets the "model_provider" field.
func (m *KnowledgeBaseMutation) SetModelProvider(kp knowledgebase.ModelProvider) {
	m.model_provider = &kp
}

// ModelProvider returns the value of the "model_provider" field in the mutation.
func (m *KnowledgeBaseMutation) ModelProvider() (r knowledgebase.ModelProvider, exists bool) {
	v := m.model_provider
	if v == nil {
		return
	}
	return *v, true
}

// OldModelProvider returns the old "model_provider" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldModelProvider(ctx context.Context) (v knowledgebase.ModelProvider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelProvider: %w", err)
	}
	return oldValue.ModelProvider, nil
}

// ResetModelProvider resets all changes to the "model_provider" field.
func (m *KnowledgeBaseMutation) ResetModelProvider() {
	m.model_provider = nil
}

// SetModel sets the "model" field.
func (m *KnowledgeBaseMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *KnowledgeBaseMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *KnowledgeBaseMutation) ResetModel() {
	m.model = nil
}

// SetVectorDimension sets the "vector_dimension" field.
func (m *KnowledgeBaseMutation) SetVectorDimension(i int) {
	m.vector_dimension = &i
	m.addvector_dimension = nil
}

// VectorDimension returns the value of the "vector_dimension" field in the mutation.
func (m *KnowledgeBaseMutation) VectorDimension() (r int, exists bool) {
	v := m.vector_dimension
	if v == nil {
		return
	}
	return *v, true
}

// OldVectorDimension returns the old "vector_dimension" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldVectorDimension(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVectorDimension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVectorDimension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVectorDimension: %w", err)
	}
	return oldValue.VectorDimension, nil
}

// AddVectorDimension adds i to the "vector_dimension" field.
func (m *KnowledgeBaseMutation) AddVectorDimension(i int) {
	if m.addvector_dimension != nil {
		*m.addvector_dimension += i
	} else {
		m.addvector_dimension = &i
	}
}

// AddedVectorDimension returns the value that was added to the "vector_dimension" field in this mutation.
func (m *KnowledgeBaseMutation) AddedVectorDimension() (r int, exists bool) {
	v := m.addvector_dimension
	if v == nil {
		return
	}
	return *v, true
}

// ResetVectorDimension resets all changes to the "vector_dimension" field.
func (m *KnowledgeBaseMutation) ResetVectorDimension() {
	m.vector_dimension = nil
	m.addvector_dimension = nil
}

// SetMaxBatchDocumentCount sets the "max_batch_document_count" field.
func (m *KnowledgeBaseMutation) SetMaxBatchDocumentCount(i int) {
	m.max_batch_document_count = &i
	m.addmax_batch_document_count = nil
}

// MaxBatchDocumentCount returns the value of the "max_batch_document_count" field in the mutation.
func (m *KnowledgeBaseMutation) MaxBatchDocumentCount() (r int, exists bool) {
	v := m.max_batch_document_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxBatchDocumentCount returns the old "max_batch_document_count" field's value of the KnowledgeBase entity.
// If the KnowledgeBase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KnowledgeBaseMutation) OldMaxBatchDocumentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxBatchDocumentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxBatchDocumentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxBatchDocumentCount: %w", err)
	}
	return oldValue.MaxBatchDocumentCount, nil
}

// AddMaxBatchDocumentCount adds i to the "max_batch_document_count" field.
func (m *KnowledgeBaseMutation) AddMaxBatchDocumentCount(i int) {
	if m.addmax_batch_document_count != nil {
		*m.addmax_batch_document_count += i
	} else {
		m.addmax_batch_document_count = &i
	}
}

// AddedMaxBatchDocumentCount returns the value that was added to the "max_batch_document_count" field in this mutation.
func (m *KnowledgeBaseMutation) AddedMaxBatchDocumentCount() (r int, exists bool) {
	v := m.addmax_batch_document_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxBatchDocumentCount resets all changes to the "max_batch_document_count" field.
func (m *KnowledgeBaseMutation) ResetMaxBatchDocumentCount() {
	m.max_batch_document_count = nil
	m.addmax_batch_document_count = nil
}

// Where appends a list predicates to the KnowledgeBaseMutation builder.
func (m *KnowledgeBaseMutation) Where(ps ...predicate.KnowledgeBase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KnowledgeBaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KnowledgeBaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.KnowledgeBase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KnowledgeBaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KnowledgeBaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (KnowledgeBase).
func (m *KnowledgeBaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KnowledgeBaseMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, knowledgebase.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, knowledgebase.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, knowledgebase.FieldName)
	}
	if m.model_provider != nil {
		fields = append(fields, knowledgebase.FieldModelProvider)
	}
	if m.model != nil {
		fields = append(fields, knowledgebase.FieldModel)
	}
	if m.vector_dimension != nil {
		fields = append(fields, knowledgebase.FieldVectorDimension)
	}
	if m.max_batch_document_count != nil {
		fields = append(fields, knowledgebase.FieldMaxBatchDocumentCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KnowledgeBaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case knowledgebase.FieldCreatedAt:
		return m.CreatedAt()
	case knowledgebase.FieldUpdatedAt:
		return m.UpdatedAt()
	case knowledgebase.FieldName:
		return m.Name()
	case knowledgebase.FieldModelProvider:
		return m.ModelProvider()
	case knowledgebase.FieldModel:
		return m.Model()
	case knowledgebase.FieldVectorDimension:
		return m.VectorDimension()
	case knowledgebase.FieldMaxBatchDocumentCount:
		return m.MaxBatchDocumentCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KnowledgeBaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case knowledgebase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case knowledgebase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case knowledgebase.FieldName:
		return m.OldName(ctx)
	case knowledgebase.FieldModelProvider:
		return m.OldModelProvider(ctx)
	case knowledgebase.FieldModel:
		return m.OldModel(ctx)
	case knowledgebase.FieldVectorDimension:
		return m.OldVectorDimension(ctx)
	case knowledgebase.FieldMaxBatchDocumentCount:
		return m.OldMaxBatchDocumentCount(ctx)
	}
	return nil, fmt.Errorf("unknown KnowledgeBase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KnowledgeBaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case knowledgebase.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case knowledgebase.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case knowledgebase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case knowledgebase.FieldModelProvider:
		v, ok := value.(knowledgebase.ModelProvider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelProvider(v)
		return nil
	case knowledgebase.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case knowledgebase.FieldVectorDimension:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVectorDimension(v)
		return nil
	case knowledgebase.FieldMaxBatchDocumentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxBatchDocumentCount(v)
		return nil
	}
	return fmt.Errorf("unknown KnowledgeBase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KnowledgeBaseMutation) AddedFields() []string {
	var fields []string
	if m.addvector_dimension != nil {
		fields = append(fields, knowledgebase.FieldVectorDimension)
	}
	if m.addmax_batch_document_count != nil {
		fields = append(fields, knowledgebase.FieldMaxBatchDocumentCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KnowledgeBaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case knowledgebase.FieldVectorDimension:
		return m.AddedVectorDimension()
	case knowledgebase.FieldMaxBatchDocumentCount:
		return m.AddedMaxBatchDocumentCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KnowledgeBaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case knowledgebase.FieldVectorDimension:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVectorDimension(v)
		return nil
	case knowledgebase.FieldMaxBatchDocumentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxBatchDocumentCount(v)
		return nil
	}
	return fmt.Errorf("unknown KnowledgeBase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KnowledgeBaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KnowledgeBaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KnowledgeBaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KnowledgeBase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KnowledgeBaseMutation) ResetField(name string) error {
	switch name {
	case knowledgebase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case knowledgebase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case knowledgebase.FieldName:
		m.ResetName()
		return nil
	case knowledgebase.FieldModelProvider:
		m.ResetModelProvider()
		return nil
	case knowledgebase.FieldModel:
		m.ResetModel()
		return nil
	case knowledgebase.FieldVectorDimension:
		m.ResetVectorDimension()
		return nil
	case knowledgebase.FieldMaxBatchDocumentCount:
		m.ResetMaxBatchDocumentCount()
		return nil
	}
	return fmt.Errorf("unknown KnowledgeBase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KnowledgeBaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KnowledgeBaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KnowledgeBaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KnowledgeBaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KnowledgeBaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KnowledgeBaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KnowledgeBaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KnowledgeBase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KnowledgeBaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KnowledgeBase edge %s", name)
}

// LicenseMutation represents an operation that mutates the License nodes in the graph.
type LicenseMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	domain        *string
	license_key   *string
	customer_name *string
	expire_date   *time.Time
	status        *int
	addstatus     *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*License, error)
	predicates    []predicate.License
}

var _ ent.Mutation = (*LicenseMutation)(nil)

// licenseOption allows management of the mutation configuration using functional options.
type licenseOption func(*LicenseMutation)

// newLicenseMutation creates new mutation for the License entity.
func newLicenseMutation(c config, op Op, opts ...licenseOption) *LicenseMutation {
	m := &LicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseID sets the ID field of the mutation.
func withLicenseID(id int) licenseOption {
	return func(m *LicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *License
		)
		m.oldValue = func(ctx context.Context) (*License, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().License.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicense sets the old License of the mutation.
func withLicense(node *License) licenseOption {
	return func(m *LicenseMutation) {
		m.oldValue = func(context.Context) (*License, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of License entities.
func (m *LicenseMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LicenseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().License.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LicenseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LicenseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LicenseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LicenseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LicenseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LicenseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDomain sets the "domain" field.
func (m *LicenseMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *LicenseMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *LicenseMutation) ResetDomain() {
	m.domain = nil
}

// SetLicenseKey sets the "license_key" field.
func (m *LicenseMutation) SetLicenseKey(s string) {
	m.license_key = &s
}

// LicenseKey returns the value of the "license_key" field in the mutation.
func (m *LicenseMutation) LicenseKey() (r string, exists bool) {
	v := m.license_key
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseKey returns the old "license_key" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldLicenseKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseKey: %w", err)
	}
	return oldValue.LicenseKey, nil
}

// ResetLicenseKey resets all changes to the "license_key" field.
func (m *LicenseMutation) ResetLicenseKey() {
	m.license_key = nil
}

// SetCustomerName sets the "customer_name" field.
func (m *LicenseMutation) SetCustomerName(s string) {
	m.customer_name = &s
}

// CustomerName returns the value of the "customer_name" field in the mutation.
func (m *LicenseMutation) CustomerName() (r string, exists bool) {
	v := m.customer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerName returns the old "customer_name" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldCustomerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerName: %w", err)
	}
	return oldValue.CustomerName, nil
}

// ClearCustomerName clears the value of the "customer_name" field.
func (m *LicenseMutation) ClearCustomerName() {
	m.customer_name = nil
	m.clearedFields[license.FieldCustomerName] = struct{}{}
}

// CustomerNameCleared returns if the "customer_name" field was cleared in this mutation.
func (m *LicenseMutation) CustomerNameCleared() bool {
	_, ok := m.clearedFields[license.FieldCustomerName]
	return ok
}

// ResetCustomerName resets all changes to the "customer_name" field.
func (m *LicenseMutation) ResetCustomerName() {
	m.customer_name = nil
	delete(m.clearedFields, license.FieldCustomerName)
}

// SetExpireDate sets the "expire_date" field.
func (m *LicenseMutation) SetExpireDate(t time.Time) {
	m.expire_date = &t
}

// ExpireDate returns the value of the "expire_date" field in the mutation.
func (m *LicenseMutation) ExpireDate() (r time.Time, exists bool) {
	v := m.expire_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireDate returns the old "expire_date" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldExpireDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireDate: %w", err)
	}
	return oldValue.ExpireDate, nil
}

// ResetExpireDate resets all changes to the "expire_date" field.
func (m *LicenseMutation) ResetExpireDate() {
	m.expire_date = nil
}

// SetStatus sets the "status" field.
func (m *LicenseMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *LicenseMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *LicenseMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *LicenseMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *LicenseMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the LicenseMutation builder.
func (m *LicenseMutation) Where(ps ...predicate.License) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LicenseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LicenseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.License, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LicenseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LicenseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (License).
func (m *LicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, license.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, license.FieldUpdatedAt)
	}
	if m.domain != nil {
		fields = append(fields, license.FieldDomain)
	}
	if m.license_key != nil {
		fields = append(fields, license.FieldLicenseKey)
	}
	if m.customer_name != nil {
		fields = append(fields, license.FieldCustomerName)
	}
	if m.expire_date != nil {
		fields = append(fields, license.FieldExpireDate)
	}
	if m.status != nil {
		fields = append(fields, license.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case license.FieldCreatedAt:
		return m.CreatedAt()
	case license.FieldUpdatedAt:
		return m.UpdatedAt()
	case license.FieldDomain:
		return m.Domain()
	case license.FieldLicenseKey:
		return m.LicenseKey()
	case license.FieldCustomerName:
		return m.CustomerName()
	case license.FieldExpireDate:
		return m.ExpireDate()
	case license.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case license.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case license.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case license.FieldDomain:
		return m.OldDomain(ctx)
	case license.FieldLicenseKey:
		return m.OldLicenseKey(ctx)
	case license.FieldCustomerName:
		return m.OldCustomerName(ctx)
	case license.FieldExpireDate:
		return m.OldExpireDate(ctx)
	case license.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown License field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case license.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case license.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case license.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case license.FieldLicenseKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseKey(v)
		return nil
	case license.FieldCustomerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerName(v)
		return nil
	case license.FieldExpireDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireDate(v)
		return nil
	case license.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, license.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case license.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case license.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown License numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(license.FieldCustomerName) {
		fields = append(fields, license.FieldCustomerName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseMutation) ClearField(name string) error {
	switch name {
	case license.FieldCustomerName:
		m.ClearCustomerName()
		return nil
	}
	return fmt.Errorf("unknown License nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseMutation) ResetField(name string) error {
	switch name {
	case license.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case license.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case license.FieldDomain:
		m.ResetDomain()
		return nil
	case license.FieldLicenseKey:
		m.ResetLicenseKey()
		return nil
	case license.FieldCustomerName:
		m.ResetCustomerName()
		return nil
	case license.FieldExpireDate:
		m.ResetExpireDate()
		return nil
	case license.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown License unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown License edge %s", name)
}

// MemberMutation represents an operation that mutates the Member nodes in the graph.
type MemberMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	member_level    *int
	addmember_level *int
	member_no       *string
	join_time       *time.Time
	expire_time     *time.Time
	points          *int
	addpoints       *int
	total_spent     *int
	addtotal_spent  *int
	order_count     *int
	addorder_count  *int
	active          *bool
	remark          *string
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Member, error)
	predicates      []predicate.Member
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows management of the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for the Member entity.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the ID field of the mutation.
func withMemberID(id int) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Member entities.
func (m *MemberMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Member.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *MemberMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MemberMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *MemberMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[member.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *MemberMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[member.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MemberMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, member.FieldUserID)
}

// SetMemberLevel sets the "member_level" field.
func (m *MemberMutation) SetMemberLevel(i int) {
	m.member_level = &i
	m.addmember_level = nil
}

// MemberLevel returns the value of the "member_level" field in the mutation.
func (m *MemberMutation) MemberLevel() (r int, exists bool) {
	v := m.member_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberLevel returns the old "member_level" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldMemberLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberLevel: %w", err)
	}
	return oldValue.MemberLevel, nil
}

// AddMemberLevel adds i to the "member_level" field.
func (m *MemberMutation) AddMemberLevel(i int) {
	if m.addmember_level != nil {
		*m.addmember_level += i
	} else {
		m.addmember_level = &i
	}
}

// AddedMemberLevel returns the value that was added to the "member_level" field in this mutation.
func (m *MemberMutation) AddedMemberLevel() (r int, exists bool) {
	v := m.addmember_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemberLevel resets all changes to the "member_level" field.
func (m *MemberMutation) ResetMemberLevel() {
	m.member_level = nil
	m.addmember_level = nil
}

// SetMemberNo sets the "member_no" field.
func (m *MemberMutation) SetMemberNo(s string) {
	m.member_no = &s
}

// MemberNo returns the value of the "member_no" field in the mutation.
func (m *MemberMutation) MemberNo() (r string, exists bool) {
	v := m.member_no
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberNo returns the old "member_no" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldMemberNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberNo: %w", err)
	}
	return oldValue.MemberNo, nil
}

// ResetMemberNo resets all changes to the "member_no" field.
func (m *MemberMutation) ResetMemberNo() {
	m.member_no = nil
}

// SetJoinTime sets the "join_time" field.
func (m *MemberMutation) SetJoinTime(t time.Time) {
	m.join_time = &t
}

// JoinTime returns the value of the "join_time" field in the mutation.
func (m *MemberMutation) JoinTime() (r time.Time, exists bool) {
	v := m.join_time
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinTime returns the old "join_time" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldJoinTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinTime: %w", err)
	}
	return oldValue.JoinTime, nil
}

// ResetJoinTime resets all changes to the "join_time" field.
func (m *MemberMutation) ResetJoinTime() {
	m.join_time = nil
}

// SetExpireTime sets the "expire_time" field.
func (m *MemberMutation) SetExpireTime(t time.Time) {
	m.expire_time = &t
}

// ExpireTime returns the value of the "expire_time" field in the mutation.
func (m *MemberMutation) ExpireTime() (r time.Time, exists bool) {
	v := m.expire_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireTime returns the old "expire_time" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldExpireTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireTime: %w", err)
	}
	return oldValue.ExpireTime, nil
}

// ClearExpireTime clears the value of the "expire_time" field.
func (m *MemberMutation) ClearExpireTime() {
	m.expire_time = nil
	m.clearedFields[member.FieldExpireTime] = struct{}{}
}

// ExpireTimeCleared returns if the "expire_time" field was cleared in this mutation.
func (m *MemberMutation) ExpireTimeCleared() bool {
	_, ok := m.clearedFields[member.FieldExpireTime]
	return ok
}

// ResetExpireTime resets all changes to the "expire_time" field.
func (m *MemberMutation) ResetExpireTime() {
	m.expire_time = nil
	delete(m.clearedFields, member.FieldExpireTime)
}

// SetPoints sets the "points" field.
func (m *MemberMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *MemberMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *MemberMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *MemberMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *MemberMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetTotalSpent sets the "total_spent" field.
func (m *MemberMutation) SetTotalSpent(i int) {
	m.total_spent = &i
	m.addtotal_spent = nil
}

// TotalSpent returns the value of the "total_spent" field in the mutation.
func (m *MemberMutation) TotalSpent() (r int, exists bool) {
	v := m.total_spent
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSpent returns the old "total_spent" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldTotalSpent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSpent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSpent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSpent: %w", err)
	}
	return oldValue.TotalSpent, nil
}

// AddTotalSpent adds i to the "total_spent" field.
func (m *MemberMutation) AddTotalSpent(i int) {
	if m.addtotal_spent != nil {
		*m.addtotal_spent += i
	} else {
		m.addtotal_spent = &i
	}
}

// AddedTotalSpent returns the value that was added to the "total_spent" field in this mutation.
func (m *MemberMutation) AddedTotalSpent() (r int, exists bool) {
	v := m.addtotal_spent
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSpent resets all changes to the "total_spent" field.
func (m *MemberMutation) ResetTotalSpent() {
	m.total_spent = nil
	m.addtotal_spent = nil
}

// SetOrderCount sets the "order_count" field.
func (m *MemberMutation) SetOrderCount(i int) {
	m.order_count = &i
	m.addorder_count = nil
}

// OrderCount returns the value of the "order_count" field in the mutation.
func (m *MemberMutation) OrderCount() (r int, exists bool) {
	v := m.order_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderCount returns the old "order_count" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldOrderCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderCount: %w", err)
	}
	return oldValue.OrderCount, nil
}

// AddOrderCount adds i to the "order_count" field.
func (m *MemberMutation) AddOrderCount(i int) {
	if m.addorder_count != nil {
		*m.addorder_count += i
	} else {
		m.addorder_count = &i
	}
}

// AddedOrderCount returns the value that was added to the "order_count" field in this mutation.
func (m *MemberMutation) AddedOrderCount() (r int, exists bool) {
	v := m.addorder_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderCount resets all changes to the "order_count" field.
func (m *MemberMutation) ResetOrderCount() {
	m.order_count = nil
	m.addorder_count = nil
}

// SetActive sets the "active" field.
func (m *MemberMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *MemberMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *MemberMutation) ResetActive() {
	m.active = nil
}

// SetRemark sets the "remark" field.
func (m *MemberMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *MemberMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *MemberMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[member.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *MemberMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[member.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *MemberMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, member.FieldRemark)
}

// ClearUser clears the "user" edge to the User entity.
func (m *MemberMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[member.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MemberMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MemberMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MemberMutation builder.
func (m *MemberMutation) Where(ps ...predicate.Member) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Member, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, member.FieldUserID)
	}
	if m.member_level != nil {
		fields = append(fields, member.FieldMemberLevel)
	}
	if m.member_no != nil {
		fields = append(fields, member.FieldMemberNo)
	}
	if m.join_time != nil {
		fields = append(fields, member.FieldJoinTime)
	}
	if m.expire_time != nil {
		fields = append(fields, member.FieldExpireTime)
	}
	if m.points != nil {
		fields = append(fields, member.FieldPoints)
	}
	if m.total_spent != nil {
		fields = append(fields, member.FieldTotalSpent)
	}
	if m.order_count != nil {
		fields = append(fields, member.FieldOrderCount)
	}
	if m.active != nil {
		fields = append(fields, member.FieldActive)
	}
	if m.remark != nil {
		fields = append(fields, member.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldCreatedAt:
		return m.CreatedAt()
	case member.FieldUpdatedAt:
		return m.UpdatedAt()
	case member.FieldUserID:
		return m.UserID()
	case member.FieldMemberLevel:
		return m.MemberLevel()
	case member.FieldMemberNo:
		return m.MemberNo()
	case member.FieldJoinTime:
		return m.JoinTime()
	case member.FieldExpireTime:
		return m.ExpireTime()
	case member.FieldPoints:
		return m.Points()
	case member.FieldTotalSpent:
		return m.TotalSpent()
	case member.FieldOrderCount:
		return m.OrderCount()
	case member.FieldActive:
		return m.Active()
	case member.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case member.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case member.FieldUserID:
		return m.OldUserID(ctx)
	case member.FieldMemberLevel:
		return m.OldMemberLevel(ctx)
	case member.FieldMemberNo:
		return m.OldMemberNo(ctx)
	case member.FieldJoinTime:
		return m.OldJoinTime(ctx)
	case member.FieldExpireTime:
		return m.OldExpireTime(ctx)
	case member.FieldPoints:
		return m.OldPoints(ctx)
	case member.FieldTotalSpent:
		return m.OldTotalSpent(ctx)
	case member.FieldOrderCount:
		return m.OldOrderCount(ctx)
	case member.FieldActive:
		return m.OldActive(ctx)
	case member.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case member.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case member.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case member.FieldMemberLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberLevel(v)
		return nil
	case member.FieldMemberNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberNo(v)
		return nil
	case member.FieldJoinTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinTime(v)
		return nil
	case member.FieldExpireTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireTime(v)
		return nil
	case member.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case member.FieldTotalSpent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSpent(v)
		return nil
	case member.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderCount(v)
		return nil
	case member.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case member.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberMutation) AddedFields() []string {
	var fields []string
	if m.addmember_level != nil {
		fields = append(fields, member.FieldMemberLevel)
	}
	if m.addpoints != nil {
		fields = append(fields, member.FieldPoints)
	}
	if m.addtotal_spent != nil {
		fields = append(fields, member.FieldTotalSpent)
	}
	if m.addorder_count != nil {
		fields = append(fields, member.FieldOrderCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case member.FieldMemberLevel:
		return m.AddedMemberLevel()
	case member.FieldPoints:
		return m.AddedPoints()
	case member.FieldTotalSpent:
		return m.AddedTotalSpent()
	case member.FieldOrderCount:
		return m.AddedOrderCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case member.FieldMemberLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberLevel(v)
		return nil
	case member.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case member.FieldTotalSpent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSpent(v)
		return nil
	case member.FieldOrderCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderCount(v)
		return nil
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(member.FieldUserID) {
		fields = append(fields, member.FieldUserID)
	}
	if m.FieldCleared(member.FieldExpireTime) {
		fields = append(fields, member.FieldExpireTime)
	}
	if m.FieldCleared(member.FieldRemark) {
		fields = append(fields, member.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	switch name {
	case member.FieldUserID:
		m.ClearUserID()
		return nil
	case member.FieldExpireTime:
		m.ClearExpireTime()
		return nil
	case member.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case member.FieldUserID:
		m.ResetUserID()
		return nil
	case member.FieldMemberLevel:
		m.ResetMemberLevel()
		return nil
	case member.FieldMemberNo:
		m.ResetMemberNo()
		return nil
	case member.FieldJoinTime:
		m.ResetJoinTime()
		return nil
	case member.FieldExpireTime:
		m.ResetExpireTime()
		return nil
	case member.FieldPoints:
		m.ResetPoints()
		return nil
	case member.FieldTotalSpent:
		m.ResetTotalSpent()
		return nil
	case member.FieldOrderCount:
		m.ResetOrderCount()
		return nil
	case member.FieldActive:
		m.ResetActive()
		return nil
	case member.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, member.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, member.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	case member.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	case member.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// MemberLevelMutation represents an operation that mutates the MemberLevel nodes in the graph.
type MemberLevelMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	description      *string
	level            *int
	addlevel         *int
	min_points       *int
	addmin_points    *int
	discount_rate    *int
	adddiscount_rate *int
	privileges       *[]string
	appendprivileges []string
	icon             *string
	active           *bool
	sort_order       *int
	addsort_order    *int
	clearedFields    map[string]struct{}
	members          map[int]struct{}
	removedmembers   map[int]struct{}
	clearedmembers   bool
	done             bool
	oldValue         func(context.Context) (*MemberLevel, error)
	predicates       []predicate.MemberLevel
}

var _ ent.Mutation = (*MemberLevelMutation)(nil)

// memberlevelOption allows management of the mutation configuration using functional options.
type memberlevelOption func(*MemberLevelMutation)

// newMemberLevelMutation creates new mutation for the MemberLevel entity.
func newMemberLevelMutation(c config, op Op, opts ...memberlevelOption) *MemberLevelMutation {
	m := &MemberLevelMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberLevel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberLevelID sets the ID field of the mutation.
func withMemberLevelID(id int) memberlevelOption {
	return func(m *MemberLevelMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberLevel
		)
		m.oldValue = func(ctx context.Context) (*MemberLevel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberLevel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberLevel sets the old MemberLevel of the mutation.
func withMemberLevel(node *MemberLevel) memberlevelOption {
	return func(m *MemberLevelMutation) {
		m.oldValue = func(context.Context) (*MemberLevel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberLevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberLevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberLevel entities.
func (m *MemberLevelMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberLevelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberLevelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberLevel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberLevelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberLevelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberLevel entity.
// If the MemberLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberLevelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberLevelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberLevelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberLevelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberLevel entity.
// If the MemberLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberLevelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberLevelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *MemberLevelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberLevelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberLevel entity.
// If the MemberLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberLevelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MemberLevelMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *MemberLevelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MemberLevelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the MemberLevel entity.
// If the MemberLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberLevelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MemberLevelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[memberlevel.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MemberLevelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[memberlevel.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MemberLevelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, memberlevel.FieldDescription)
}

// SetLevel sets the "level" field.
func (m *MemberLevelMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *MemberLevelMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the MemberLevel entity.
// If the MemberLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberLevelMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *MemberLevelMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *MemberLevelMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *MemberLevelMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetMinPoints sets the "min_points" field.
func (m *MemberLevelMutation) SetMinPoints(i int) {
	m.min_points = &i
	m.addmin_points = nil
}

// MinPoints returns the value of the "min_points" field in the mutation.
func (m *MemberLevelMutation) MinPoints() (r int, exists bool) {
	v := m.min_points
	if v == nil {
		return
	}
	return *v, true
}

// OldMinPoints returns the old "min_points" field's value of the MemberLevel entity.
// If the MemberLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberLevelMutation) OldMinPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinPoints: %w", err)
	}
	return oldValue.MinPoints, nil
}

// AddMinPoints adds i to the "min_points" field.
func (m *MemberLevelMutation) AddMinPoints(i int) {
	if m.addmin_points != nil {
		*m.addmin_points += i
	} else {
		m.addmin_points = &i
	}
}

// AddedMinPoints returns the value that was added to the "min_points" field in this mutation.
func (m *MemberLevelMutation) AddedMinPoints() (r int, exists bool) {
	v := m.addmin_points
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinPoints resets all changes to the "min_points" field.
func (m *MemberLevelMutation) ResetMinPoints() {
	m.min_points = nil
	m.addmin_points = nil
}

// SetDiscountRate sets the "discount_rate" field.
func (m *MemberLevelMutation) SetDiscountRate(i int) {
	m.discount_rate = &i
	m.adddiscount_rate = nil
}

// DiscountRate returns the value of the "discount_rate" field in the mutation.
func (m *MemberLevelMutation) DiscountRate() (r int, exists bool) {
	v := m.discount_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountRate returns the old "discount_rate" field's value of the MemberLevel entity.
// If the MemberLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberLevelMutation) OldDiscountRate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountRate: %w", err)
	}
	return oldValue.DiscountRate, nil
}

// AddDiscountRate adds i to the "discount_rate" field.
func (m *MemberLevelMutation) AddDiscountRate(i int) {
	if m.adddiscount_rate != nil {
		*m.adddiscount_rate += i
	} else {
		m.adddiscount_rate = &i
	}
}

// AddedDiscountRate returns the value that was added to the "discount_rate" field in this mutation.
func (m *MemberLevelMutation) AddedDiscountRate() (r int, exists bool) {
	v := m.adddiscount_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountRate resets all changes to the "discount_rate" field.
func (m *MemberLevelMutation) ResetDiscountRate() {
	m.discount_rate = nil
	m.adddiscount_rate = nil
}

// SetPrivileges sets the "privileges" field.
func (m *MemberLevelMutation) SetPrivileges(s []string) {
	m.privileges = &s
	m.appendprivileges = nil
}

// Privileges returns the value of the "privileges" field in the mutation.
func (m *MemberLevelMutation) Privileges() (r []string, exists bool) {
	v := m.privileges
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivileges returns the old "privileges" field's value of the MemberLevel entity.
// If the MemberLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberLevelMutation) OldPrivileges(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivileges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivileges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivileges: %w", err)
	}
	return oldValue.Privileges, nil
}

// AppendPrivileges adds s to the "privileges" field.
func (m *MemberLevelMutation) AppendPrivileges(s []string) {
	m.appendprivileges = append(m.appendprivileges, s...)
}

// AppendedPrivileges returns the list of values that were appended to the "privileges" field in this mutation.
func (m *MemberLevelMutation) AppendedPrivileges() ([]string, bool) {
	if len(m.appendprivileges) == 0 {
		return nil, false
	}
	return m.appendprivileges, true
}

// ClearPrivileges clears the value of the "privileges" field.
func (m *MemberLevelMutation) ClearPrivileges() {
	m.privileges = nil
	m.appendprivileges = nil
	m.clearedFields[memberlevel.FieldPrivileges] = struct{}{}
}

// PrivilegesCleared returns if the "privileges" field was cleared in this mutation.
func (m *MemberLevelMutation) PrivilegesCleared() bool {
	_, ok := m.clearedFields[memberlevel.FieldPrivileges]
	return ok
}

// ResetPrivileges resets all changes to the "privileges" field.
func (m *MemberLevelMutation) ResetPrivileges() {
	m.privileges = nil
	m.appendprivileges = nil
	delete(m.clearedFields, memberlevel.FieldPrivileges)
}

// SetIcon sets the "icon" field.
func (m *MemberLevelMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *MemberLevelMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the MemberLevel entity.
// If the MemberLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberLevelMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *MemberLevelMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[memberlevel.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *MemberLevelMutation) IconCleared() bool {
	_, ok := m.clearedFields[memberlevel.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *MemberLevelMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, memberlevel.FieldIcon)
}

// SetActive sets the "active" field.
func (m *MemberLevelMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *MemberLevelMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the MemberLevel entity.
// If the MemberLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberLevelMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *MemberLevelMutation) ResetActive() {
	m.active = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *MemberLevelMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *MemberLevelMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the MemberLevel entity.
// If the MemberLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberLevelMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *MemberLevelMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *MemberLevelMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *MemberLevelMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// AddMemberIDs adds the "members" edge to the Member entity by ids.
func (m *MemberLevelMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *MemberLevelMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *MemberLevelMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Member entity by IDs.
func (m *MemberLevelMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Member entity.
func (m *MemberLevelMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *MemberLevelMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *MemberLevelMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the MemberLevelMutation builder.
func (m *MemberLevelMutation) Where(ps ...predicate.MemberLevel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberLevelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberLevelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberLevel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberLevelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberLevelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberLevel).
func (m *MemberLevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberLevelMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, memberlevel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberlevel.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, memberlevel.FieldName)
	}
	if m.description != nil {
		fields = append(fields, memberlevel.FieldDescription)
	}
	if m.level != nil {
		fields = append(fields, memberlevel.FieldLevel)
	}
	if m.min_points != nil {
		fields = append(fields, memberlevel.FieldMinPoints)
	}
	if m.discount_rate != nil {
		fields = append(fields, memberlevel.FieldDiscountRate)
	}
	if m.privileges != nil {
		fields = append(fields, memberlevel.FieldPrivileges)
	}
	if m.icon != nil {
		fields = append(fields, memberlevel.FieldIcon)
	}
	if m.active != nil {
		fields = append(fields, memberlevel.FieldActive)
	}
	if m.sort_order != nil {
		fields = append(fields, memberlevel.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberLevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberlevel.FieldCreatedAt:
		return m.CreatedAt()
	case memberlevel.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberlevel.FieldName:
		return m.Name()
	case memberlevel.FieldDescription:
		return m.Description()
	case memberlevel.FieldLevel:
		return m.Level()
	case memberlevel.FieldMinPoints:
		return m.MinPoints()
	case memberlevel.FieldDiscountRate:
		return m.DiscountRate()
	case memberlevel.FieldPrivileges:
		return m.Privileges()
	case memberlevel.FieldIcon:
		return m.Icon()
	case memberlevel.FieldActive:
		return m.Active()
	case memberlevel.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberLevelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberlevel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberlevel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberlevel.FieldName:
		return m.OldName(ctx)
	case memberlevel.FieldDescription:
		return m.OldDescription(ctx)
	case memberlevel.FieldLevel:
		return m.OldLevel(ctx)
	case memberlevel.FieldMinPoints:
		return m.OldMinPoints(ctx)
	case memberlevel.FieldDiscountRate:
		return m.OldDiscountRate(ctx)
	case memberlevel.FieldPrivileges:
		return m.OldPrivileges(ctx)
	case memberlevel.FieldIcon:
		return m.OldIcon(ctx)
	case memberlevel.FieldActive:
		return m.OldActive(ctx)
	case memberlevel.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown MemberLevel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberLevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberlevel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberlevel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberlevel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case memberlevel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case memberlevel.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case memberlevel.FieldMinPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinPoints(v)
		return nil
	case memberlevel.FieldDiscountRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountRate(v)
		return nil
	case memberlevel.FieldPrivileges:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivileges(v)
		return nil
	case memberlevel.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case memberlevel.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case memberlevel.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown MemberLevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberLevelMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, memberlevel.FieldLevel)
	}
	if m.addmin_points != nil {
		fields = append(fields, memberlevel.FieldMinPoints)
	}
	if m.adddiscount_rate != nil {
		fields = append(fields, memberlevel.FieldDiscountRate)
	}
	if m.addsort_order != nil {
		fields = append(fields, memberlevel.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberLevelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberlevel.FieldLevel:
		return m.AddedLevel()
	case memberlevel.FieldMinPoints:
		return m.AddedMinPoints()
	case memberlevel.FieldDiscountRate:
		return m.AddedDiscountRate()
	case memberlevel.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberLevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberlevel.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case memberlevel.FieldMinPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinPoints(v)
		return nil
	case memberlevel.FieldDiscountRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountRate(v)
		return nil
	case memberlevel.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown MemberLevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberLevelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberlevel.FieldDescription) {
		fields = append(fields, memberlevel.FieldDescription)
	}
	if m.FieldCleared(memberlevel.FieldPrivileges) {
		fields = append(fields, memberlevel.FieldPrivileges)
	}
	if m.FieldCleared(memberlevel.FieldIcon) {
		fields = append(fields, memberlevel.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberLevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberLevelMutation) ClearField(name string) error {
	switch name {
	case memberlevel.FieldDescription:
		m.ClearDescription()
		return nil
	case memberlevel.FieldPrivileges:
		m.ClearPrivileges()
		return nil
	case memberlevel.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown MemberLevel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberLevelMutation) ResetField(name string) error {
	switch name {
	case memberlevel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberlevel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberlevel.FieldName:
		m.ResetName()
		return nil
	case memberlevel.FieldDescription:
		m.ResetDescription()
		return nil
	case memberlevel.FieldLevel:
		m.ResetLevel()
		return nil
	case memberlevel.FieldMinPoints:
		m.ResetMinPoints()
		return nil
	case memberlevel.FieldDiscountRate:
		m.ResetDiscountRate()
		return nil
	case memberlevel.FieldPrivileges:
		m.ResetPrivileges()
		return nil
	case memberlevel.FieldIcon:
		m.ResetIcon()
		return nil
	case memberlevel.FieldActive:
		m.ResetActive()
		return nil
	case memberlevel.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown MemberLevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberLevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.members != nil {
		edges = append(edges, memberlevel.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberLevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberlevel.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberLevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmembers != nil {
		edges = append(edges, memberlevel.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberLevelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case memberlevel.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberLevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmembers {
		edges = append(edges, memberlevel.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberLevelMutation) EdgeCleared(name string) bool {
	switch name {
	case memberlevel.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberLevelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MemberLevel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberLevelMutation) ResetEdge(name string) error {
	switch name {
	case memberlevel.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown MemberLevel edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	title         *string
	content       *string
	publish_time  *time.Time
	is_read       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Notification, error)
	predicates    []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id int) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *NotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *NotificationMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *NotificationMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *NotificationMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *NotificationMutation) ResetContent() {
	m.content = nil
}

// SetPublishTime sets the "publish_time" field.
func (m *NotificationMutation) SetPublishTime(t time.Time) {
	m.publish_time = &t
}

// PublishTime returns the value of the "publish_time" field in the mutation.
func (m *NotificationMutation) PublishTime() (r time.Time, exists bool) {
	v := m.publish_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishTime returns the old "publish_time" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldPublishTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishTime: %w", err)
	}
	return oldValue.PublishTime, nil
}

// ClearPublishTime clears the value of the "publish_time" field.
func (m *NotificationMutation) ClearPublishTime() {
	m.publish_time = nil
	m.clearedFields[notification.FieldPublishTime] = struct{}{}
}

// PublishTimeCleared returns if the "publish_time" field was cleared in this mutation.
func (m *NotificationMutation) PublishTimeCleared() bool {
	_, ok := m.clearedFields[notification.FieldPublishTime]
	return ok
}

// ResetPublishTime resets all changes to the "publish_time" field.
func (m *NotificationMutation) ResetPublishTime() {
	m.publish_time = nil
	delete(m.clearedFields, notification.FieldPublishTime)
}

// SetIsRead sets the "is_read" field.
func (m *NotificationMutation) SetIsRead(b bool) {
	m.is_read = &b
}

// IsRead returns the value of the "is_read" field in the mutation.
func (m *NotificationMutation) IsRead() (r bool, exists bool) {
	v := m.is_read
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRead returns the old "is_read" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldIsRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRead: %w", err)
	}
	return oldValue.IsRead, nil
}

// ResetIsRead resets all changes to the "is_read" field.
func (m *NotificationMutation) ResetIsRead() {
	m.is_read = nil
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notification.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, notification.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, notification.FieldContent)
	}
	if m.publish_time != nil {
		fields = append(fields, notification.FieldPublishTime)
	}
	if m.is_read != nil {
		fields = append(fields, notification.FieldIsRead)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldUpdatedAt:
		return m.UpdatedAt()
	case notification.FieldTitle:
		return m.Title()
	case notification.FieldContent:
		return m.Content()
	case notification.FieldPublishTime:
		return m.PublishTime()
	case notification.FieldIsRead:
		return m.IsRead()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notification.FieldTitle:
		return m.OldTitle(ctx)
	case notification.FieldContent:
		return m.OldContent(ctx)
	case notification.FieldPublishTime:
		return m.OldPublishTime(ctx)
	case notification.FieldIsRead:
		return m.OldIsRead(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case notification.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case notification.FieldPublishTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishTime(v)
		return nil
	case notification.FieldIsRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRead(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldPublishTime) {
		fields = append(fields, notification.FieldPublishTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldPublishTime:
		m.ClearPublishTime()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notification.FieldTitle:
		m.ResetTitle()
		return nil
	case notification.FieldContent:
		m.ResetContent()
		return nil
	case notification.FieldPublishTime:
		m.ResetPublishTime()
		return nil
	case notification.FieldIsRead:
		m.ResetIsRead()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Notification edge %s", name)
}

// Oauth2AccessTokenMutation represents an operation that mutates the Oauth2AccessToken nodes in the graph.
type Oauth2AccessTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *int
	adduser_id    *int
	access_token  *string
	refresh_token *string
	client_id     *string
	scope         *string
	expire_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Oauth2AccessToken, error)
	predicates    []predicate.Oauth2AccessToken
}

var _ ent.Mutation = (*Oauth2AccessTokenMutation)(nil)

// oauth2accesstokenOption allows management of the mutation configuration using functional options.
type oauth2accesstokenOption func(*Oauth2AccessTokenMutation)

// newOauth2AccessTokenMutation creates new mutation for the Oauth2AccessToken entity.
func newOauth2AccessTokenMutation(c config, op Op, opts ...oauth2accesstokenOption) *Oauth2AccessTokenMutation {
	m := &Oauth2AccessTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeOauth2AccessToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauth2AccessTokenID sets the ID field of the mutation.
func withOauth2AccessTokenID(id int) oauth2accesstokenOption {
	return func(m *Oauth2AccessTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Oauth2AccessToken
		)
		m.oldValue = func(ctx context.Context) (*Oauth2AccessToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Oauth2AccessToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauth2AccessToken sets the old Oauth2AccessToken of the mutation.
func withOauth2AccessToken(node *Oauth2AccessToken) oauth2accesstokenOption {
	return func(m *Oauth2AccessTokenMutation) {
		m.oldValue = func(context.Context) (*Oauth2AccessToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m Oauth2AccessTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m Oauth2AccessTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Oauth2AccessToken entities.
func (m *Oauth2AccessTokenMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *Oauth2AccessTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *Oauth2AccessTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Oauth2AccessToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *Oauth2AccessTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *Oauth2AccessTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Oauth2AccessToken entity.
// If the Oauth2AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2AccessTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *Oauth2AccessTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *Oauth2AccessTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *Oauth2AccessTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Oauth2AccessToken entity.
// If the Oauth2AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2AccessTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *Oauth2AccessTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *Oauth2AccessTokenMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *Oauth2AccessTokenMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Oauth2AccessToken entity.
// If the Oauth2AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2AccessTokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *Oauth2AccessTokenMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *Oauth2AccessTokenMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *Oauth2AccessTokenMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetAccessToken sets the "access_token" field.
func (m *Oauth2AccessTokenMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *Oauth2AccessTokenMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the Oauth2AccessToken entity.
// If the Oauth2AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2AccessTokenMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *Oauth2AccessTokenMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *Oauth2AccessTokenMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *Oauth2AccessTokenMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the Oauth2AccessToken entity.
// If the Oauth2AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2AccessTokenMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *Oauth2AccessTokenMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetClientID sets the "client_id" field.
func (m *Oauth2AccessTokenMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *Oauth2AccessTokenMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Oauth2AccessToken entity.
// If the Oauth2AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2AccessTokenMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *Oauth2AccessTokenMutation) ResetClientID() {
	m.client_id = nil
}

// SetScope sets the "scope" field.
func (m *Oauth2AccessTokenMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *Oauth2AccessTokenMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the Oauth2AccessToken entity.
// If the Oauth2AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2AccessTokenMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *Oauth2AccessTokenMutation) ResetScope() {
	m.scope = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *Oauth2AccessTokenMutation) SetExpireAt(t time.Time) {
	m.expire_at = &t
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *Oauth2AccessTokenMutation) ExpireAt() (r time.Time, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the Oauth2AccessToken entity.
// If the Oauth2AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2AccessTokenMutation) OldExpireAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *Oauth2AccessTokenMutation) ResetExpireAt() {
	m.expire_at = nil
}

// Where appends a list predicates to the Oauth2AccessTokenMutation builder.
func (m *Oauth2AccessTokenMutation) Where(ps ...predicate.Oauth2AccessToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the Oauth2AccessTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *Oauth2AccessTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Oauth2AccessToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *Oauth2AccessTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *Oauth2AccessTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Oauth2AccessToken).
func (m *Oauth2AccessTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *Oauth2AccessTokenMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, oauth2accesstoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauth2accesstoken.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, oauth2accesstoken.FieldUserID)
	}
	if m.access_token != nil {
		fields = append(fields, oauth2accesstoken.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, oauth2accesstoken.FieldRefreshToken)
	}
	if m.client_id != nil {
		fields = append(fields, oauth2accesstoken.FieldClientID)
	}
	if m.scope != nil {
		fields = append(fields, oauth2accesstoken.FieldScope)
	}
	if m.expire_at != nil {
		fields = append(fields, oauth2accesstoken.FieldExpireAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *Oauth2AccessTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauth2accesstoken.FieldCreatedAt:
		return m.CreatedAt()
	case oauth2accesstoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauth2accesstoken.FieldUserID:
		return m.UserID()
	case oauth2accesstoken.FieldAccessToken:
		return m.AccessToken()
	case oauth2accesstoken.FieldRefreshToken:
		return m.RefreshToken()
	case oauth2accesstoken.FieldClientID:
		return m.ClientID()
	case oauth2accesstoken.FieldScope:
		return m.Scope()
	case oauth2accesstoken.FieldExpireAt:
		return m.ExpireAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *Oauth2AccessTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauth2accesstoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauth2accesstoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauth2accesstoken.FieldUserID:
		return m.OldUserID(ctx)
	case oauth2accesstoken.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case oauth2accesstoken.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case oauth2accesstoken.FieldClientID:
		return m.OldClientID(ctx)
	case oauth2accesstoken.FieldScope:
		return m.OldScope(ctx)
	case oauth2accesstoken.FieldExpireAt:
		return m.OldExpireAt(ctx)
	}
	return nil, fmt.Errorf("unknown Oauth2AccessToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Oauth2AccessTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauth2accesstoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauth2accesstoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauth2accesstoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oauth2accesstoken.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case oauth2accesstoken.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case oauth2accesstoken.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauth2accesstoken.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case oauth2accesstoken.FieldExpireAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2AccessToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *Oauth2AccessTokenMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, oauth2accesstoken.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *Oauth2AccessTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauth2accesstoken.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Oauth2AccessTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauth2accesstoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2AccessToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *Oauth2AccessTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *Oauth2AccessTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *Oauth2AccessTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Oauth2AccessToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *Oauth2AccessTokenMutation) ResetField(name string) error {
	switch name {
	case oauth2accesstoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauth2accesstoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauth2accesstoken.FieldUserID:
		m.ResetUserID()
		return nil
	case oauth2accesstoken.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case oauth2accesstoken.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case oauth2accesstoken.FieldClientID:
		m.ResetClientID()
		return nil
	case oauth2accesstoken.FieldScope:
		m.ResetScope()
		return nil
	case oauth2accesstoken.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	}
	return fmt.Errorf("unknown Oauth2AccessToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *Oauth2AccessTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *Oauth2AccessTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *Oauth2AccessTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *Oauth2AccessTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *Oauth2AccessTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *Oauth2AccessTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *Oauth2AccessTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Oauth2AccessToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *Oauth2AccessTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Oauth2AccessToken edge %s", name)
}

// Oauth2CodeMutation represents an operation that mutates the Oauth2Code nodes in the graph.
type Oauth2CodeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *int
	adduser_id    *int
	code          *string
	expire_at     *time.Time
	client_id     *string
	redirect_uri  *string
	scope         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Oauth2Code, error)
	predicates    []predicate.Oauth2Code
}

var _ ent.Mutation = (*Oauth2CodeMutation)(nil)

// oauth2codeOption allows management of the mutation configuration using functional options.
type oauth2codeOption func(*Oauth2CodeMutation)

// newOauth2CodeMutation creates new mutation for the Oauth2Code entity.
func newOauth2CodeMutation(c config, op Op, opts ...oauth2codeOption) *Oauth2CodeMutation {
	m := &Oauth2CodeMutation{
		config:        c,
		op:            op,
		typ:           TypeOauth2Code,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauth2CodeID sets the ID field of the mutation.
func withOauth2CodeID(id int) oauth2codeOption {
	return func(m *Oauth2CodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Oauth2Code
		)
		m.oldValue = func(ctx context.Context) (*Oauth2Code, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Oauth2Code.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauth2Code sets the old Oauth2Code of the mutation.
func withOauth2Code(node *Oauth2Code) oauth2codeOption {
	return func(m *Oauth2CodeMutation) {
		m.oldValue = func(context.Context) (*Oauth2Code, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m Oauth2CodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m Oauth2CodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Oauth2Code entities.
func (m *Oauth2CodeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *Oauth2CodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *Oauth2CodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Oauth2Code.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *Oauth2CodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *Oauth2CodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Oauth2Code entity.
// If the Oauth2Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2CodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *Oauth2CodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *Oauth2CodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *Oauth2CodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Oauth2Code entity.
// If the Oauth2Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2CodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *Oauth2CodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *Oauth2CodeMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *Oauth2CodeMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Oauth2Code entity.
// If the Oauth2Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2CodeMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *Oauth2CodeMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *Oauth2CodeMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *Oauth2CodeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCode sets the "code" field.
func (m *Oauth2CodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *Oauth2CodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Oauth2Code entity.
// If the Oauth2Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2CodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *Oauth2CodeMutation) ResetCode() {
	m.code = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *Oauth2CodeMutation) SetExpireAt(t time.Time) {
	m.expire_at = &t
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *Oauth2CodeMutation) ExpireAt() (r time.Time, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the Oauth2Code entity.
// If the Oauth2Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2CodeMutation) OldExpireAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *Oauth2CodeMutation) ResetExpireAt() {
	m.expire_at = nil
}

// SetClientID sets the "client_id" field.
func (m *Oauth2CodeMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *Oauth2CodeMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Oauth2Code entity.
// If the Oauth2Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2CodeMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *Oauth2CodeMutation) ResetClientID() {
	m.client_id = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *Oauth2CodeMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *Oauth2CodeMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the Oauth2Code entity.
// If the Oauth2Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2CodeMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *Oauth2CodeMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetScope sets the "scope" field.
func (m *Oauth2CodeMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *Oauth2CodeMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the Oauth2Code entity.
// If the Oauth2Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2CodeMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *Oauth2CodeMutation) ResetScope() {
	m.scope = nil
}

// Where appends a list predicates to the Oauth2CodeMutation builder.
func (m *Oauth2CodeMutation) Where(ps ...predicate.Oauth2Code) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the Oauth2CodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *Oauth2CodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Oauth2Code, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *Oauth2CodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *Oauth2CodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Oauth2Code).
func (m *Oauth2CodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *Oauth2CodeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, oauth2code.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauth2code.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, oauth2code.FieldUserID)
	}
	if m.code != nil {
		fields = append(fields, oauth2code.FieldCode)
	}
	if m.expire_at != nil {
		fields = append(fields, oauth2code.FieldExpireAt)
	}
	if m.client_id != nil {
		fields = append(fields, oauth2code.FieldClientID)
	}
	if m.redirect_uri != nil {
		fields = append(fields, oauth2code.FieldRedirectURI)
	}
	if m.scope != nil {
		fields = append(fields, oauth2code.FieldScope)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *Oauth2CodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauth2code.FieldCreatedAt:
		return m.CreatedAt()
	case oauth2code.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauth2code.FieldUserID:
		return m.UserID()
	case oauth2code.FieldCode:
		return m.Code()
	case oauth2code.FieldExpireAt:
		return m.ExpireAt()
	case oauth2code.FieldClientID:
		return m.ClientID()
	case oauth2code.FieldRedirectURI:
		return m.RedirectURI()
	case oauth2code.FieldScope:
		return m.Scope()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *Oauth2CodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauth2code.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauth2code.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauth2code.FieldUserID:
		return m.OldUserID(ctx)
	case oauth2code.FieldCode:
		return m.OldCode(ctx)
	case oauth2code.FieldExpireAt:
		return m.OldExpireAt(ctx)
	case oauth2code.FieldClientID:
		return m.OldClientID(ctx)
	case oauth2code.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case oauth2code.FieldScope:
		return m.OldScope(ctx)
	}
	return nil, fmt.Errorf("unknown Oauth2Code field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Oauth2CodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauth2code.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauth2code.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauth2code.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oauth2code.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case oauth2code.FieldExpireAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	case oauth2code.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauth2code.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case oauth2code.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2Code field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *Oauth2CodeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, oauth2code.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *Oauth2CodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauth2code.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Oauth2CodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauth2code.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2Code numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *Oauth2CodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *Oauth2CodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *Oauth2CodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Oauth2Code nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *Oauth2CodeMutation) ResetField(name string) error {
	switch name {
	case oauth2code.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauth2code.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauth2code.FieldUserID:
		m.ResetUserID()
		return nil
	case oauth2code.FieldCode:
		m.ResetCode()
		return nil
	case oauth2code.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	case oauth2code.FieldClientID:
		m.ResetClientID()
		return nil
	case oauth2code.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case oauth2code.FieldScope:
		m.ResetScope()
		return nil
	}
	return fmt.Errorf("unknown Oauth2Code field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *Oauth2CodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *Oauth2CodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *Oauth2CodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *Oauth2CodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *Oauth2CodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *Oauth2CodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *Oauth2CodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Oauth2Code unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *Oauth2CodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Oauth2Code edge %s", name)
}

// Oauth2RefreshTokenMutation represents an operation that mutates the Oauth2RefreshToken nodes in the graph.
type Oauth2RefreshTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *int
	adduser_id    *int
	refresh_token *string
	client_id     *string
	scope         *string
	expire_at     *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Oauth2RefreshToken, error)
	predicates    []predicate.Oauth2RefreshToken
}

var _ ent.Mutation = (*Oauth2RefreshTokenMutation)(nil)

// oauth2refreshtokenOption allows management of the mutation configuration using functional options.
type oauth2refreshtokenOption func(*Oauth2RefreshTokenMutation)

// newOauth2RefreshTokenMutation creates new mutation for the Oauth2RefreshToken entity.
func newOauth2RefreshTokenMutation(c config, op Op, opts ...oauth2refreshtokenOption) *Oauth2RefreshTokenMutation {
	m := &Oauth2RefreshTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeOauth2RefreshToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauth2RefreshTokenID sets the ID field of the mutation.
func withOauth2RefreshTokenID(id int) oauth2refreshtokenOption {
	return func(m *Oauth2RefreshTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Oauth2RefreshToken
		)
		m.oldValue = func(ctx context.Context) (*Oauth2RefreshToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Oauth2RefreshToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauth2RefreshToken sets the old Oauth2RefreshToken of the mutation.
func withOauth2RefreshToken(node *Oauth2RefreshToken) oauth2refreshtokenOption {
	return func(m *Oauth2RefreshTokenMutation) {
		m.oldValue = func(context.Context) (*Oauth2RefreshToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m Oauth2RefreshTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m Oauth2RefreshTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Oauth2RefreshToken entities.
func (m *Oauth2RefreshTokenMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *Oauth2RefreshTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *Oauth2RefreshTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Oauth2RefreshToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *Oauth2RefreshTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *Oauth2RefreshTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Oauth2RefreshToken entity.
// If the Oauth2RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2RefreshTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *Oauth2RefreshTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *Oauth2RefreshTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *Oauth2RefreshTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Oauth2RefreshToken entity.
// If the Oauth2RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2RefreshTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *Oauth2RefreshTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *Oauth2RefreshTokenMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *Oauth2RefreshTokenMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Oauth2RefreshToken entity.
// If the Oauth2RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2RefreshTokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *Oauth2RefreshTokenMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *Oauth2RefreshTokenMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *Oauth2RefreshTokenMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *Oauth2RefreshTokenMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *Oauth2RefreshTokenMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the Oauth2RefreshToken entity.
// If the Oauth2RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2RefreshTokenMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *Oauth2RefreshTokenMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetClientID sets the "client_id" field.
func (m *Oauth2RefreshTokenMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *Oauth2RefreshTokenMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the Oauth2RefreshToken entity.
// If the Oauth2RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2RefreshTokenMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *Oauth2RefreshTokenMutation) ResetClientID() {
	m.client_id = nil
}

// SetScope sets the "scope" field.
func (m *Oauth2RefreshTokenMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *Oauth2RefreshTokenMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the Oauth2RefreshToken entity.
// If the Oauth2RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2RefreshTokenMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *Oauth2RefreshTokenMutation) ResetScope() {
	m.scope = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *Oauth2RefreshTokenMutation) SetExpireAt(t time.Time) {
	m.expire_at = &t
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *Oauth2RefreshTokenMutation) ExpireAt() (r time.Time, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the Oauth2RefreshToken entity.
// If the Oauth2RefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Oauth2RefreshTokenMutation) OldExpireAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *Oauth2RefreshTokenMutation) ResetExpireAt() {
	m.expire_at = nil
}

// Where appends a list predicates to the Oauth2RefreshTokenMutation builder.
func (m *Oauth2RefreshTokenMutation) Where(ps ...predicate.Oauth2RefreshToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the Oauth2RefreshTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *Oauth2RefreshTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Oauth2RefreshToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *Oauth2RefreshTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *Oauth2RefreshTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Oauth2RefreshToken).
func (m *Oauth2RefreshTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *Oauth2RefreshTokenMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, oauth2refreshtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauth2refreshtoken.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, oauth2refreshtoken.FieldUserID)
	}
	if m.refresh_token != nil {
		fields = append(fields, oauth2refreshtoken.FieldRefreshToken)
	}
	if m.client_id != nil {
		fields = append(fields, oauth2refreshtoken.FieldClientID)
	}
	if m.scope != nil {
		fields = append(fields, oauth2refreshtoken.FieldScope)
	}
	if m.expire_at != nil {
		fields = append(fields, oauth2refreshtoken.FieldExpireAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *Oauth2RefreshTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauth2refreshtoken.FieldCreatedAt:
		return m.CreatedAt()
	case oauth2refreshtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauth2refreshtoken.FieldUserID:
		return m.UserID()
	case oauth2refreshtoken.FieldRefreshToken:
		return m.RefreshToken()
	case oauth2refreshtoken.FieldClientID:
		return m.ClientID()
	case oauth2refreshtoken.FieldScope:
		return m.Scope()
	case oauth2refreshtoken.FieldExpireAt:
		return m.ExpireAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *Oauth2RefreshTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauth2refreshtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauth2refreshtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauth2refreshtoken.FieldUserID:
		return m.OldUserID(ctx)
	case oauth2refreshtoken.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case oauth2refreshtoken.FieldClientID:
		return m.OldClientID(ctx)
	case oauth2refreshtoken.FieldScope:
		return m.OldScope(ctx)
	case oauth2refreshtoken.FieldExpireAt:
		return m.OldExpireAt(ctx)
	}
	return nil, fmt.Errorf("unknown Oauth2RefreshToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Oauth2RefreshTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauth2refreshtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauth2refreshtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauth2refreshtoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oauth2refreshtoken.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case oauth2refreshtoken.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauth2refreshtoken.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case oauth2refreshtoken.FieldExpireAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2RefreshToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *Oauth2RefreshTokenMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, oauth2refreshtoken.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *Oauth2RefreshTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauth2refreshtoken.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Oauth2RefreshTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauth2refreshtoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Oauth2RefreshToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *Oauth2RefreshTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *Oauth2RefreshTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *Oauth2RefreshTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Oauth2RefreshToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *Oauth2RefreshTokenMutation) ResetField(name string) error {
	switch name {
	case oauth2refreshtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauth2refreshtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauth2refreshtoken.FieldUserID:
		m.ResetUserID()
		return nil
	case oauth2refreshtoken.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case oauth2refreshtoken.FieldClientID:
		m.ResetClientID()
		return nil
	case oauth2refreshtoken.FieldScope:
		m.ResetScope()
		return nil
	case oauth2refreshtoken.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	}
	return fmt.Errorf("unknown Oauth2RefreshToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *Oauth2RefreshTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *Oauth2RefreshTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *Oauth2RefreshTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *Oauth2RefreshTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *Oauth2RefreshTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *Oauth2RefreshTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *Oauth2RefreshTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Oauth2RefreshToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *Oauth2RefreshTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Oauth2RefreshToken edge %s", name)
}

// PayOrderMutation represents an operation that mutates the PayOrder nodes in the graph.
type PayOrderMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	channel_type         *string
	order_id             *string
	merchant_order_id    *string
	out_trade_no         *string
	order_price          *int
	addorder_price       *int
	price                *int
	addprice             *int
	channel_fee_price    *int
	addchannel_fee_price *int
	subject              *string
	body                 *string
	notify_url           *string
	return_url           *string
	extra                *string
	pay_url              *string
	state                *string
	error_msg            *string
	raw                  *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*PayOrder, error)
	predicates           []predicate.PayOrder
}

var _ ent.Mutation = (*PayOrderMutation)(nil)

// payorderOption allows management of the mutation configuration using functional options.
type payorderOption func(*PayOrderMutation)

// newPayOrderMutation creates new mutation for the PayOrder entity.
func newPayOrderMutation(c config, op Op, opts ...payorderOption) *PayOrderMutation {
	m := &PayOrderMutation{
		config:        c,
		op:            op,
		typ:           TypePayOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPayOrderID sets the ID field of the mutation.
func withPayOrderID(id int) payorderOption {
	return func(m *PayOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *PayOrder
		)
		m.oldValue = func(ctx context.Context) (*PayOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PayOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayOrder sets the old PayOrder of the mutation.
func withPayOrder(node *PayOrder) payorderOption {
	return func(m *PayOrderMutation) {
		m.oldValue = func(context.Context) (*PayOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PayOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PayOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PayOrder entities.
func (m *PayOrderMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PayOrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PayOrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PayOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PayOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PayOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PayOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PayOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PayOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PayOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetChannelType sets the "channel_type" field.
func (m *PayOrderMutation) SetChannelType(s string) {
	m.channel_type = &s
}

// ChannelType returns the value of the "channel_type" field in the mutation.
func (m *PayOrderMutation) ChannelType() (r string, exists bool) {
	v := m.channel_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelType returns the old "channel_type" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldChannelType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelType: %w", err)
	}
	return oldValue.ChannelType, nil
}

// ClearChannelType clears the value of the "channel_type" field.
func (m *PayOrderMutation) ClearChannelType() {
	m.channel_type = nil
	m.clearedFields[payorder.FieldChannelType] = struct{}{}
}

// ChannelTypeCleared returns if the "channel_type" field was cleared in this mutation.
func (m *PayOrderMutation) ChannelTypeCleared() bool {
	_, ok := m.clearedFields[payorder.FieldChannelType]
	return ok
}

// ResetChannelType resets all changes to the "channel_type" field.
func (m *PayOrderMutation) ResetChannelType() {
	m.channel_type = nil
	delete(m.clearedFields, payorder.FieldChannelType)
}

// SetOrderID sets the "order_id" field.
func (m *PayOrderMutation) SetOrderID(s string) {
	m.order_id = &s
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *PayOrderMutation) OrderID() (r string, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldOrderID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *PayOrderMutation) ClearOrderID() {
	m.order_id = nil
	m.clearedFields[payorder.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *PayOrderMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[payorder.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *PayOrderMutation) ResetOrderID() {
	m.order_id = nil
	delete(m.clearedFields, payorder.FieldOrderID)
}

// SetMerchantOrderID sets the "merchant_order_id" field.
func (m *PayOrderMutation) SetMerchantOrderID(s string) {
	m.merchant_order_id = &s
}

// MerchantOrderID returns the value of the "merchant_order_id" field in the mutation.
func (m *PayOrderMutation) MerchantOrderID() (r string, exists bool) {
	v := m.merchant_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantOrderID returns the old "merchant_order_id" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldMerchantOrderID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantOrderID: %w", err)
	}
	return oldValue.MerchantOrderID, nil
}

// ClearMerchantOrderID clears the value of the "merchant_order_id" field.
func (m *PayOrderMutation) ClearMerchantOrderID() {
	m.merchant_order_id = nil
	m.clearedFields[payorder.FieldMerchantOrderID] = struct{}{}
}

// MerchantOrderIDCleared returns if the "merchant_order_id" field was cleared in this mutation.
func (m *PayOrderMutation) MerchantOrderIDCleared() bool {
	_, ok := m.clearedFields[payorder.FieldMerchantOrderID]
	return ok
}

// ResetMerchantOrderID resets all changes to the "merchant_order_id" field.
func (m *PayOrderMutation) ResetMerchantOrderID() {
	m.merchant_order_id = nil
	delete(m.clearedFields, payorder.FieldMerchantOrderID)
}

// SetOutTradeNo sets the "out_trade_no" field.
func (m *PayOrderMutation) SetOutTradeNo(s string) {
	m.out_trade_no = &s
}

// OutTradeNo returns the value of the "out_trade_no" field in the mutation.
func (m *PayOrderMutation) OutTradeNo() (r string, exists bool) {
	v := m.out_trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOutTradeNo returns the old "out_trade_no" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldOutTradeNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutTradeNo: %w", err)
	}
	return oldValue.OutTradeNo, nil
}

// ClearOutTradeNo clears the value of the "out_trade_no" field.
func (m *PayOrderMutation) ClearOutTradeNo() {
	m.out_trade_no = nil
	m.clearedFields[payorder.FieldOutTradeNo] = struct{}{}
}

// OutTradeNoCleared returns if the "out_trade_no" field was cleared in this mutation.
func (m *PayOrderMutation) OutTradeNoCleared() bool {
	_, ok := m.clearedFields[payorder.FieldOutTradeNo]
	return ok
}

// ResetOutTradeNo resets all changes to the "out_trade_no" field.
func (m *PayOrderMutation) ResetOutTradeNo() {
	m.out_trade_no = nil
	delete(m.clearedFields, payorder.FieldOutTradeNo)
}

// SetOrderPrice sets the "order_price" field.
func (m *PayOrderMutation) SetOrderPrice(i int) {
	m.order_price = &i
	m.addorder_price = nil
}

// OrderPrice returns the value of the "order_price" field in the mutation.
func (m *PayOrderMutation) OrderPrice() (r int, exists bool) {
	v := m.order_price
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderPrice returns the old "order_price" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldOrderPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderPrice: %w", err)
	}
	return oldValue.OrderPrice, nil
}

// AddOrderPrice adds i to the "order_price" field.
func (m *PayOrderMutation) AddOrderPrice(i int) {
	if m.addorder_price != nil {
		*m.addorder_price += i
	} else {
		m.addorder_price = &i
	}
}

// AddedOrderPrice returns the value that was added to the "order_price" field in this mutation.
func (m *PayOrderMutation) AddedOrderPrice() (r int, exists bool) {
	v := m.addorder_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderPrice clears the value of the "order_price" field.
func (m *PayOrderMutation) ClearOrderPrice() {
	m.order_price = nil
	m.addorder_price = nil
	m.clearedFields[payorder.FieldOrderPrice] = struct{}{}
}

// OrderPriceCleared returns if the "order_price" field was cleared in this mutation.
func (m *PayOrderMutation) OrderPriceCleared() bool {
	_, ok := m.clearedFields[payorder.FieldOrderPrice]
	return ok
}

// ResetOrderPrice resets all changes to the "order_price" field.
func (m *PayOrderMutation) ResetOrderPrice() {
	m.order_price = nil
	m.addorder_price = nil
	delete(m.clearedFields, payorder.FieldOrderPrice)
}

// SetPrice sets the "price" field.
func (m *PayOrderMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PayOrderMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *PayOrderMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PayOrderMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *PayOrderMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[payorder.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *PayOrderMutation) PriceCleared() bool {
	_, ok := m.clearedFields[payorder.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *PayOrderMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, payorder.FieldPrice)
}

// SetChannelFeePrice sets the "channel_fee_price" field.
func (m *PayOrderMutation) SetChannelFeePrice(i int) {
	m.channel_fee_price = &i
	m.addchannel_fee_price = nil
}

// ChannelFeePrice returns the value of the "channel_fee_price" field in the mutation.
func (m *PayOrderMutation) ChannelFeePrice() (r int, exists bool) {
	v := m.channel_fee_price
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelFeePrice returns the old "channel_fee_price" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldChannelFeePrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelFeePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelFeePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelFeePrice: %w", err)
	}
	return oldValue.ChannelFeePrice, nil
}

// AddChannelFeePrice adds i to the "channel_fee_price" field.
func (m *PayOrderMutation) AddChannelFeePrice(i int) {
	if m.addchannel_fee_price != nil {
		*m.addchannel_fee_price += i
	} else {
		m.addchannel_fee_price = &i
	}
}

// AddedChannelFeePrice returns the value that was added to the "channel_fee_price" field in this mutation.
func (m *PayOrderMutation) AddedChannelFeePrice() (r int, exists bool) {
	v := m.addchannel_fee_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearChannelFeePrice clears the value of the "channel_fee_price" field.
func (m *PayOrderMutation) ClearChannelFeePrice() {
	m.channel_fee_price = nil
	m.addchannel_fee_price = nil
	m.clearedFields[payorder.FieldChannelFeePrice] = struct{}{}
}

// ChannelFeePriceCleared returns if the "channel_fee_price" field was cleared in this mutation.
func (m *PayOrderMutation) ChannelFeePriceCleared() bool {
	_, ok := m.clearedFields[payorder.FieldChannelFeePrice]
	return ok
}

// ResetChannelFeePrice resets all changes to the "channel_fee_price" field.
func (m *PayOrderMutation) ResetChannelFeePrice() {
	m.channel_fee_price = nil
	m.addchannel_fee_price = nil
	delete(m.clearedFields, payorder.FieldChannelFeePrice)
}

// SetSubject sets the "subject" field.
func (m *PayOrderMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *PayOrderMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ClearSubject clears the value of the "subject" field.
func (m *PayOrderMutation) ClearSubject() {
	m.subject = nil
	m.clearedFields[payorder.FieldSubject] = struct{}{}
}

// SubjectCleared returns if the "subject" field was cleared in this mutation.
func (m *PayOrderMutation) SubjectCleared() bool {
	_, ok := m.clearedFields[payorder.FieldSubject]
	return ok
}

// ResetSubject resets all changes to the "subject" field.
func (m *PayOrderMutation) ResetSubject() {
	m.subject = nil
	delete(m.clearedFields, payorder.FieldSubject)
}

// SetBody sets the "body" field.
func (m *PayOrderMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *PayOrderMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ClearBody clears the value of the "body" field.
func (m *PayOrderMutation) ClearBody() {
	m.body = nil
	m.clearedFields[payorder.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *PayOrderMutation) BodyCleared() bool {
	_, ok := m.clearedFields[payorder.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *PayOrderMutation) ResetBody() {
	m.body = nil
	delete(m.clearedFields, payorder.FieldBody)
}

// SetNotifyURL sets the "notify_url" field.
func (m *PayOrderMutation) SetNotifyURL(s string) {
	m.notify_url = &s
}

// NotifyURL returns the value of the "notify_url" field in the mutation.
func (m *PayOrderMutation) NotifyURL() (r string, exists bool) {
	v := m.notify_url
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyURL returns the old "notify_url" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldNotifyURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyURL: %w", err)
	}
	return oldValue.NotifyURL, nil
}

// ClearNotifyURL clears the value of the "notify_url" field.
func (m *PayOrderMutation) ClearNotifyURL() {
	m.notify_url = nil
	m.clearedFields[payorder.FieldNotifyURL] = struct{}{}
}

// NotifyURLCleared returns if the "notify_url" field was cleared in this mutation.
func (m *PayOrderMutation) NotifyURLCleared() bool {
	_, ok := m.clearedFields[payorder.FieldNotifyURL]
	return ok
}

// ResetNotifyURL resets all changes to the "notify_url" field.
func (m *PayOrderMutation) ResetNotifyURL() {
	m.notify_url = nil
	delete(m.clearedFields, payorder.FieldNotifyURL)
}

// SetReturnURL sets the "return_url" field.
func (m *PayOrderMutation) SetReturnURL(s string) {
	m.return_url = &s
}

// ReturnURL returns the value of the "return_url" field in the mutation.
func (m *PayOrderMutation) ReturnURL() (r string, exists bool) {
	v := m.return_url
	if v == nil {
		return
	}
	return *v, true
}

// OldReturnURL returns the old "return_url" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldReturnURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReturnURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReturnURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReturnURL: %w", err)
	}
	return oldValue.ReturnURL, nil
}

// ClearReturnURL clears the value of the "return_url" field.
func (m *PayOrderMutation) ClearReturnURL() {
	m.return_url = nil
	m.clearedFields[payorder.FieldReturnURL] = struct{}{}
}

// ReturnURLCleared returns if the "return_url" field was cleared in this mutation.
func (m *PayOrderMutation) ReturnURLCleared() bool {
	_, ok := m.clearedFields[payorder.FieldReturnURL]
	return ok
}

// ResetReturnURL resets all changes to the "return_url" field.
func (m *PayOrderMutation) ResetReturnURL() {
	m.return_url = nil
	delete(m.clearedFields, payorder.FieldReturnURL)
}

// SetExtra sets the "extra" field.
func (m *PayOrderMutation) SetExtra(s string) {
	m.extra = &s
}

// Extra returns the value of the "extra" field in the mutation.
func (m *PayOrderMutation) Extra() (r string, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldExtra(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of the "extra" field.
func (m *PayOrderMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[payorder.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the "extra" field was cleared in this mutation.
func (m *PayOrderMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[payorder.FieldExtra]
	return ok
}

// ResetExtra resets all changes to the "extra" field.
func (m *PayOrderMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, payorder.FieldExtra)
}

// SetPayURL sets the "pay_url" field.
func (m *PayOrderMutation) SetPayURL(s string) {
	m.pay_url = &s
}

// PayURL returns the value of the "pay_url" field in the mutation.
func (m *PayOrderMutation) PayURL() (r string, exists bool) {
	v := m.pay_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPayURL returns the old "pay_url" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldPayURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayURL: %w", err)
	}
	return oldValue.PayURL, nil
}

// ClearPayURL clears the value of the "pay_url" field.
func (m *PayOrderMutation) ClearPayURL() {
	m.pay_url = nil
	m.clearedFields[payorder.FieldPayURL] = struct{}{}
}

// PayURLCleared returns if the "pay_url" field was cleared in this mutation.
func (m *PayOrderMutation) PayURLCleared() bool {
	_, ok := m.clearedFields[payorder.FieldPayURL]
	return ok
}

// ResetPayURL resets all changes to the "pay_url" field.
func (m *PayOrderMutation) ResetPayURL() {
	m.pay_url = nil
	delete(m.clearedFields, payorder.FieldPayURL)
}

// SetState sets the "state" field.
func (m *PayOrderMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *PayOrderMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *PayOrderMutation) ClearState() {
	m.state = nil
	m.clearedFields[payorder.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *PayOrderMutation) StateCleared() bool {
	_, ok := m.clearedFields[payorder.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *PayOrderMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, payorder.FieldState)
}

// SetErrorMsg sets the "error_msg" field.
func (m *PayOrderMutation) SetErrorMsg(s string) {
	m.error_msg = &s
}

// ErrorMsg returns the value of the "error_msg" field in the mutation.
func (m *PayOrderMutation) ErrorMsg() (r string, exists bool) {
	v := m.error_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMsg returns the old "error_msg" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldErrorMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMsg: %w", err)
	}
	return oldValue.ErrorMsg, nil
}

// ClearErrorMsg clears the value of the "error_msg" field.
func (m *PayOrderMutation) ClearErrorMsg() {
	m.error_msg = nil
	m.clearedFields[payorder.FieldErrorMsg] = struct{}{}
}

// ErrorMsgCleared returns if the "error_msg" field was cleared in this mutation.
func (m *PayOrderMutation) ErrorMsgCleared() bool {
	_, ok := m.clearedFields[payorder.FieldErrorMsg]
	return ok
}

// ResetErrorMsg resets all changes to the "error_msg" field.
func (m *PayOrderMutation) ResetErrorMsg() {
	m.error_msg = nil
	delete(m.clearedFields, payorder.FieldErrorMsg)
}

// SetRaw sets the "raw" field.
func (m *PayOrderMutation) SetRaw(s string) {
	m.raw = &s
}

// Raw returns the value of the "raw" field in the mutation.
func (m *PayOrderMutation) Raw() (r string, exists bool) {
	v := m.raw
	if v == nil {
		return
	}
	return *v, true
}

// OldRaw returns the old "raw" field's value of the PayOrder entity.
// If the PayOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PayOrderMutation) OldRaw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRaw: %w", err)
	}
	return oldValue.Raw, nil
}

// ClearRaw clears the value of the "raw" field.
func (m *PayOrderMutation) ClearRaw() {
	m.raw = nil
	m.clearedFields[payorder.FieldRaw] = struct{}{}
}

// RawCleared returns if the "raw" field was cleared in this mutation.
func (m *PayOrderMutation) RawCleared() bool {
	_, ok := m.clearedFields[payorder.FieldRaw]
	return ok
}

// ResetRaw resets all changes to the "raw" field.
func (m *PayOrderMutation) ResetRaw() {
	m.raw = nil
	delete(m.clearedFields, payorder.FieldRaw)
}

// Where appends a list predicates to the PayOrderMutation builder.
func (m *PayOrderMutation) Where(ps ...predicate.PayOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PayOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PayOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PayOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PayOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PayOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PayOrder).
func (m *PayOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PayOrderMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, payorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, payorder.FieldUpdatedAt)
	}
	if m.channel_type != nil {
		fields = append(fields, payorder.FieldChannelType)
	}
	if m.order_id != nil {
		fields = append(fields, payorder.FieldOrderID)
	}
	if m.merchant_order_id != nil {
		fields = append(fields, payorder.FieldMerchantOrderID)
	}
	if m.out_trade_no != nil {
		fields = append(fields, payorder.FieldOutTradeNo)
	}
	if m.order_price != nil {
		fields = append(fields, payorder.FieldOrderPrice)
	}
	if m.price != nil {
		fields = append(fields, payorder.FieldPrice)
	}
	if m.channel_fee_price != nil {
		fields = append(fields, payorder.FieldChannelFeePrice)
	}
	if m.subject != nil {
		fields = append(fields, payorder.FieldSubject)
	}
	if m.body != nil {
		fields = append(fields, payorder.FieldBody)
	}
	if m.notify_url != nil {
		fields = append(fields, payorder.FieldNotifyURL)
	}
	if m.return_url != nil {
		fields = append(fields, payorder.FieldReturnURL)
	}
	if m.extra != nil {
		fields = append(fields, payorder.FieldExtra)
	}
	if m.pay_url != nil {
		fields = append(fields, payorder.FieldPayURL)
	}
	if m.state != nil {
		fields = append(fields, payorder.FieldState)
	}
	if m.error_msg != nil {
		fields = append(fields, payorder.FieldErrorMsg)
	}
	if m.raw != nil {
		fields = append(fields, payorder.FieldRaw)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PayOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payorder.FieldCreatedAt:
		return m.CreatedAt()
	case payorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case payorder.FieldChannelType:
		return m.ChannelType()
	case payorder.FieldOrderID:
		return m.OrderID()
	case payorder.FieldMerchantOrderID:
		return m.MerchantOrderID()
	case payorder.FieldOutTradeNo:
		return m.OutTradeNo()
	case payorder.FieldOrderPrice:
		return m.OrderPrice()
	case payorder.FieldPrice:
		return m.Price()
	case payorder.FieldChannelFeePrice:
		return m.ChannelFeePrice()
	case payorder.FieldSubject:
		return m.Subject()
	case payorder.FieldBody:
		return m.Body()
	case payorder.FieldNotifyURL:
		return m.NotifyURL()
	case payorder.FieldReturnURL:
		return m.ReturnURL()
	case payorder.FieldExtra:
		return m.Extra()
	case payorder.FieldPayURL:
		return m.PayURL()
	case payorder.FieldState:
		return m.State()
	case payorder.FieldErrorMsg:
		return m.ErrorMsg()
	case payorder.FieldRaw:
		return m.Raw()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PayOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payorder.FieldChannelType:
		return m.OldChannelType(ctx)
	case payorder.FieldOrderID:
		return m.OldOrderID(ctx)
	case payorder.FieldMerchantOrderID:
		return m.OldMerchantOrderID(ctx)
	case payorder.FieldOutTradeNo:
		return m.OldOutTradeNo(ctx)
	case payorder.FieldOrderPrice:
		return m.OldOrderPrice(ctx)
	case payorder.FieldPrice:
		return m.OldPrice(ctx)
	case payorder.FieldChannelFeePrice:
		return m.OldChannelFeePrice(ctx)
	case payorder.FieldSubject:
		return m.OldSubject(ctx)
	case payorder.FieldBody:
		return m.OldBody(ctx)
	case payorder.FieldNotifyURL:
		return m.OldNotifyURL(ctx)
	case payorder.FieldReturnURL:
		return m.OldReturnURL(ctx)
	case payorder.FieldExtra:
		return m.OldExtra(ctx)
	case payorder.FieldPayURL:
		return m.OldPayURL(ctx)
	case payorder.FieldState:
		return m.OldState(ctx)
	case payorder.FieldErrorMsg:
		return m.OldErrorMsg(ctx)
	case payorder.FieldRaw:
		return m.OldRaw(ctx)
	}
	return nil, fmt.Errorf("unknown PayOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payorder.FieldChannelType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelType(v)
		return nil
	case payorder.FieldOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case payorder.FieldMerchantOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantOrderID(v)
		return nil
	case payorder.FieldOutTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutTradeNo(v)
		return nil
	case payorder.FieldOrderPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderPrice(v)
		return nil
	case payorder.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case payorder.FieldChannelFeePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelFeePrice(v)
		return nil
	case payorder.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case payorder.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case payorder.FieldNotifyURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyURL(v)
		return nil
	case payorder.FieldReturnURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReturnURL(v)
		return nil
	case payorder.FieldExtra:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	case payorder.FieldPayURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayURL(v)
		return nil
	case payorder.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case payorder.FieldErrorMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMsg(v)
		return nil
	case payorder.FieldRaw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRaw(v)
		return nil
	}
	return fmt.Errorf("unknown PayOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PayOrderMutation) AddedFields() []string {
	var fields []string
	if m.addorder_price != nil {
		fields = append(fields, payorder.FieldOrderPrice)
	}
	if m.addprice != nil {
		fields = append(fields, payorder.FieldPrice)
	}
	if m.addchannel_fee_price != nil {
		fields = append(fields, payorder.FieldChannelFeePrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PayOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payorder.FieldOrderPrice:
		return m.AddedOrderPrice()
	case payorder.FieldPrice:
		return m.AddedPrice()
	case payorder.FieldChannelFeePrice:
		return m.AddedChannelFeePrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PayOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payorder.FieldOrderPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderPrice(v)
		return nil
	case payorder.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case payorder.FieldChannelFeePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannelFeePrice(v)
		return nil
	}
	return fmt.Errorf("unknown PayOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PayOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payorder.FieldChannelType) {
		fields = append(fields, payorder.FieldChannelType)
	}
	if m.FieldCleared(payorder.FieldOrderID) {
		fields = append(fields, payorder.FieldOrderID)
	}
	if m.FieldCleared(payorder.FieldMerchantOrderID) {
		fields = append(fields, payorder.FieldMerchantOrderID)
	}
	if m.FieldCleared(payorder.FieldOutTradeNo) {
		fields = append(fields, payorder.FieldOutTradeNo)
	}
	if m.FieldCleared(payorder.FieldOrderPrice) {
		fields = append(fields, payorder.FieldOrderPrice)
	}
	if m.FieldCleared(payorder.FieldPrice) {
		fields = append(fields, payorder.FieldPrice)
	}
	if m.FieldCleared(payorder.FieldChannelFeePrice) {
		fields = append(fields, payorder.FieldChannelFeePrice)
	}
	if m.FieldCleared(payorder.FieldSubject) {
		fields = append(fields, payorder.FieldSubject)
	}
	if m.FieldCleared(payorder.FieldBody) {
		fields = append(fields, payorder.FieldBody)
	}
	if m.FieldCleared(payorder.FieldNotifyURL) {
		fields = append(fields, payorder.FieldNotifyURL)
	}
	if m.FieldCleared(payorder.FieldReturnURL) {
		fields = append(fields, payorder.FieldReturnURL)
	}
	if m.FieldCleared(payorder.FieldExtra) {
		fields = append(fields, payorder.FieldExtra)
	}
	if m.FieldCleared(payorder.FieldPayURL) {
		fields = append(fields, payorder.FieldPayURL)
	}
	if m.FieldCleared(payorder.FieldState) {
		fields = append(fields, payorder.FieldState)
	}
	if m.FieldCleared(payorder.FieldErrorMsg) {
		fields = append(fields, payorder.FieldErrorMsg)
	}
	if m.FieldCleared(payorder.FieldRaw) {
		fields = append(fields, payorder.FieldRaw)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PayOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PayOrderMutation) ClearField(name string) error {
	switch name {
	case payorder.FieldChannelType:
		m.ClearChannelType()
		return nil
	case payorder.FieldOrderID:
		m.ClearOrderID()
		return nil
	case payorder.FieldMerchantOrderID:
		m.ClearMerchantOrderID()
		return nil
	case payorder.FieldOutTradeNo:
		m.ClearOutTradeNo()
		return nil
	case payorder.FieldOrderPrice:
		m.ClearOrderPrice()
		return nil
	case payorder.FieldPrice:
		m.ClearPrice()
		return nil
	case payorder.FieldChannelFeePrice:
		m.ClearChannelFeePrice()
		return nil
	case payorder.FieldSubject:
		m.ClearSubject()
		return nil
	case payorder.FieldBody:
		m.ClearBody()
		return nil
	case payorder.FieldNotifyURL:
		m.ClearNotifyURL()
		return nil
	case payorder.FieldReturnURL:
		m.ClearReturnURL()
		return nil
	case payorder.FieldExtra:
		m.ClearExtra()
		return nil
	case payorder.FieldPayURL:
		m.ClearPayURL()
		return nil
	case payorder.FieldState:
		m.ClearState()
		return nil
	case payorder.FieldErrorMsg:
		m.ClearErrorMsg()
		return nil
	case payorder.FieldRaw:
		m.ClearRaw()
		return nil
	}
	return fmt.Errorf("unknown PayOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PayOrderMutation) ResetField(name string) error {
	switch name {
	case payorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payorder.FieldChannelType:
		m.ResetChannelType()
		return nil
	case payorder.FieldOrderID:
		m.ResetOrderID()
		return nil
	case payorder.FieldMerchantOrderID:
		m.ResetMerchantOrderID()
		return nil
	case payorder.FieldOutTradeNo:
		m.ResetOutTradeNo()
		return nil
	case payorder.FieldOrderPrice:
		m.ResetOrderPrice()
		return nil
	case payorder.FieldPrice:
		m.ResetPrice()
		return nil
	case payorder.FieldChannelFeePrice:
		m.ResetChannelFeePrice()
		return nil
	case payorder.FieldSubject:
		m.ResetSubject()
		return nil
	case payorder.FieldBody:
		m.ResetBody()
		return nil
	case payorder.FieldNotifyURL:
		m.ResetNotifyURL()
		return nil
	case payorder.FieldReturnURL:
		m.ResetReturnURL()
		return nil
	case payorder.FieldExtra:
		m.ResetExtra()
		return nil
	case payorder.FieldPayURL:
		m.ResetPayURL()
		return nil
	case payorder.FieldState:
		m.ResetState()
		return nil
	case payorder.FieldErrorMsg:
		m.ResetErrorMsg()
		return nil
	case payorder.FieldRaw:
		m.ResetRaw()
		return nil
	}
	return fmt.Errorf("unknown PayOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PayOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PayOrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PayOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PayOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PayOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PayOrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PayOrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PayOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PayOrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PayOrder edge %s", name)
}

// PersonalAccessTokenMutation represents an operation that mutates the PersonalAccessToken nodes in the graph.
type PersonalAccessTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	expires       *time.Time
	description   *string
	token         *string
	user_id       *int
	adduser_id    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PersonalAccessToken, error)
	predicates    []predicate.PersonalAccessToken
}

var _ ent.Mutation = (*PersonalAccessTokenMutation)(nil)

// personalaccesstokenOption allows management of the mutation configuration using functional options.
type personalaccesstokenOption func(*PersonalAccessTokenMutation)

// newPersonalAccessTokenMutation creates new mutation for the PersonalAccessToken entity.
func newPersonalAccessTokenMutation(c config, op Op, opts ...personalaccesstokenOption) *PersonalAccessTokenMutation {
	m := &PersonalAccessTokenMutation{
		config:        c,
		op:            op,
		typ:           TypePersonalAccessToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonalAccessTokenID sets the ID field of the mutation.
func withPersonalAccessTokenID(id int) personalaccesstokenOption {
	return func(m *PersonalAccessTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonalAccessToken
		)
		m.oldValue = func(ctx context.Context) (*PersonalAccessToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonalAccessToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonalAccessToken sets the old PersonalAccessToken of the mutation.
func withPersonalAccessToken(node *PersonalAccessToken) personalaccesstokenOption {
	return func(m *PersonalAccessTokenMutation) {
		m.oldValue = func(context.Context) (*PersonalAccessToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonalAccessTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonalAccessTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PersonalAccessToken entities.
func (m *PersonalAccessTokenMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonalAccessTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonalAccessTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PersonalAccessToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonalAccessTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonalAccessTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonalAccessTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonalAccessTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonalAccessTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonalAccessTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PersonalAccessTokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonalAccessTokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonalAccessTokenMutation) ResetName() {
	m.name = nil
}

// SetExpires sets the "expires" field.
func (m *PersonalAccessTokenMutation) SetExpires(t time.Time) {
	m.expires = &t
}

// Expires returns the value of the "expires" field in the mutation.
func (m *PersonalAccessTokenMutation) Expires() (r time.Time, exists bool) {
	v := m.expires
	if v == nil {
		return
	}
	return *v, true
}

// OldExpires returns the old "expires" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldExpires(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpires: %w", err)
	}
	return oldValue.Expires, nil
}

// ClearExpires clears the value of the "expires" field.
func (m *PersonalAccessTokenMutation) ClearExpires() {
	m.expires = nil
	m.clearedFields[personalaccesstoken.FieldExpires] = struct{}{}
}

// ExpiresCleared returns if the "expires" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) ExpiresCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldExpires]
	return ok
}

// ResetExpires resets all changes to the "expires" field.
func (m *PersonalAccessTokenMutation) ResetExpires() {
	m.expires = nil
	delete(m.clearedFields, personalaccesstoken.FieldExpires)
}

// SetDescription sets the "description" field.
func (m *PersonalAccessTokenMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PersonalAccessTokenMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PersonalAccessTokenMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[personalaccesstoken.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PersonalAccessTokenMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[personalaccesstoken.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PersonalAccessTokenMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, personalaccesstoken.FieldDescription)
}

// SetToken sets the "token" field.
func (m *PersonalAccessTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *PersonalAccessTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *PersonalAccessTokenMutation) ResetToken() {
	m.token = nil
}

// SetUserID sets the "user_id" field.
func (m *PersonalAccessTokenMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PersonalAccessTokenMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PersonalAccessToken entity.
// If the PersonalAccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalAccessTokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *PersonalAccessTokenMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *PersonalAccessTokenMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PersonalAccessTokenMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// Where appends a list predicates to the PersonalAccessTokenMutation builder.
func (m *PersonalAccessTokenMutation) Where(ps ...predicate.PersonalAccessToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonalAccessTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonalAccessTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PersonalAccessToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonalAccessTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonalAccessTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PersonalAccessToken).
func (m *PersonalAccessTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonalAccessTokenMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, personalaccesstoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, personalaccesstoken.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, personalaccesstoken.FieldName)
	}
	if m.expires != nil {
		fields = append(fields, personalaccesstoken.FieldExpires)
	}
	if m.description != nil {
		fields = append(fields, personalaccesstoken.FieldDescription)
	}
	if m.token != nil {
		fields = append(fields, personalaccesstoken.FieldToken)
	}
	if m.user_id != nil {
		fields = append(fields, personalaccesstoken.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonalAccessTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personalaccesstoken.FieldCreatedAt:
		return m.CreatedAt()
	case personalaccesstoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case personalaccesstoken.FieldName:
		return m.Name()
	case personalaccesstoken.FieldExpires:
		return m.Expires()
	case personalaccesstoken.FieldDescription:
		return m.Description()
	case personalaccesstoken.FieldToken:
		return m.Token()
	case personalaccesstoken.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonalAccessTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personalaccesstoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case personalaccesstoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case personalaccesstoken.FieldName:
		return m.OldName(ctx)
	case personalaccesstoken.FieldExpires:
		return m.OldExpires(ctx)
	case personalaccesstoken.FieldDescription:
		return m.OldDescription(ctx)
	case personalaccesstoken.FieldToken:
		return m.OldToken(ctx)
	case personalaccesstoken.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown PersonalAccessToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalAccessTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personalaccesstoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case personalaccesstoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case personalaccesstoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case personalaccesstoken.FieldExpires:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpires(v)
		return nil
	case personalaccesstoken.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case personalaccesstoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case personalaccesstoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonalAccessTokenMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, personalaccesstoken.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonalAccessTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case personalaccesstoken.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalAccessTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case personalaccesstoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonalAccessTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(personalaccesstoken.FieldExpires) {
		fields = append(fields, personalaccesstoken.FieldExpires)
	}
	if m.FieldCleared(personalaccesstoken.FieldDescription) {
		fields = append(fields, personalaccesstoken.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonalAccessTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonalAccessTokenMutation) ClearField(name string) error {
	switch name {
	case personalaccesstoken.FieldExpires:
		m.ClearExpires()
		return nil
	case personalaccesstoken.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonalAccessTokenMutation) ResetField(name string) error {
	switch name {
	case personalaccesstoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case personalaccesstoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case personalaccesstoken.FieldName:
		m.ResetName()
		return nil
	case personalaccesstoken.FieldExpires:
		m.ResetExpires()
		return nil
	case personalaccesstoken.FieldDescription:
		m.ResetDescription()
		return nil
	case personalaccesstoken.FieldToken:
		m.ResetToken()
		return nil
	case personalaccesstoken.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown PersonalAccessToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonalAccessTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonalAccessTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonalAccessTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonalAccessTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonalAccessTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonalAccessTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonalAccessTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PersonalAccessToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonalAccessTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PersonalAccessToken edge %s", name)
}

// PluginMutation represents an operation that mutates the Plugin nodes in the graph.
type PluginMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	key                 *string
	name                *string
	version             *string
	description         *string
	bin_path            *string
	protocol_version    *uint
	addprotocol_version *int
	magic_cookie_key    *string
	magic_cookie_value  *string
	dependencies        *[]string
	appenddependencies  []string
	_config             *string
	enabled             *bool
	auto_start          *bool
	status              *plugin.Status
	last_error          *string
	last_started_at     *time.Time
	last_stopped_at     *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Plugin, error)
	predicates          []predicate.Plugin
}

var _ ent.Mutation = (*PluginMutation)(nil)

// pluginOption allows management of the mutation configuration using functional options.
type pluginOption func(*PluginMutation)

// newPluginMutation creates new mutation for the Plugin entity.
func newPluginMutation(c config, op Op, opts ...pluginOption) *PluginMutation {
	m := &PluginMutation{
		config:        c,
		op:            op,
		typ:           TypePlugin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPluginID sets the ID field of the mutation.
func withPluginID(id int) pluginOption {
	return func(m *PluginMutation) {
		var (
			err   error
			once  sync.Once
			value *Plugin
		)
		m.oldValue = func(ctx context.Context) (*Plugin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plugin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlugin sets the old Plugin of the mutation.
func withPlugin(node *Plugin) pluginOption {
	return func(m *PluginMutation) {
		m.oldValue = func(context.Context) (*Plugin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PluginMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PluginMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plugin entities.
func (m *PluginMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PluginMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PluginMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plugin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PluginMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PluginMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PluginMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PluginMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PluginMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PluginMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the "key" field.
func (m *PluginMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PluginMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PluginMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *PluginMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PluginMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PluginMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PluginMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PluginMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PluginMutation) ResetVersion() {
	m.version = nil
}

// SetDescription sets the "description" field.
func (m *PluginMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PluginMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PluginMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[plugin.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PluginMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[plugin.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PluginMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, plugin.FieldDescription)
}

// SetBinPath sets the "bin_path" field.
func (m *PluginMutation) SetBinPath(s string) {
	m.bin_path = &s
}

// BinPath returns the value of the "bin_path" field in the mutation.
func (m *PluginMutation) BinPath() (r string, exists bool) {
	v := m.bin_path
	if v == nil {
		return
	}
	return *v, true
}

// OldBinPath returns the old "bin_path" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldBinPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinPath: %w", err)
	}
	return oldValue.BinPath, nil
}

// ResetBinPath resets all changes to the "bin_path" field.
func (m *PluginMutation) ResetBinPath() {
	m.bin_path = nil
}

// SetProtocolVersion sets the "protocol_version" field.
func (m *PluginMutation) SetProtocolVersion(u uint) {
	m.protocol_version = &u
	m.addprotocol_version = nil
}

// ProtocolVersion returns the value of the "protocol_version" field in the mutation.
func (m *PluginMutation) ProtocolVersion() (r uint, exists bool) {
	v := m.protocol_version
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocolVersion returns the old "protocol_version" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldProtocolVersion(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocolVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocolVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocolVersion: %w", err)
	}
	return oldValue.ProtocolVersion, nil
}

// AddProtocolVersion adds u to the "protocol_version" field.
func (m *PluginMutation) AddProtocolVersion(u int) {
	if m.addprotocol_version != nil {
		*m.addprotocol_version += u
	} else {
		m.addprotocol_version = &u
	}
}

// AddedProtocolVersion returns the value that was added to the "protocol_version" field in this mutation.
func (m *PluginMutation) AddedProtocolVersion() (r int, exists bool) {
	v := m.addprotocol_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetProtocolVersion resets all changes to the "protocol_version" field.
func (m *PluginMutation) ResetProtocolVersion() {
	m.protocol_version = nil
	m.addprotocol_version = nil
}

// SetMagicCookieKey sets the "magic_cookie_key" field.
func (m *PluginMutation) SetMagicCookieKey(s string) {
	m.magic_cookie_key = &s
}

// MagicCookieKey returns the value of the "magic_cookie_key" field in the mutation.
func (m *PluginMutation) MagicCookieKey() (r string, exists bool) {
	v := m.magic_cookie_key
	if v == nil {
		return
	}
	return *v, true
}

// OldMagicCookieKey returns the old "magic_cookie_key" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldMagicCookieKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagicCookieKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagicCookieKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagicCookieKey: %w", err)
	}
	return oldValue.MagicCookieKey, nil
}

// ResetMagicCookieKey resets all changes to the "magic_cookie_key" field.
func (m *PluginMutation) ResetMagicCookieKey() {
	m.magic_cookie_key = nil
}

// SetMagicCookieValue sets the "magic_cookie_value" field.
func (m *PluginMutation) SetMagicCookieValue(s string) {
	m.magic_cookie_value = &s
}

// MagicCookieValue returns the value of the "magic_cookie_value" field in the mutation.
func (m *PluginMutation) MagicCookieValue() (r string, exists bool) {
	v := m.magic_cookie_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMagicCookieValue returns the old "magic_cookie_value" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldMagicCookieValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagicCookieValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagicCookieValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagicCookieValue: %w", err)
	}
	return oldValue.MagicCookieValue, nil
}

// ResetMagicCookieValue resets all changes to the "magic_cookie_value" field.
func (m *PluginMutation) ResetMagicCookieValue() {
	m.magic_cookie_value = nil
}

// SetDependencies sets the "dependencies" field.
func (m *PluginMutation) SetDependencies(s []string) {
	m.dependencies = &s
	m.appenddependencies = nil
}

// Dependencies returns the value of the "dependencies" field in the mutation.
func (m *PluginMutation) Dependencies() (r []string, exists bool) {
	v := m.dependencies
	if v == nil {
		return
	}
	return *v, true
}

// OldDependencies returns the old "dependencies" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldDependencies(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDependencies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDependencies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDependencies: %w", err)
	}
	return oldValue.Dependencies, nil
}

// AppendDependencies adds s to the "dependencies" field.
func (m *PluginMutation) AppendDependencies(s []string) {
	m.appenddependencies = append(m.appenddependencies, s...)
}

// AppendedDependencies returns the list of values that were appended to the "dependencies" field in this mutation.
func (m *PluginMutation) AppendedDependencies() ([]string, bool) {
	if len(m.appenddependencies) == 0 {
		return nil, false
	}
	return m.appenddependencies, true
}

// ClearDependencies clears the value of the "dependencies" field.
func (m *PluginMutation) ClearDependencies() {
	m.dependencies = nil
	m.appenddependencies = nil
	m.clearedFields[plugin.FieldDependencies] = struct{}{}
}

// DependenciesCleared returns if the "dependencies" field was cleared in this mutation.
func (m *PluginMutation) DependenciesCleared() bool {
	_, ok := m.clearedFields[plugin.FieldDependencies]
	return ok
}

// ResetDependencies resets all changes to the "dependencies" field.
func (m *PluginMutation) ResetDependencies() {
	m.dependencies = nil
	m.appenddependencies = nil
	delete(m.clearedFields, plugin.FieldDependencies)
}

// SetConfig sets the "config" field.
func (m *PluginMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *PluginMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *PluginMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[plugin.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *PluginMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[plugin.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *PluginMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, plugin.FieldConfig)
}

// SetEnabled sets the "enabled" field.
func (m *PluginMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *PluginMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *PluginMutation) ResetEnabled() {
	m.enabled = nil
}

// SetAutoStart sets the "auto_start" field.
func (m *PluginMutation) SetAutoStart(b bool) {
	m.auto_start = &b
}

// AutoStart returns the value of the "auto_start" field in the mutation.
func (m *PluginMutation) AutoStart() (r bool, exists bool) {
	v := m.auto_start
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoStart returns the old "auto_start" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldAutoStart(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoStart: %w", err)
	}
	return oldValue.AutoStart, nil
}

// ResetAutoStart resets all changes to the "auto_start" field.
func (m *PluginMutation) ResetAutoStart() {
	m.auto_start = nil
}

// SetStatus sets the "status" field.
func (m *PluginMutation) SetStatus(pl plugin.Status) {
	m.status = &pl
}

// Status returns the value of the "status" field in the mutation.
func (m *PluginMutation) Status() (r plugin.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldStatus(ctx context.Context) (v plugin.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PluginMutation) ResetStatus() {
	m.status = nil
}

// SetLastError sets the "last_error" field.
func (m *PluginMutation) SetLastError(s string) {
	m.last_error = &s
}

// LastError returns the value of the "last_error" field in the mutation.
func (m *PluginMutation) LastError() (r string, exists bool) {
	v := m.last_error
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "last_error" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldLastError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ClearLastError clears the value of the "last_error" field.
func (m *PluginMutation) ClearLastError() {
	m.last_error = nil
	m.clearedFields[plugin.FieldLastError] = struct{}{}
}

// LastErrorCleared returns if the "last_error" field was cleared in this mutation.
func (m *PluginMutation) LastErrorCleared() bool {
	_, ok := m.clearedFields[plugin.FieldLastError]
	return ok
}

// ResetLastError resets all changes to the "last_error" field.
func (m *PluginMutation) ResetLastError() {
	m.last_error = nil
	delete(m.clearedFields, plugin.FieldLastError)
}

// SetLastStartedAt sets the "last_started_at" field.
func (m *PluginMutation) SetLastStartedAt(t time.Time) {
	m.last_started_at = &t
}

// LastStartedAt returns the value of the "last_started_at" field in the mutation.
func (m *PluginMutation) LastStartedAt() (r time.Time, exists bool) {
	v := m.last_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStartedAt returns the old "last_started_at" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldLastStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStartedAt: %w", err)
	}
	return oldValue.LastStartedAt, nil
}

// ClearLastStartedAt clears the value of the "last_started_at" field.
func (m *PluginMutation) ClearLastStartedAt() {
	m.last_started_at = nil
	m.clearedFields[plugin.FieldLastStartedAt] = struct{}{}
}

// LastStartedAtCleared returns if the "last_started_at" field was cleared in this mutation.
func (m *PluginMutation) LastStartedAtCleared() bool {
	_, ok := m.clearedFields[plugin.FieldLastStartedAt]
	return ok
}

// ResetLastStartedAt resets all changes to the "last_started_at" field.
func (m *PluginMutation) ResetLastStartedAt() {
	m.last_started_at = nil
	delete(m.clearedFields, plugin.FieldLastStartedAt)
}

// SetLastStoppedAt sets the "last_stopped_at" field.
func (m *PluginMutation) SetLastStoppedAt(t time.Time) {
	m.last_stopped_at = &t
}

// LastStoppedAt returns the value of the "last_stopped_at" field in the mutation.
func (m *PluginMutation) LastStoppedAt() (r time.Time, exists bool) {
	v := m.last_stopped_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStoppedAt returns the old "last_stopped_at" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldLastStoppedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastStoppedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastStoppedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStoppedAt: %w", err)
	}
	return oldValue.LastStoppedAt, nil
}

// ClearLastStoppedAt clears the value of the "last_stopped_at" field.
func (m *PluginMutation) ClearLastStoppedAt() {
	m.last_stopped_at = nil
	m.clearedFields[plugin.FieldLastStoppedAt] = struct{}{}
}

// LastStoppedAtCleared returns if the "last_stopped_at" field was cleared in this mutation.
func (m *PluginMutation) LastStoppedAtCleared() bool {
	_, ok := m.clearedFields[plugin.FieldLastStoppedAt]
	return ok
}

// ResetLastStoppedAt resets all changes to the "last_stopped_at" field.
func (m *PluginMutation) ResetLastStoppedAt() {
	m.last_stopped_at = nil
	delete(m.clearedFields, plugin.FieldLastStoppedAt)
}

// Where appends a list predicates to the PluginMutation builder.
func (m *PluginMutation) Where(ps ...predicate.Plugin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PluginMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PluginMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plugin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PluginMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PluginMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plugin).
func (m *PluginMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PluginMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, plugin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plugin.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, plugin.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, plugin.FieldName)
	}
	if m.version != nil {
		fields = append(fields, plugin.FieldVersion)
	}
	if m.description != nil {
		fields = append(fields, plugin.FieldDescription)
	}
	if m.bin_path != nil {
		fields = append(fields, plugin.FieldBinPath)
	}
	if m.protocol_version != nil {
		fields = append(fields, plugin.FieldProtocolVersion)
	}
	if m.magic_cookie_key != nil {
		fields = append(fields, plugin.FieldMagicCookieKey)
	}
	if m.magic_cookie_value != nil {
		fields = append(fields, plugin.FieldMagicCookieValue)
	}
	if m.dependencies != nil {
		fields = append(fields, plugin.FieldDependencies)
	}
	if m._config != nil {
		fields = append(fields, plugin.FieldConfig)
	}
	if m.enabled != nil {
		fields = append(fields, plugin.FieldEnabled)
	}
	if m.auto_start != nil {
		fields = append(fields, plugin.FieldAutoStart)
	}
	if m.status != nil {
		fields = append(fields, plugin.FieldStatus)
	}
	if m.last_error != nil {
		fields = append(fields, plugin.FieldLastError)
	}
	if m.last_started_at != nil {
		fields = append(fields, plugin.FieldLastStartedAt)
	}
	if m.last_stopped_at != nil {
		fields = append(fields, plugin.FieldLastStoppedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PluginMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plugin.FieldCreatedAt:
		return m.CreatedAt()
	case plugin.FieldUpdatedAt:
		return m.UpdatedAt()
	case plugin.FieldKey:
		return m.Key()
	case plugin.FieldName:
		return m.Name()
	case plugin.FieldVersion:
		return m.Version()
	case plugin.FieldDescription:
		return m.Description()
	case plugin.FieldBinPath:
		return m.BinPath()
	case plugin.FieldProtocolVersion:
		return m.ProtocolVersion()
	case plugin.FieldMagicCookieKey:
		return m.MagicCookieKey()
	case plugin.FieldMagicCookieValue:
		return m.MagicCookieValue()
	case plugin.FieldDependencies:
		return m.Dependencies()
	case plugin.FieldConfig:
		return m.Config()
	case plugin.FieldEnabled:
		return m.Enabled()
	case plugin.FieldAutoStart:
		return m.AutoStart()
	case plugin.FieldStatus:
		return m.Status()
	case plugin.FieldLastError:
		return m.LastError()
	case plugin.FieldLastStartedAt:
		return m.LastStartedAt()
	case plugin.FieldLastStoppedAt:
		return m.LastStoppedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PluginMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plugin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plugin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plugin.FieldKey:
		return m.OldKey(ctx)
	case plugin.FieldName:
		return m.OldName(ctx)
	case plugin.FieldVersion:
		return m.OldVersion(ctx)
	case plugin.FieldDescription:
		return m.OldDescription(ctx)
	case plugin.FieldBinPath:
		return m.OldBinPath(ctx)
	case plugin.FieldProtocolVersion:
		return m.OldProtocolVersion(ctx)
	case plugin.FieldMagicCookieKey:
		return m.OldMagicCookieKey(ctx)
	case plugin.FieldMagicCookieValue:
		return m.OldMagicCookieValue(ctx)
	case plugin.FieldDependencies:
		return m.OldDependencies(ctx)
	case plugin.FieldConfig:
		return m.OldConfig(ctx)
	case plugin.FieldEnabled:
		return m.OldEnabled(ctx)
	case plugin.FieldAutoStart:
		return m.OldAutoStart(ctx)
	case plugin.FieldStatus:
		return m.OldStatus(ctx)
	case plugin.FieldLastError:
		return m.OldLastError(ctx)
	case plugin.FieldLastStartedAt:
		return m.OldLastStartedAt(ctx)
	case plugin.FieldLastStoppedAt:
		return m.OldLastStoppedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Plugin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plugin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plugin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plugin.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case plugin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plugin.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case plugin.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case plugin.FieldBinPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinPath(v)
		return nil
	case plugin.FieldProtocolVersion:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocolVersion(v)
		return nil
	case plugin.FieldMagicCookieKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagicCookieKey(v)
		return nil
	case plugin.FieldMagicCookieValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagicCookieValue(v)
		return nil
	case plugin.FieldDependencies:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDependencies(v)
		return nil
	case plugin.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case plugin.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case plugin.FieldAutoStart:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoStart(v)
		return nil
	case plugin.FieldStatus:
		v, ok := value.(plugin.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case plugin.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	case plugin.FieldLastStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStartedAt(v)
		return nil
	case plugin.FieldLastStoppedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStoppedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Plugin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PluginMutation) AddedFields() []string {
	var fields []string
	if m.addprotocol_version != nil {
		fields = append(fields, plugin.FieldProtocolVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PluginMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plugin.FieldProtocolVersion:
		return m.AddedProtocolVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plugin.FieldProtocolVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProtocolVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Plugin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PluginMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plugin.FieldDescription) {
		fields = append(fields, plugin.FieldDescription)
	}
	if m.FieldCleared(plugin.FieldDependencies) {
		fields = append(fields, plugin.FieldDependencies)
	}
	if m.FieldCleared(plugin.FieldConfig) {
		fields = append(fields, plugin.FieldConfig)
	}
	if m.FieldCleared(plugin.FieldLastError) {
		fields = append(fields, plugin.FieldLastError)
	}
	if m.FieldCleared(plugin.FieldLastStartedAt) {
		fields = append(fields, plugin.FieldLastStartedAt)
	}
	if m.FieldCleared(plugin.FieldLastStoppedAt) {
		fields = append(fields, plugin.FieldLastStoppedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PluginMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PluginMutation) ClearField(name string) error {
	switch name {
	case plugin.FieldDescription:
		m.ClearDescription()
		return nil
	case plugin.FieldDependencies:
		m.ClearDependencies()
		return nil
	case plugin.FieldConfig:
		m.ClearConfig()
		return nil
	case plugin.FieldLastError:
		m.ClearLastError()
		return nil
	case plugin.FieldLastStartedAt:
		m.ClearLastStartedAt()
		return nil
	case plugin.FieldLastStoppedAt:
		m.ClearLastStoppedAt()
		return nil
	}
	return fmt.Errorf("unknown Plugin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PluginMutation) ResetField(name string) error {
	switch name {
	case plugin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plugin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plugin.FieldKey:
		m.ResetKey()
		return nil
	case plugin.FieldName:
		m.ResetName()
		return nil
	case plugin.FieldVersion:
		m.ResetVersion()
		return nil
	case plugin.FieldDescription:
		m.ResetDescription()
		return nil
	case plugin.FieldBinPath:
		m.ResetBinPath()
		return nil
	case plugin.FieldProtocolVersion:
		m.ResetProtocolVersion()
		return nil
	case plugin.FieldMagicCookieKey:
		m.ResetMagicCookieKey()
		return nil
	case plugin.FieldMagicCookieValue:
		m.ResetMagicCookieValue()
		return nil
	case plugin.FieldDependencies:
		m.ResetDependencies()
		return nil
	case plugin.FieldConfig:
		m.ResetConfig()
		return nil
	case plugin.FieldEnabled:
		m.ResetEnabled()
		return nil
	case plugin.FieldAutoStart:
		m.ResetAutoStart()
		return nil
	case plugin.FieldStatus:
		m.ResetStatus()
		return nil
	case plugin.FieldLastError:
		m.ResetLastError()
		return nil
	case plugin.FieldLastStartedAt:
		m.ResetLastStartedAt()
		return nil
	case plugin.FieldLastStoppedAt:
		m.ResetLastStoppedAt()
		return nil
	}
	return fmt.Errorf("unknown Plugin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PluginMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PluginMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PluginMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PluginMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PluginMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PluginMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PluginMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Plugin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PluginMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Plugin edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	title                    *string
	slug                     *string
	content                  *string
	md_content               *string
	html_content             *string
	content_type             *post.ContentType
	status                   *post.Status
	is_autogen_summary       *bool
	is_visible               *bool
	is_pin_to_top            *bool
	is_allow_comment         *bool
	is_visible_after_comment *bool
	is_visible_after_pay     *bool
	price                    *int
	addprice                 *int
	published_at             *time.Time
	view_count               *int
	addview_count            *int
	comment_count            *int
	addcomment_count         *int
	cover                    *string
	keywords                 *string
	copyright                *string
	author                   *string
	summary                  *string
	clearedFields            map[string]struct{}
	categories               map[int]struct{}
	removedcategories        map[int]struct{}
	clearedcategories        bool
	tags                     map[int]struct{}
	removedtags              map[int]struct{}
	clearedtags              bool
	done                     bool
	oldValue                 func(context.Context) (*Post, error)
	predicates               []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id int) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *PostMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSlug(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *PostMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[post.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *PostMutation) SlugCleared() bool {
	_, ok := m.clearedFields[post.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, post.FieldSlug)
}

// SetContent sets the "content" field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PostMutation) ResetContent() {
	m.content = nil
}

// SetMdContent sets the "md_content" field.
func (m *PostMutation) SetMdContent(s string) {
	m.md_content = &s
}

// MdContent returns the value of the "md_content" field in the mutation.
func (m *PostMutation) MdContent() (r string, exists bool) {
	v := m.md_content
	if v == nil {
		return
	}
	return *v, true
}

// OldMdContent returns the old "md_content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldMdContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMdContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMdContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMdContent: %w", err)
	}
	return oldValue.MdContent, nil
}

// ClearMdContent clears the value of the "md_content" field.
func (m *PostMutation) ClearMdContent() {
	m.md_content = nil
	m.clearedFields[post.FieldMdContent] = struct{}{}
}

// MdContentCleared returns if the "md_content" field was cleared in this mutation.
func (m *PostMutation) MdContentCleared() bool {
	_, ok := m.clearedFields[post.FieldMdContent]
	return ok
}

// ResetMdContent resets all changes to the "md_content" field.
func (m *PostMutation) ResetMdContent() {
	m.md_content = nil
	delete(m.clearedFields, post.FieldMdContent)
}

// SetHTMLContent sets the "html_content" field.
func (m *PostMutation) SetHTMLContent(s string) {
	m.html_content = &s
}

// HTMLContent returns the value of the "html_content" field in the mutation.
func (m *PostMutation) HTMLContent() (r string, exists bool) {
	v := m.html_content
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLContent returns the old "html_content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldHTMLContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLContent: %w", err)
	}
	return oldValue.HTMLContent, nil
}

// ClearHTMLContent clears the value of the "html_content" field.
func (m *PostMutation) ClearHTMLContent() {
	m.html_content = nil
	m.clearedFields[post.FieldHTMLContent] = struct{}{}
}

// HTMLContentCleared returns if the "html_content" field was cleared in this mutation.
func (m *PostMutation) HTMLContentCleared() bool {
	_, ok := m.clearedFields[post.FieldHTMLContent]
	return ok
}

// ResetHTMLContent resets all changes to the "html_content" field.
func (m *PostMutation) ResetHTMLContent() {
	m.html_content = nil
	delete(m.clearedFields, post.FieldHTMLContent)
}

// SetContentType sets the "content_type" field.
func (m *PostMutation) SetContentType(pt post.ContentType) {
	m.content_type = &pt
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *PostMutation) ContentType() (r post.ContentType, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContentType(ctx context.Context) (v post.ContentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ResetContentType resets all changes to the "content_type" field.
func (m *PostMutation) ResetContentType() {
	m.content_type = nil
}

// SetStatus sets the "status" field.
func (m *PostMutation) SetStatus(po post.Status) {
	m.status = &po
}

// Status returns the value of the "status" field in the mutation.
func (m *PostMutation) Status() (r post.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldStatus(ctx context.Context) (v post.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PostMutation) ResetStatus() {
	m.status = nil
}

// SetIsAutogenSummary sets the "is_autogen_summary" field.
func (m *PostMutation) SetIsAutogenSummary(b bool) {
	m.is_autogen_summary = &b
}

// IsAutogenSummary returns the value of the "is_autogen_summary" field in the mutation.
func (m *PostMutation) IsAutogenSummary() (r bool, exists bool) {
	v := m.is_autogen_summary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAutogenSummary returns the old "is_autogen_summary" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsAutogenSummary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAutogenSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAutogenSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAutogenSummary: %w", err)
	}
	return oldValue.IsAutogenSummary, nil
}

// ResetIsAutogenSummary resets all changes to the "is_autogen_summary" field.
func (m *PostMutation) ResetIsAutogenSummary() {
	m.is_autogen_summary = nil
}

// SetIsVisible sets the "is_visible" field.
func (m *PostMutation) SetIsVisible(b bool) {
	m.is_visible = &b
}

// IsVisible returns the value of the "is_visible" field in the mutation.
func (m *PostMutation) IsVisible() (r bool, exists bool) {
	v := m.is_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVisible returns the old "is_visible" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVisible: %w", err)
	}
	return oldValue.IsVisible, nil
}

// ResetIsVisible resets all changes to the "is_visible" field.
func (m *PostMutation) ResetIsVisible() {
	m.is_visible = nil
}

// SetIsPinToTop sets the "is_pin_to_top" field.
func (m *PostMutation) SetIsPinToTop(b bool) {
	m.is_pin_to_top = &b
}

// IsPinToTop returns the value of the "is_pin_to_top" field in the mutation.
func (m *PostMutation) IsPinToTop() (r bool, exists bool) {
	v := m.is_pin_to_top
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPinToTop returns the old "is_pin_to_top" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsPinToTop(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPinToTop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPinToTop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPinToTop: %w", err)
	}
	return oldValue.IsPinToTop, nil
}

// ResetIsPinToTop resets all changes to the "is_pin_to_top" field.
func (m *PostMutation) ResetIsPinToTop() {
	m.is_pin_to_top = nil
}

// SetIsAllowComment sets the "is_allow_comment" field.
func (m *PostMutation) SetIsAllowComment(b bool) {
	m.is_allow_comment = &b
}

// IsAllowComment returns the value of the "is_allow_comment" field in the mutation.
func (m *PostMutation) IsAllowComment() (r bool, exists bool) {
	v := m.is_allow_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAllowComment returns the old "is_allow_comment" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsAllowComment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAllowComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAllowComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAllowComment: %w", err)
	}
	return oldValue.IsAllowComment, nil
}

// ResetIsAllowComment resets all changes to the "is_allow_comment" field.
func (m *PostMutation) ResetIsAllowComment() {
	m.is_allow_comment = nil
}

// SetIsVisibleAfterComment sets the "is_visible_after_comment" field.
func (m *PostMutation) SetIsVisibleAfterComment(b bool) {
	m.is_visible_after_comment = &b
}

// IsVisibleAfterComment returns the value of the "is_visible_after_comment" field in the mutation.
func (m *PostMutation) IsVisibleAfterComment() (r bool, exists bool) {
	v := m.is_visible_after_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVisibleAfterComment returns the old "is_visible_after_comment" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsVisibleAfterComment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVisibleAfterComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVisibleAfterComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVisibleAfterComment: %w", err)
	}
	return oldValue.IsVisibleAfterComment, nil
}

// ResetIsVisibleAfterComment resets all changes to the "is_visible_after_comment" field.
func (m *PostMutation) ResetIsVisibleAfterComment() {
	m.is_visible_after_comment = nil
}

// SetIsVisibleAfterPay sets the "is_visible_after_pay" field.
func (m *PostMutation) SetIsVisibleAfterPay(b bool) {
	m.is_visible_after_pay = &b
}

// IsVisibleAfterPay returns the value of the "is_visible_after_pay" field in the mutation.
func (m *PostMutation) IsVisibleAfterPay() (r bool, exists bool) {
	v := m.is_visible_after_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVisibleAfterPay returns the old "is_visible_after_pay" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldIsVisibleAfterPay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVisibleAfterPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVisibleAfterPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVisibleAfterPay: %w", err)
	}
	return oldValue.IsVisibleAfterPay, nil
}

// ResetIsVisibleAfterPay resets all changes to the "is_visible_after_pay" field.
func (m *PostMutation) ResetIsVisibleAfterPay() {
	m.is_visible_after_pay = nil
}

// SetPrice sets the "price" field.
func (m *PostMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PostMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *PostMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PostMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *PostMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetPublishedAt sets the "published_at" field.
func (m *PostMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *PostMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPublishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *PostMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[post.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *PostMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *PostMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, post.FieldPublishedAt)
}

// SetViewCount sets the "view_count" field.
func (m *PostMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *PostMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *PostMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *PostMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *PostMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetCommentCount sets the "comment_count" field.
func (m *PostMutation) SetCommentCount(i int) {
	m.comment_count = &i
	m.addcomment_count = nil
}

// CommentCount returns the value of the "comment_count" field in the mutation.
func (m *PostMutation) CommentCount() (r int, exists bool) {
	v := m.comment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "comment_count" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCommentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds i to the "comment_count" field.
func (m *PostMutation) AddCommentCount(i int) {
	if m.addcomment_count != nil {
		*m.addcomment_count += i
	} else {
		m.addcomment_count = &i
	}
}

// AddedCommentCount returns the value that was added to the "comment_count" field in this mutation.
func (m *PostMutation) AddedCommentCount() (r int, exists bool) {
	v := m.addcomment_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentCount resets all changes to the "comment_count" field.
func (m *PostMutation) ResetCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
}

// SetCover sets the "cover" field.
func (m *PostMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *PostMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ClearCover clears the value of the "cover" field.
func (m *PostMutation) ClearCover() {
	m.cover = nil
	m.clearedFields[post.FieldCover] = struct{}{}
}

// CoverCleared returns if the "cover" field was cleared in this mutation.
func (m *PostMutation) CoverCleared() bool {
	_, ok := m.clearedFields[post.FieldCover]
	return ok
}

// ResetCover resets all changes to the "cover" field.
func (m *PostMutation) ResetCover() {
	m.cover = nil
	delete(m.clearedFields, post.FieldCover)
}

// SetKeywords sets the "keywords" field.
func (m *PostMutation) SetKeywords(s string) {
	m.keywords = &s
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *PostMutation) Keywords() (r string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldKeywords(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// ClearKeywords clears the value of the "keywords" field.
func (m *PostMutation) ClearKeywords() {
	m.keywords = nil
	m.clearedFields[post.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *PostMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[post.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *PostMutation) ResetKeywords() {
	m.keywords = nil
	delete(m.clearedFields, post.FieldKeywords)
}

// SetCopyright sets the "copyright" field.
func (m *PostMutation) SetCopyright(s string) {
	m.copyright = &s
}

// Copyright returns the value of the "copyright" field in the mutation.
func (m *PostMutation) Copyright() (r string, exists bool) {
	v := m.copyright
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyright returns the old "copyright" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCopyright(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyright is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyright requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyright: %w", err)
	}
	return oldValue.Copyright, nil
}

// ClearCopyright clears the value of the "copyright" field.
func (m *PostMutation) ClearCopyright() {
	m.copyright = nil
	m.clearedFields[post.FieldCopyright] = struct{}{}
}

// CopyrightCleared returns if the "copyright" field was cleared in this mutation.
func (m *PostMutation) CopyrightCleared() bool {
	_, ok := m.clearedFields[post.FieldCopyright]
	return ok
}

// ResetCopyright resets all changes to the "copyright" field.
func (m *PostMutation) ResetCopyright() {
	m.copyright = nil
	delete(m.clearedFields, post.FieldCopyright)
}

// SetAuthor sets the "author" field.
func (m *PostMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *PostMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *PostMutation) ResetAuthor() {
	m.author = nil
}

// SetSummary sets the "summary" field.
func (m *PostMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *PostMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *PostMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[post.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *PostMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[post.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *PostMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, post.FieldSummary)
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *PostMutation) AddCategoryIDs(ids ...int) {
	if m.categories == nil {
		m.categories = make(map[int]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *PostMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *PostMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *PostMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *PostMutation) RemovedCategoriesIDs() (ids []int) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *PostMutation) CategoriesIDs() (ids []int) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *PostMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *PostMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *PostMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *PostMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *PostMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *PostMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *PostMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *PostMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, post.FieldSlug)
	}
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m.md_content != nil {
		fields = append(fields, post.FieldMdContent)
	}
	if m.html_content != nil {
		fields = append(fields, post.FieldHTMLContent)
	}
	if m.content_type != nil {
		fields = append(fields, post.FieldContentType)
	}
	if m.status != nil {
		fields = append(fields, post.FieldStatus)
	}
	if m.is_autogen_summary != nil {
		fields = append(fields, post.FieldIsAutogenSummary)
	}
	if m.is_visible != nil {
		fields = append(fields, post.FieldIsVisible)
	}
	if m.is_pin_to_top != nil {
		fields = append(fields, post.FieldIsPinToTop)
	}
	if m.is_allow_comment != nil {
		fields = append(fields, post.FieldIsAllowComment)
	}
	if m.is_visible_after_comment != nil {
		fields = append(fields, post.FieldIsVisibleAfterComment)
	}
	if m.is_visible_after_pay != nil {
		fields = append(fields, post.FieldIsVisibleAfterPay)
	}
	if m.price != nil {
		fields = append(fields, post.FieldPrice)
	}
	if m.published_at != nil {
		fields = append(fields, post.FieldPublishedAt)
	}
	if m.view_count != nil {
		fields = append(fields, post.FieldViewCount)
	}
	if m.comment_count != nil {
		fields = append(fields, post.FieldCommentCount)
	}
	if m.cover != nil {
		fields = append(fields, post.FieldCover)
	}
	if m.keywords != nil {
		fields = append(fields, post.FieldKeywords)
	}
	if m.copyright != nil {
		fields = append(fields, post.FieldCopyright)
	}
	if m.author != nil {
		fields = append(fields, post.FieldAuthor)
	}
	if m.summary != nil {
		fields = append(fields, post.FieldSummary)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldTitle:
		return m.Title()
	case post.FieldSlug:
		return m.Slug()
	case post.FieldContent:
		return m.Content()
	case post.FieldMdContent:
		return m.MdContent()
	case post.FieldHTMLContent:
		return m.HTMLContent()
	case post.FieldContentType:
		return m.ContentType()
	case post.FieldStatus:
		return m.Status()
	case post.FieldIsAutogenSummary:
		return m.IsAutogenSummary()
	case post.FieldIsVisible:
		return m.IsVisible()
	case post.FieldIsPinToTop:
		return m.IsPinToTop()
	case post.FieldIsAllowComment:
		return m.IsAllowComment()
	case post.FieldIsVisibleAfterComment:
		return m.IsVisibleAfterComment()
	case post.FieldIsVisibleAfterPay:
		return m.IsVisibleAfterPay()
	case post.FieldPrice:
		return m.Price()
	case post.FieldPublishedAt:
		return m.PublishedAt()
	case post.FieldViewCount:
		return m.ViewCount()
	case post.FieldCommentCount:
		return m.CommentCount()
	case post.FieldCover:
		return m.Cover()
	case post.FieldKeywords:
		return m.Keywords()
	case post.FieldCopyright:
		return m.Copyright()
	case post.FieldAuthor:
		return m.Author()
	case post.FieldSummary:
		return m.Summary()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldSlug:
		return m.OldSlug(ctx)
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldMdContent:
		return m.OldMdContent(ctx)
	case post.FieldHTMLContent:
		return m.OldHTMLContent(ctx)
	case post.FieldContentType:
		return m.OldContentType(ctx)
	case post.FieldStatus:
		return m.OldStatus(ctx)
	case post.FieldIsAutogenSummary:
		return m.OldIsAutogenSummary(ctx)
	case post.FieldIsVisible:
		return m.OldIsVisible(ctx)
	case post.FieldIsPinToTop:
		return m.OldIsPinToTop(ctx)
	case post.FieldIsAllowComment:
		return m.OldIsAllowComment(ctx)
	case post.FieldIsVisibleAfterComment:
		return m.OldIsVisibleAfterComment(ctx)
	case post.FieldIsVisibleAfterPay:
		return m.OldIsVisibleAfterPay(ctx)
	case post.FieldPrice:
		return m.OldPrice(ctx)
	case post.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case post.FieldViewCount:
		return m.OldViewCount(ctx)
	case post.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case post.FieldCover:
		return m.OldCover(ctx)
	case post.FieldKeywords:
		return m.OldKeywords(ctx)
	case post.FieldCopyright:
		return m.OldCopyright(ctx)
	case post.FieldAuthor:
		return m.OldAuthor(ctx)
	case post.FieldSummary:
		return m.OldSummary(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldMdContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMdContent(v)
		return nil
	case post.FieldHTMLContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLContent(v)
		return nil
	case post.FieldContentType:
		v, ok := value.(post.ContentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case post.FieldStatus:
		v, ok := value.(post.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case post.FieldIsAutogenSummary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAutogenSummary(v)
		return nil
	case post.FieldIsVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVisible(v)
		return nil
	case post.FieldIsPinToTop:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPinToTop(v)
		return nil
	case post.FieldIsAllowComment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAllowComment(v)
		return nil
	case post.FieldIsVisibleAfterComment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVisibleAfterComment(v)
		return nil
	case post.FieldIsVisibleAfterPay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVisibleAfterPay(v)
		return nil
	case post.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case post.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case post.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case post.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case post.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	case post.FieldKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case post.FieldCopyright:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyright(v)
		return nil
	case post.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case post.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, post.FieldPrice)
	}
	if m.addview_count != nil {
		fields = append(fields, post.FieldViewCount)
	}
	if m.addcomment_count != nil {
		fields = append(fields, post.FieldCommentCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case post.FieldPrice:
		return m.AddedPrice()
	case post.FieldViewCount:
		return m.AddedViewCount()
	case post.FieldCommentCount:
		return m.AddedCommentCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case post.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case post.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case post.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldSlug) {
		fields = append(fields, post.FieldSlug)
	}
	if m.FieldCleared(post.FieldMdContent) {
		fields = append(fields, post.FieldMdContent)
	}
	if m.FieldCleared(post.FieldHTMLContent) {
		fields = append(fields, post.FieldHTMLContent)
	}
	if m.FieldCleared(post.FieldPublishedAt) {
		fields = append(fields, post.FieldPublishedAt)
	}
	if m.FieldCleared(post.FieldCover) {
		fields = append(fields, post.FieldCover)
	}
	if m.FieldCleared(post.FieldKeywords) {
		fields = append(fields, post.FieldKeywords)
	}
	if m.FieldCleared(post.FieldCopyright) {
		fields = append(fields, post.FieldCopyright)
	}
	if m.FieldCleared(post.FieldSummary) {
		fields = append(fields, post.FieldSummary)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldSlug:
		m.ClearSlug()
		return nil
	case post.FieldMdContent:
		m.ClearMdContent()
		return nil
	case post.FieldHTMLContent:
		m.ClearHTMLContent()
		return nil
	case post.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	case post.FieldCover:
		m.ClearCover()
		return nil
	case post.FieldKeywords:
		m.ClearKeywords()
		return nil
	case post.FieldCopyright:
		m.ClearCopyright()
		return nil
	case post.FieldSummary:
		m.ClearSummary()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldSlug:
		m.ResetSlug()
		return nil
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldMdContent:
		m.ResetMdContent()
		return nil
	case post.FieldHTMLContent:
		m.ResetHTMLContent()
		return nil
	case post.FieldContentType:
		m.ResetContentType()
		return nil
	case post.FieldStatus:
		m.ResetStatus()
		return nil
	case post.FieldIsAutogenSummary:
		m.ResetIsAutogenSummary()
		return nil
	case post.FieldIsVisible:
		m.ResetIsVisible()
		return nil
	case post.FieldIsPinToTop:
		m.ResetIsPinToTop()
		return nil
	case post.FieldIsAllowComment:
		m.ResetIsAllowComment()
		return nil
	case post.FieldIsVisibleAfterComment:
		m.ResetIsVisibleAfterComment()
		return nil
	case post.FieldIsVisibleAfterPay:
		m.ResetIsVisibleAfterPay()
		return nil
	case post.FieldPrice:
		m.ResetPrice()
		return nil
	case post.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case post.FieldViewCount:
		m.ResetViewCount()
		return nil
	case post.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case post.FieldCover:
		m.ResetCover()
		return nil
	case post.FieldKeywords:
		m.ResetKeywords()
		return nil
	case post.FieldCopyright:
		m.ResetCopyright()
		return nil
	case post.FieldAuthor:
		m.ResetAuthor()
		return nil
	case post.FieldSummary:
		m.ResetSummary()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.categories != nil {
		edges = append(edges, post.EdgeCategories)
	}
	if m.tags != nil {
		edges = append(edges, post.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcategories != nil {
		edges = append(edges, post.EdgeCategories)
	}
	if m.removedtags != nil {
		edges = append(edges, post.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcategories {
		edges = append(edges, post.EdgeCategories)
	}
	if m.clearedtags {
		edges = append(edges, post.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeCategories:
		return m.clearedcategories
	case post.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeCategories:
		m.ResetCategories()
		return nil
	case post.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	description       *string
	short_description *string
	sku               *string
	price             *int
	addprice          *int
	original_price    *int
	addoriginal_price *int
	cost_price        *int
	addcost_price     *int
	stock             *int
	addstock          *int
	min_stock         *int
	addmin_stock      *int
	sales             *int
	addsales          *int
	category_id       *int
	addcategory_id    *int
	brand             *string
	unit              *string
	weight            *float64
	addweight         *float64
	volume            *float64
	addvolume         *float64
	images            *[]string
	appendimages      []string
	attributes        *map[string]interface{}
	tags              *[]string
	appendtags        []string
	active            *bool
	featured          *bool
	digital           *bool
	meta_title        *string
	meta_description  *string
	meta_keywords     *string
	sort_order        *int
	addsort_order     *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Product, error)
	predicates        []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[product.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, product.FieldDescription)
}

// SetShortDescription sets the "short_description" field.
func (m *ProductMutation) SetShortDescription(s string) {
	m.short_description = &s
}

// ShortDescription returns the value of the "short_description" field in the mutation.
func (m *ProductMutation) ShortDescription() (r string, exists bool) {
	v := m.short_description
	if v == nil {
		return
	}
	return *v, true
}

// OldShortDescription returns the old "short_description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldShortDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortDescription: %w", err)
	}
	return oldValue.ShortDescription, nil
}

// ClearShortDescription clears the value of the "short_description" field.
func (m *ProductMutation) ClearShortDescription() {
	m.short_description = nil
	m.clearedFields[product.FieldShortDescription] = struct{}{}
}

// ShortDescriptionCleared returns if the "short_description" field was cleared in this mutation.
func (m *ProductMutation) ShortDescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldShortDescription]
	return ok
}

// ResetShortDescription resets all changes to the "short_description" field.
func (m *ProductMutation) ResetShortDescription() {
	m.short_description = nil
	delete(m.clearedFields, product.FieldShortDescription)
}

// SetSku sets the "sku" field.
func (m *ProductMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *ProductMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *ProductMutation) ResetSku() {
	m.sku = nil
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *ProductMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetOriginalPrice sets the "original_price" field.
func (m *ProductMutation) SetOriginalPrice(i int) {
	m.original_price = &i
	m.addoriginal_price = nil
}

// OriginalPrice returns the value of the "original_price" field in the mutation.
func (m *ProductMutation) OriginalPrice() (r int, exists bool) {
	v := m.original_price
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalPrice returns the old "original_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldOriginalPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalPrice: %w", err)
	}
	return oldValue.OriginalPrice, nil
}

// AddOriginalPrice adds i to the "original_price" field.
func (m *ProductMutation) AddOriginalPrice(i int) {
	if m.addoriginal_price != nil {
		*m.addoriginal_price += i
	} else {
		m.addoriginal_price = &i
	}
}

// AddedOriginalPrice returns the value that was added to the "original_price" field in this mutation.
func (m *ProductMutation) AddedOriginalPrice() (r int, exists bool) {
	v := m.addoriginal_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearOriginalPrice clears the value of the "original_price" field.
func (m *ProductMutation) ClearOriginalPrice() {
	m.original_price = nil
	m.addoriginal_price = nil
	m.clearedFields[product.FieldOriginalPrice] = struct{}{}
}

// OriginalPriceCleared returns if the "original_price" field was cleared in this mutation.
func (m *ProductMutation) OriginalPriceCleared() bool {
	_, ok := m.clearedFields[product.FieldOriginalPrice]
	return ok
}

// ResetOriginalPrice resets all changes to the "original_price" field.
func (m *ProductMutation) ResetOriginalPrice() {
	m.original_price = nil
	m.addoriginal_price = nil
	delete(m.clearedFields, product.FieldOriginalPrice)
}

// SetCostPrice sets the "cost_price" field.
func (m *ProductMutation) SetCostPrice(i int) {
	m.cost_price = &i
	m.addcost_price = nil
}

// CostPrice returns the value of the "cost_price" field in the mutation.
func (m *ProductMutation) CostPrice() (r int, exists bool) {
	v := m.cost_price
	if v == nil {
		return
	}
	return *v, true
}

// OldCostPrice returns the old "cost_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCostPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostPrice: %w", err)
	}
	return oldValue.CostPrice, nil
}

// AddCostPrice adds i to the "cost_price" field.
func (m *ProductMutation) AddCostPrice(i int) {
	if m.addcost_price != nil {
		*m.addcost_price += i
	} else {
		m.addcost_price = &i
	}
}

// AddedCostPrice returns the value that was added to the "cost_price" field in this mutation.
func (m *ProductMutation) AddedCostPrice() (r int, exists bool) {
	v := m.addcost_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearCostPrice clears the value of the "cost_price" field.
func (m *ProductMutation) ClearCostPrice() {
	m.cost_price = nil
	m.addcost_price = nil
	m.clearedFields[product.FieldCostPrice] = struct{}{}
}

// CostPriceCleared returns if the "cost_price" field was cleared in this mutation.
func (m *ProductMutation) CostPriceCleared() bool {
	_, ok := m.clearedFields[product.FieldCostPrice]
	return ok
}

// ResetCostPrice resets all changes to the "cost_price" field.
func (m *ProductMutation) ResetCostPrice() {
	m.cost_price = nil
	m.addcost_price = nil
	delete(m.clearedFields, product.FieldCostPrice)
}

// SetStock sets the "stock" field.
func (m *ProductMutation) SetStock(i int) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ProductMutation) Stock() (r int, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *ProductMutation) AddStock(i int) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ProductMutation) AddedStock() (r int, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *ProductMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetMinStock sets the "min_stock" field.
func (m *ProductMutation) SetMinStock(i int) {
	m.min_stock = &i
	m.addmin_stock = nil
}

// MinStock returns the value of the "min_stock" field in the mutation.
func (m *ProductMutation) MinStock() (r int, exists bool) {
	v := m.min_stock
	if v == nil {
		return
	}
	return *v, true
}

// OldMinStock returns the old "min_stock" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMinStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinStock: %w", err)
	}
	return oldValue.MinStock, nil
}

// AddMinStock adds i to the "min_stock" field.
func (m *ProductMutation) AddMinStock(i int) {
	if m.addmin_stock != nil {
		*m.addmin_stock += i
	} else {
		m.addmin_stock = &i
	}
}

// AddedMinStock returns the value that was added to the "min_stock" field in this mutation.
func (m *ProductMutation) AddedMinStock() (r int, exists bool) {
	v := m.addmin_stock
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinStock resets all changes to the "min_stock" field.
func (m *ProductMutation) ResetMinStock() {
	m.min_stock = nil
	m.addmin_stock = nil
}

// SetSales sets the "sales" field.
func (m *ProductMutation) SetSales(i int) {
	m.sales = &i
	m.addsales = nil
}

// Sales returns the value of the "sales" field in the mutation.
func (m *ProductMutation) Sales() (r int, exists bool) {
	v := m.sales
	if v == nil {
		return
	}
	return *v, true
}

// OldSales returns the old "sales" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSales(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSales is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSales requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSales: %w", err)
	}
	return oldValue.Sales, nil
}

// AddSales adds i to the "sales" field.
func (m *ProductMutation) AddSales(i int) {
	if m.addsales != nil {
		*m.addsales += i
	} else {
		m.addsales = &i
	}
}

// AddedSales returns the value that was added to the "sales" field in this mutation.
func (m *ProductMutation) AddedSales() (r int, exists bool) {
	v := m.addsales
	if v == nil {
		return
	}
	return *v, true
}

// ResetSales resets all changes to the "sales" field.
func (m *ProductMutation) ResetSales() {
	m.sales = nil
	m.addsales = nil
}

// SetCategoryID sets the "category_id" field.
func (m *ProductMutation) SetCategoryID(i int) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *ProductMutation) CategoryID() (r int, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *ProductMutation) AddCategoryID(i int) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *ProductMutation) AddedCategoryID() (r int, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *ProductMutation) ClearCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
	m.clearedFields[product.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *ProductMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[product.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *ProductMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
	delete(m.clearedFields, product.FieldCategoryID)
}

// SetBrand sets the "brand" field.
func (m *ProductMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the value of the "brand" field in the mutation.
func (m *ProductMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ClearBrand clears the value of the "brand" field.
func (m *ProductMutation) ClearBrand() {
	m.brand = nil
	m.clearedFields[product.FieldBrand] = struct{}{}
}

// BrandCleared returns if the "brand" field was cleared in this mutation.
func (m *ProductMutation) BrandCleared() bool {
	_, ok := m.clearedFields[product.FieldBrand]
	return ok
}

// ResetBrand resets all changes to the "brand" field.
func (m *ProductMutation) ResetBrand() {
	m.brand = nil
	delete(m.clearedFields, product.FieldBrand)
}

// SetUnit sets the "unit" field.
func (m *ProductMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *ProductMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *ProductMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[product.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *ProductMutation) UnitCleared() bool {
	_, ok := m.clearedFields[product.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *ProductMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, product.FieldUnit)
}

// SetWeight sets the "weight" field.
func (m *ProductMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *ProductMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *ProductMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *ProductMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *ProductMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[product.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *ProductMutation) WeightCleared() bool {
	_, ok := m.clearedFields[product.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *ProductMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, product.FieldWeight)
}

// SetVolume sets the "volume" field.
func (m *ProductMutation) SetVolume(f float64) {
	m.volume = &f
	m.addvolume = nil
}

// Volume returns the value of the "volume" field in the mutation.
func (m *ProductMutation) Volume() (r float64, exists bool) {
	v := m.volume
	if v == nil {
		return
	}
	return *v, true
}

// OldVolume returns the old "volume" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldVolume(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolume: %w", err)
	}
	return oldValue.Volume, nil
}

// AddVolume adds f to the "volume" field.
func (m *ProductMutation) AddVolume(f float64) {
	if m.addvolume != nil {
		*m.addvolume += f
	} else {
		m.addvolume = &f
	}
}

// AddedVolume returns the value that was added to the "volume" field in this mutation.
func (m *ProductMutation) AddedVolume() (r float64, exists bool) {
	v := m.addvolume
	if v == nil {
		return
	}
	return *v, true
}

// ClearVolume clears the value of the "volume" field.
func (m *ProductMutation) ClearVolume() {
	m.volume = nil
	m.addvolume = nil
	m.clearedFields[product.FieldVolume] = struct{}{}
}

// VolumeCleared returns if the "volume" field was cleared in this mutation.
func (m *ProductMutation) VolumeCleared() bool {
	_, ok := m.clearedFields[product.FieldVolume]
	return ok
}

// ResetVolume resets all changes to the "volume" field.
func (m *ProductMutation) ResetVolume() {
	m.volume = nil
	m.addvolume = nil
	delete(m.clearedFields, product.FieldVolume)
}

// SetImages sets the "images" field.
func (m *ProductMutation) SetImages(s []string) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *ProductMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *ProductMutation) AppendImages(s []string) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *ProductMutation) AppendedImages() ([]string, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *ProductMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[product.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *ProductMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[product.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *ProductMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, product.FieldImages)
}

// SetAttributes sets the "attributes" field.
func (m *ProductMutation) SetAttributes(value map[string]interface{}) {
	m.attributes = &value
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *ProductMutation) Attributes() (r map[string]interface{}, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAttributes(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *ProductMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[product.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *ProductMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[product.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *ProductMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, product.FieldAttributes)
}

// SetTags sets the "tags" field.
func (m *ProductMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ProductMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *ProductMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *ProductMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *ProductMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[product.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *ProductMutation) TagsCleared() bool {
	_, ok := m.clearedFields[product.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *ProductMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, product.FieldTags)
}

// SetActive sets the "active" field.
func (m *ProductMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ProductMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *ProductMutation) ResetActive() {
	m.active = nil
}

// SetFeatured sets the "featured" field.
func (m *ProductMutation) SetFeatured(b bool) {
	m.featured = &b
}

// Featured returns the value of the "featured" field in the mutation.
func (m *ProductMutation) Featured() (r bool, exists bool) {
	v := m.featured
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatured returns the old "featured" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldFeatured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatured: %w", err)
	}
	return oldValue.Featured, nil
}

// ResetFeatured resets all changes to the "featured" field.
func (m *ProductMutation) ResetFeatured() {
	m.featured = nil
}

// SetDigital sets the "digital" field.
func (m *ProductMutation) SetDigital(b bool) {
	m.digital = &b
}

// Digital returns the value of the "digital" field in the mutation.
func (m *ProductMutation) Digital() (r bool, exists bool) {
	v := m.digital
	if v == nil {
		return
	}
	return *v, true
}

// OldDigital returns the old "digital" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDigital(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigital is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigital requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigital: %w", err)
	}
	return oldValue.Digital, nil
}

// ResetDigital resets all changes to the "digital" field.
func (m *ProductMutation) ResetDigital() {
	m.digital = nil
}

// SetMetaTitle sets the "meta_title" field.
func (m *ProductMutation) SetMetaTitle(s string) {
	m.meta_title = &s
}

// MetaTitle returns the value of the "meta_title" field in the mutation.
func (m *ProductMutation) MetaTitle() (r string, exists bool) {
	v := m.meta_title
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaTitle returns the old "meta_title" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMetaTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaTitle: %w", err)
	}
	return oldValue.MetaTitle, nil
}

// ClearMetaTitle clears the value of the "meta_title" field.
func (m *ProductMutation) ClearMetaTitle() {
	m.meta_title = nil
	m.clearedFields[product.FieldMetaTitle] = struct{}{}
}

// MetaTitleCleared returns if the "meta_title" field was cleared in this mutation.
func (m *ProductMutation) MetaTitleCleared() bool {
	_, ok := m.clearedFields[product.FieldMetaTitle]
	return ok
}

// ResetMetaTitle resets all changes to the "meta_title" field.
func (m *ProductMutation) ResetMetaTitle() {
	m.meta_title = nil
	delete(m.clearedFields, product.FieldMetaTitle)
}

// SetMetaDescription sets the "meta_description" field.
func (m *ProductMutation) SetMetaDescription(s string) {
	m.meta_description = &s
}

// MetaDescription returns the value of the "meta_description" field in the mutation.
func (m *ProductMutation) MetaDescription() (r string, exists bool) {
	v := m.meta_description
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaDescription returns the old "meta_description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMetaDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaDescription: %w", err)
	}
	return oldValue.MetaDescription, nil
}

// ClearMetaDescription clears the value of the "meta_description" field.
func (m *ProductMutation) ClearMetaDescription() {
	m.meta_description = nil
	m.clearedFields[product.FieldMetaDescription] = struct{}{}
}

// MetaDescriptionCleared returns if the "meta_description" field was cleared in this mutation.
func (m *ProductMutation) MetaDescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldMetaDescription]
	return ok
}

// ResetMetaDescription resets all changes to the "meta_description" field.
func (m *ProductMutation) ResetMetaDescription() {
	m.meta_description = nil
	delete(m.clearedFields, product.FieldMetaDescription)
}

// SetMetaKeywords sets the "meta_keywords" field.
func (m *ProductMutation) SetMetaKeywords(s string) {
	m.meta_keywords = &s
}

// MetaKeywords returns the value of the "meta_keywords" field in the mutation.
func (m *ProductMutation) MetaKeywords() (r string, exists bool) {
	v := m.meta_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaKeywords returns the old "meta_keywords" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMetaKeywords(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaKeywords: %w", err)
	}
	return oldValue.MetaKeywords, nil
}

// ClearMetaKeywords clears the value of the "meta_keywords" field.
func (m *ProductMutation) ClearMetaKeywords() {
	m.meta_keywords = nil
	m.clearedFields[product.FieldMetaKeywords] = struct{}{}
}

// MetaKeywordsCleared returns if the "meta_keywords" field was cleared in this mutation.
func (m *ProductMutation) MetaKeywordsCleared() bool {
	_, ok := m.clearedFields[product.FieldMetaKeywords]
	return ok
}

// ResetMetaKeywords resets all changes to the "meta_keywords" field.
func (m *ProductMutation) ResetMetaKeywords() {
	m.meta_keywords = nil
	delete(m.clearedFields, product.FieldMetaKeywords)
}

// SetSortOrder sets the "sort_order" field.
func (m *ProductMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ProductMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ProductMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ProductMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ProductMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.short_description != nil {
		fields = append(fields, product.FieldShortDescription)
	}
	if m.sku != nil {
		fields = append(fields, product.FieldSku)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.original_price != nil {
		fields = append(fields, product.FieldOriginalPrice)
	}
	if m.cost_price != nil {
		fields = append(fields, product.FieldCostPrice)
	}
	if m.stock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.min_stock != nil {
		fields = append(fields, product.FieldMinStock)
	}
	if m.sales != nil {
		fields = append(fields, product.FieldSales)
	}
	if m.category_id != nil {
		fields = append(fields, product.FieldCategoryID)
	}
	if m.brand != nil {
		fields = append(fields, product.FieldBrand)
	}
	if m.unit != nil {
		fields = append(fields, product.FieldUnit)
	}
	if m.weight != nil {
		fields = append(fields, product.FieldWeight)
	}
	if m.volume != nil {
		fields = append(fields, product.FieldVolume)
	}
	if m.images != nil {
		fields = append(fields, product.FieldImages)
	}
	if m.attributes != nil {
		fields = append(fields, product.FieldAttributes)
	}
	if m.tags != nil {
		fields = append(fields, product.FieldTags)
	}
	if m.active != nil {
		fields = append(fields, product.FieldActive)
	}
	if m.featured != nil {
		fields = append(fields, product.FieldFeatured)
	}
	if m.digital != nil {
		fields = append(fields, product.FieldDigital)
	}
	if m.meta_title != nil {
		fields = append(fields, product.FieldMetaTitle)
	}
	if m.meta_description != nil {
		fields = append(fields, product.FieldMetaDescription)
	}
	if m.meta_keywords != nil {
		fields = append(fields, product.FieldMetaKeywords)
	}
	if m.sort_order != nil {
		fields = append(fields, product.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldName:
		return m.Name()
	case product.FieldDescription:
		return m.Description()
	case product.FieldShortDescription:
		return m.ShortDescription()
	case product.FieldSku:
		return m.Sku()
	case product.FieldPrice:
		return m.Price()
	case product.FieldOriginalPrice:
		return m.OriginalPrice()
	case product.FieldCostPrice:
		return m.CostPrice()
	case product.FieldStock:
		return m.Stock()
	case product.FieldMinStock:
		return m.MinStock()
	case product.FieldSales:
		return m.Sales()
	case product.FieldCategoryID:
		return m.CategoryID()
	case product.FieldBrand:
		return m.Brand()
	case product.FieldUnit:
		return m.Unit()
	case product.FieldWeight:
		return m.Weight()
	case product.FieldVolume:
		return m.Volume()
	case product.FieldImages:
		return m.Images()
	case product.FieldAttributes:
		return m.Attributes()
	case product.FieldTags:
		return m.Tags()
	case product.FieldActive:
		return m.Active()
	case product.FieldFeatured:
		return m.Featured()
	case product.FieldDigital:
		return m.Digital()
	case product.FieldMetaTitle:
		return m.MetaTitle()
	case product.FieldMetaDescription:
		return m.MetaDescription()
	case product.FieldMetaKeywords:
		return m.MetaKeywords()
	case product.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldShortDescription:
		return m.OldShortDescription(ctx)
	case product.FieldSku:
		return m.OldSku(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldOriginalPrice:
		return m.OldOriginalPrice(ctx)
	case product.FieldCostPrice:
		return m.OldCostPrice(ctx)
	case product.FieldStock:
		return m.OldStock(ctx)
	case product.FieldMinStock:
		return m.OldMinStock(ctx)
	case product.FieldSales:
		return m.OldSales(ctx)
	case product.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case product.FieldBrand:
		return m.OldBrand(ctx)
	case product.FieldUnit:
		return m.OldUnit(ctx)
	case product.FieldWeight:
		return m.OldWeight(ctx)
	case product.FieldVolume:
		return m.OldVolume(ctx)
	case product.FieldImages:
		return m.OldImages(ctx)
	case product.FieldAttributes:
		return m.OldAttributes(ctx)
	case product.FieldTags:
		return m.OldTags(ctx)
	case product.FieldActive:
		return m.OldActive(ctx)
	case product.FieldFeatured:
		return m.OldFeatured(ctx)
	case product.FieldDigital:
		return m.OldDigital(ctx)
	case product.FieldMetaTitle:
		return m.OldMetaTitle(ctx)
	case product.FieldMetaDescription:
		return m.OldMetaDescription(ctx)
	case product.FieldMetaKeywords:
		return m.OldMetaKeywords(ctx)
	case product.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldShortDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortDescription(v)
		return nil
	case product.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldOriginalPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalPrice(v)
		return nil
	case product.FieldCostPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostPrice(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case product.FieldMinStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinStock(v)
		return nil
	case product.FieldSales:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSales(v)
		return nil
	case product.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case product.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case product.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case product.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case product.FieldVolume:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolume(v)
		return nil
	case product.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case product.FieldAttributes:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case product.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case product.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case product.FieldFeatured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatured(v)
		return nil
	case product.FieldDigital:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigital(v)
		return nil
	case product.FieldMetaTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaTitle(v)
		return nil
	case product.FieldMetaDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaDescription(v)
		return nil
	case product.FieldMetaKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaKeywords(v)
		return nil
	case product.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.addoriginal_price != nil {
		fields = append(fields, product.FieldOriginalPrice)
	}
	if m.addcost_price != nil {
		fields = append(fields, product.FieldCostPrice)
	}
	if m.addstock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.addmin_stock != nil {
		fields = append(fields, product.FieldMinStock)
	}
	if m.addsales != nil {
		fields = append(fields, product.FieldSales)
	}
	if m.addcategory_id != nil {
		fields = append(fields, product.FieldCategoryID)
	}
	if m.addweight != nil {
		fields = append(fields, product.FieldWeight)
	}
	if m.addvolume != nil {
		fields = append(fields, product.FieldVolume)
	}
	if m.addsort_order != nil {
		fields = append(fields, product.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldPrice:
		return m.AddedPrice()
	case product.FieldOriginalPrice:
		return m.AddedOriginalPrice()
	case product.FieldCostPrice:
		return m.AddedCostPrice()
	case product.FieldStock:
		return m.AddedStock()
	case product.FieldMinStock:
		return m.AddedMinStock()
	case product.FieldSales:
		return m.AddedSales()
	case product.FieldCategoryID:
		return m.AddedCategoryID()
	case product.FieldWeight:
		return m.AddedWeight()
	case product.FieldVolume:
		return m.AddedVolume()
	case product.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case product.FieldOriginalPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginalPrice(v)
		return nil
	case product.FieldCostPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCostPrice(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case product.FieldMinStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinStock(v)
		return nil
	case product.FieldSales:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSales(v)
		return nil
	case product.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	case product.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case product.FieldVolume:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolume(v)
		return nil
	case product.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldDescription) {
		fields = append(fields, product.FieldDescription)
	}
	if m.FieldCleared(product.FieldShortDescription) {
		fields = append(fields, product.FieldShortDescription)
	}
	if m.FieldCleared(product.FieldOriginalPrice) {
		fields = append(fields, product.FieldOriginalPrice)
	}
	if m.FieldCleared(product.FieldCostPrice) {
		fields = append(fields, product.FieldCostPrice)
	}
	if m.FieldCleared(product.FieldCategoryID) {
		fields = append(fields, product.FieldCategoryID)
	}
	if m.FieldCleared(product.FieldBrand) {
		fields = append(fields, product.FieldBrand)
	}
	if m.FieldCleared(product.FieldUnit) {
		fields = append(fields, product.FieldUnit)
	}
	if m.FieldCleared(product.FieldWeight) {
		fields = append(fields, product.FieldWeight)
	}
	if m.FieldCleared(product.FieldVolume) {
		fields = append(fields, product.FieldVolume)
	}
	if m.FieldCleared(product.FieldImages) {
		fields = append(fields, product.FieldImages)
	}
	if m.FieldCleared(product.FieldAttributes) {
		fields = append(fields, product.FieldAttributes)
	}
	if m.FieldCleared(product.FieldTags) {
		fields = append(fields, product.FieldTags)
	}
	if m.FieldCleared(product.FieldMetaTitle) {
		fields = append(fields, product.FieldMetaTitle)
	}
	if m.FieldCleared(product.FieldMetaDescription) {
		fields = append(fields, product.FieldMetaDescription)
	}
	if m.FieldCleared(product.FieldMetaKeywords) {
		fields = append(fields, product.FieldMetaKeywords)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldDescription:
		m.ClearDescription()
		return nil
	case product.FieldShortDescription:
		m.ClearShortDescription()
		return nil
	case product.FieldOriginalPrice:
		m.ClearOriginalPrice()
		return nil
	case product.FieldCostPrice:
		m.ClearCostPrice()
		return nil
	case product.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case product.FieldBrand:
		m.ClearBrand()
		return nil
	case product.FieldUnit:
		m.ClearUnit()
		return nil
	case product.FieldWeight:
		m.ClearWeight()
		return nil
	case product.FieldVolume:
		m.ClearVolume()
		return nil
	case product.FieldImages:
		m.ClearImages()
		return nil
	case product.FieldAttributes:
		m.ClearAttributes()
		return nil
	case product.FieldTags:
		m.ClearTags()
		return nil
	case product.FieldMetaTitle:
		m.ClearMetaTitle()
		return nil
	case product.FieldMetaDescription:
		m.ClearMetaDescription()
		return nil
	case product.FieldMetaKeywords:
		m.ClearMetaKeywords()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldShortDescription:
		m.ResetShortDescription()
		return nil
	case product.FieldSku:
		m.ResetSku()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldOriginalPrice:
		m.ResetOriginalPrice()
		return nil
	case product.FieldCostPrice:
		m.ResetCostPrice()
		return nil
	case product.FieldStock:
		m.ResetStock()
		return nil
	case product.FieldMinStock:
		m.ResetMinStock()
		return nil
	case product.FieldSales:
		m.ResetSales()
		return nil
	case product.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case product.FieldBrand:
		m.ResetBrand()
		return nil
	case product.FieldUnit:
		m.ResetUnit()
		return nil
	case product.FieldWeight:
		m.ResetWeight()
		return nil
	case product.FieldVolume:
		m.ResetVolume()
		return nil
	case product.FieldImages:
		m.ResetImages()
		return nil
	case product.FieldAttributes:
		m.ResetAttributes()
		return nil
	case product.FieldTags:
		m.ResetTags()
		return nil
	case product.FieldActive:
		m.ResetActive()
		return nil
	case product.FieldFeatured:
		m.ResetFeatured()
		return nil
	case product.FieldDigital:
		m.ResetDigital()
		return nil
	case product.FieldMetaTitle:
		m.ResetMetaTitle()
		return nil
	case product.FieldMetaDescription:
		m.ResetMetaDescription()
		return nil
	case product.FieldMetaKeywords:
		m.ResetMetaKeywords()
		return nil
	case product.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Product edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	code          *string
	description   *string
	is_default    *bool
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *RoleMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RoleMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RoleMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetIsDefault sets the "is_default" field.
func (m *RoleMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *RoleMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *RoleMutation) ResetIsDefault() {
	m.is_default = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.code != nil {
		fields = append(fields, role.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.is_default != nil {
		fields = append(fields, role.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldCode:
		return m.Code()
	case role.FieldDescription:
		return m.Description()
	case role.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldCode:
		return m.OldCode(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldCode:
		m.ResetCode()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// ScheduleJobMutation represents an operation that mutates the ScheduleJob nodes in the graph.
type ScheduleJobMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	_type                *string
	expression           *string
	description          *string
	enabled              *bool
	next_run_time        *time.Time
	last_run_time        *time.Time
	job_name             *string
	max_retries          *int
	addmax_retries       *int
	failure_notification *bool
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*ScheduleJob, error)
	predicates           []predicate.ScheduleJob
}

var _ ent.Mutation = (*ScheduleJobMutation)(nil)

// schedulejobOption allows management of the mutation configuration using functional options.
type schedulejobOption func(*ScheduleJobMutation)

// newScheduleJobMutation creates new mutation for the ScheduleJob entity.
func newScheduleJobMutation(c config, op Op, opts ...schedulejobOption) *ScheduleJobMutation {
	m := &ScheduleJobMutation{
		config:        c,
		op:            op,
		typ:           TypeScheduleJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleJobID sets the ID field of the mutation.
func withScheduleJobID(id int) schedulejobOption {
	return func(m *ScheduleJobMutation) {
		var (
			err   error
			once  sync.Once
			value *ScheduleJob
		)
		m.oldValue = func(ctx context.Context) (*ScheduleJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScheduleJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheduleJob sets the old ScheduleJob of the mutation.
func withScheduleJob(node *ScheduleJob) schedulejobOption {
	return func(m *ScheduleJobMutation) {
		m.oldValue = func(context.Context) (*ScheduleJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScheduleJob entities.
func (m *ScheduleJobMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleJobMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleJobMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScheduleJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ScheduleJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScheduleJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScheduleJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScheduleJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScheduleJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScheduleJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ScheduleJobMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScheduleJobMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScheduleJobMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *ScheduleJobMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ScheduleJobMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ScheduleJobMutation) ResetType() {
	m._type = nil
}

// SetExpression sets the "expression" field.
func (m *ScheduleJobMutation) SetExpression(s string) {
	m.expression = &s
}

// Expression returns the value of the "expression" field in the mutation.
func (m *ScheduleJobMutation) Expression() (r string, exists bool) {
	v := m.expression
	if v == nil {
		return
	}
	return *v, true
}

// OldExpression returns the old "expression" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldExpression(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpression is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpression requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpression: %w", err)
	}
	return oldValue.Expression, nil
}

// ResetExpression resets all changes to the "expression" field.
func (m *ScheduleJobMutation) ResetExpression() {
	m.expression = nil
}

// SetDescription sets the "description" field.
func (m *ScheduleJobMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ScheduleJobMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ScheduleJobMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[schedulejob.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ScheduleJobMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[schedulejob.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ScheduleJobMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, schedulejob.FieldDescription)
}

// SetEnabled sets the "enabled" field.
func (m *ScheduleJobMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ScheduleJobMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ScheduleJobMutation) ResetEnabled() {
	m.enabled = nil
}

// SetNextRunTime sets the "next_run_time" field.
func (m *ScheduleJobMutation) SetNextRunTime(t time.Time) {
	m.next_run_time = &t
}

// NextRunTime returns the value of the "next_run_time" field in the mutation.
func (m *ScheduleJobMutation) NextRunTime() (r time.Time, exists bool) {
	v := m.next_run_time
	if v == nil {
		return
	}
	return *v, true
}

// OldNextRunTime returns the old "next_run_time" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldNextRunTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextRunTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextRunTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextRunTime: %w", err)
	}
	return oldValue.NextRunTime, nil
}

// ClearNextRunTime clears the value of the "next_run_time" field.
func (m *ScheduleJobMutation) ClearNextRunTime() {
	m.next_run_time = nil
	m.clearedFields[schedulejob.FieldNextRunTime] = struct{}{}
}

// NextRunTimeCleared returns if the "next_run_time" field was cleared in this mutation.
func (m *ScheduleJobMutation) NextRunTimeCleared() bool {
	_, ok := m.clearedFields[schedulejob.FieldNextRunTime]
	return ok
}

// ResetNextRunTime resets all changes to the "next_run_time" field.
func (m *ScheduleJobMutation) ResetNextRunTime() {
	m.next_run_time = nil
	delete(m.clearedFields, schedulejob.FieldNextRunTime)
}

// SetLastRunTime sets the "last_run_time" field.
func (m *ScheduleJobMutation) SetLastRunTime(t time.Time) {
	m.last_run_time = &t
}

// LastRunTime returns the value of the "last_run_time" field in the mutation.
func (m *ScheduleJobMutation) LastRunTime() (r time.Time, exists bool) {
	v := m.last_run_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRunTime returns the old "last_run_time" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldLastRunTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRunTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRunTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRunTime: %w", err)
	}
	return oldValue.LastRunTime, nil
}

// ClearLastRunTime clears the value of the "last_run_time" field.
func (m *ScheduleJobMutation) ClearLastRunTime() {
	m.last_run_time = nil
	m.clearedFields[schedulejob.FieldLastRunTime] = struct{}{}
}

// LastRunTimeCleared returns if the "last_run_time" field was cleared in this mutation.
func (m *ScheduleJobMutation) LastRunTimeCleared() bool {
	_, ok := m.clearedFields[schedulejob.FieldLastRunTime]
	return ok
}

// ResetLastRunTime resets all changes to the "last_run_time" field.
func (m *ScheduleJobMutation) ResetLastRunTime() {
	m.last_run_time = nil
	delete(m.clearedFields, schedulejob.FieldLastRunTime)
}

// SetJobName sets the "job_name" field.
func (m *ScheduleJobMutation) SetJobName(s string) {
	m.job_name = &s
}

// JobName returns the value of the "job_name" field in the mutation.
func (m *ScheduleJobMutation) JobName() (r string, exists bool) {
	v := m.job_name
	if v == nil {
		return
	}
	return *v, true
}

// OldJobName returns the old "job_name" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldJobName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobName: %w", err)
	}
	return oldValue.JobName, nil
}

// ResetJobName resets all changes to the "job_name" field.
func (m *ScheduleJobMutation) ResetJobName() {
	m.job_name = nil
}

// SetMaxRetries sets the "max_retries" field.
func (m *ScheduleJobMutation) SetMaxRetries(i int) {
	m.max_retries = &i
	m.addmax_retries = nil
}

// MaxRetries returns the value of the "max_retries" field in the mutation.
func (m *ScheduleJobMutation) MaxRetries() (r int, exists bool) {
	v := m.max_retries
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxRetries returns the old "max_retries" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldMaxRetries(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxRetries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxRetries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxRetries: %w", err)
	}
	return oldValue.MaxRetries, nil
}

// AddMaxRetries adds i to the "max_retries" field.
func (m *ScheduleJobMutation) AddMaxRetries(i int) {
	if m.addmax_retries != nil {
		*m.addmax_retries += i
	} else {
		m.addmax_retries = &i
	}
}

// AddedMaxRetries returns the value that was added to the "max_retries" field in this mutation.
func (m *ScheduleJobMutation) AddedMaxRetries() (r int, exists bool) {
	v := m.addmax_retries
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxRetries resets all changes to the "max_retries" field.
func (m *ScheduleJobMutation) ResetMaxRetries() {
	m.max_retries = nil
	m.addmax_retries = nil
}

// SetFailureNotification sets the "failure_notification" field.
func (m *ScheduleJobMutation) SetFailureNotification(b bool) {
	m.failure_notification = &b
}

// FailureNotification returns the value of the "failure_notification" field in the mutation.
func (m *ScheduleJobMutation) FailureNotification() (r bool, exists bool) {
	v := m.failure_notification
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureNotification returns the old "failure_notification" field's value of the ScheduleJob entity.
// If the ScheduleJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleJobMutation) OldFailureNotification(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureNotification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureNotification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureNotification: %w", err)
	}
	return oldValue.FailureNotification, nil
}

// ResetFailureNotification resets all changes to the "failure_notification" field.
func (m *ScheduleJobMutation) ResetFailureNotification() {
	m.failure_notification = nil
}

// Where appends a list predicates to the ScheduleJobMutation builder.
func (m *ScheduleJobMutation) Where(ps ...predicate.ScheduleJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScheduleJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScheduleJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ScheduleJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScheduleJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScheduleJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ScheduleJob).
func (m *ScheduleJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleJobMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, schedulejob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, schedulejob.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, schedulejob.FieldName)
	}
	if m._type != nil {
		fields = append(fields, schedulejob.FieldType)
	}
	if m.expression != nil {
		fields = append(fields, schedulejob.FieldExpression)
	}
	if m.description != nil {
		fields = append(fields, schedulejob.FieldDescription)
	}
	if m.enabled != nil {
		fields = append(fields, schedulejob.FieldEnabled)
	}
	if m.next_run_time != nil {
		fields = append(fields, schedulejob.FieldNextRunTime)
	}
	if m.last_run_time != nil {
		fields = append(fields, schedulejob.FieldLastRunTime)
	}
	if m.job_name != nil {
		fields = append(fields, schedulejob.FieldJobName)
	}
	if m.max_retries != nil {
		fields = append(fields, schedulejob.FieldMaxRetries)
	}
	if m.failure_notification != nil {
		fields = append(fields, schedulejob.FieldFailureNotification)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedulejob.FieldCreatedAt:
		return m.CreatedAt()
	case schedulejob.FieldUpdatedAt:
		return m.UpdatedAt()
	case schedulejob.FieldName:
		return m.Name()
	case schedulejob.FieldType:
		return m.GetType()
	case schedulejob.FieldExpression:
		return m.Expression()
	case schedulejob.FieldDescription:
		return m.Description()
	case schedulejob.FieldEnabled:
		return m.Enabled()
	case schedulejob.FieldNextRunTime:
		return m.NextRunTime()
	case schedulejob.FieldLastRunTime:
		return m.LastRunTime()
	case schedulejob.FieldJobName:
		return m.JobName()
	case schedulejob.FieldMaxRetries:
		return m.MaxRetries()
	case schedulejob.FieldFailureNotification:
		return m.FailureNotification()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedulejob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case schedulejob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case schedulejob.FieldName:
		return m.OldName(ctx)
	case schedulejob.FieldType:
		return m.OldType(ctx)
	case schedulejob.FieldExpression:
		return m.OldExpression(ctx)
	case schedulejob.FieldDescription:
		return m.OldDescription(ctx)
	case schedulejob.FieldEnabled:
		return m.OldEnabled(ctx)
	case schedulejob.FieldNextRunTime:
		return m.OldNextRunTime(ctx)
	case schedulejob.FieldLastRunTime:
		return m.OldLastRunTime(ctx)
	case schedulejob.FieldJobName:
		return m.OldJobName(ctx)
	case schedulejob.FieldMaxRetries:
		return m.OldMaxRetries(ctx)
	case schedulejob.FieldFailureNotification:
		return m.OldFailureNotification(ctx)
	}
	return nil, fmt.Errorf("unknown ScheduleJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedulejob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case schedulejob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case schedulejob.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case schedulejob.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case schedulejob.FieldExpression:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpression(v)
		return nil
	case schedulejob.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case schedulejob.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case schedulejob.FieldNextRunTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextRunTime(v)
		return nil
	case schedulejob.FieldLastRunTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRunTime(v)
		return nil
	case schedulejob.FieldJobName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobName(v)
		return nil
	case schedulejob.FieldMaxRetries:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxRetries(v)
		return nil
	case schedulejob.FieldFailureNotification:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureNotification(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduleJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleJobMutation) AddedFields() []string {
	var fields []string
	if m.addmax_retries != nil {
		fields = append(fields, schedulejob.FieldMaxRetries)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schedulejob.FieldMaxRetries:
		return m.AddedMaxRetries()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schedulejob.FieldMaxRetries:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxRetries(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduleJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(schedulejob.FieldDescription) {
		fields = append(fields, schedulejob.FieldDescription)
	}
	if m.FieldCleared(schedulejob.FieldNextRunTime) {
		fields = append(fields, schedulejob.FieldNextRunTime)
	}
	if m.FieldCleared(schedulejob.FieldLastRunTime) {
		fields = append(fields, schedulejob.FieldLastRunTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleJobMutation) ClearField(name string) error {
	switch name {
	case schedulejob.FieldDescription:
		m.ClearDescription()
		return nil
	case schedulejob.FieldNextRunTime:
		m.ClearNextRunTime()
		return nil
	case schedulejob.FieldLastRunTime:
		m.ClearLastRunTime()
		return nil
	}
	return fmt.Errorf("unknown ScheduleJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleJobMutation) ResetField(name string) error {
	switch name {
	case schedulejob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case schedulejob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case schedulejob.FieldName:
		m.ResetName()
		return nil
	case schedulejob.FieldType:
		m.ResetType()
		return nil
	case schedulejob.FieldExpression:
		m.ResetExpression()
		return nil
	case schedulejob.FieldDescription:
		m.ResetDescription()
		return nil
	case schedulejob.FieldEnabled:
		m.ResetEnabled()
		return nil
	case schedulejob.FieldNextRunTime:
		m.ResetNextRunTime()
		return nil
	case schedulejob.FieldLastRunTime:
		m.ResetLastRunTime()
		return nil
	case schedulejob.FieldJobName:
		m.ResetJobName()
		return nil
	case schedulejob.FieldMaxRetries:
		m.ResetMaxRetries()
		return nil
	case schedulejob.FieldFailureNotification:
		m.ResetFailureNotification()
		return nil
	}
	return fmt.Errorf("unknown ScheduleJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleJobMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleJobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleJobMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleJobMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ScheduleJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleJobMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ScheduleJob edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	key           *string
	value         *string
	comment       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the "key" field.
func (m *SettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetComment sets the "comment" field.
func (m *SettingMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *SettingMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *SettingMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[setting.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *SettingMutation) CommentCleared() bool {
	_, ok := m.clearedFields[setting.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *SettingMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, setting.FieldComment)
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, setting.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.comment != nil {
		fields = append(fields, setting.FieldComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	case setting.FieldKey:
		return m.Key()
	case setting.FieldValue:
		return m.Value()
	case setting.FieldComment:
		return m.Comment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setting.FieldKey:
		return m.OldKey(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldComment:
		return m.OldComment(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldComment) {
		fields = append(fields, setting.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setting.FieldKey:
		m.ResetKey()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// StorageStrategyMutation represents an operation that mutates the StorageStrategy nodes in the graph.
type StorageStrategyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	_type         *storagestrategy.Type
	node_id       *string
	endpoint      *string
	region        *string
	bucket        *string
	access_key    *string
	secret_key    *string
	base_path     *string
	domain        *string
	master        *bool
	clearedFields map[string]struct{}
	files         map[int]struct{}
	removedfiles  map[int]struct{}
	clearedfiles  bool
	done          bool
	oldValue      func(context.Context) (*StorageStrategy, error)
	predicates    []predicate.StorageStrategy
}

var _ ent.Mutation = (*StorageStrategyMutation)(nil)

// storagestrategyOption allows management of the mutation configuration using functional options.
type storagestrategyOption func(*StorageStrategyMutation)

// newStorageStrategyMutation creates new mutation for the StorageStrategy entity.
func newStorageStrategyMutation(c config, op Op, opts ...storagestrategyOption) *StorageStrategyMutation {
	m := &StorageStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeStorageStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStorageStrategyID sets the ID field of the mutation.
func withStorageStrategyID(id int) storagestrategyOption {
	return func(m *StorageStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *StorageStrategy
		)
		m.oldValue = func(ctx context.Context) (*StorageStrategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StorageStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStorageStrategy sets the old StorageStrategy of the mutation.
func withStorageStrategy(node *StorageStrategy) storagestrategyOption {
	return func(m *StorageStrategyMutation) {
		m.oldValue = func(context.Context) (*StorageStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StorageStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StorageStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StorageStrategy entities.
func (m *StorageStrategyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StorageStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StorageStrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StorageStrategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StorageStrategyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StorageStrategyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StorageStrategyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StorageStrategyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StorageStrategyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StorageStrategyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *StorageStrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StorageStrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StorageStrategyMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *StorageStrategyMutation) SetType(s storagestrategy.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *StorageStrategyMutation) GetType() (r storagestrategy.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldType(ctx context.Context) (v storagestrategy.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *StorageStrategyMutation) ResetType() {
	m._type = nil
}

// SetNodeID sets the "node_id" field.
func (m *StorageStrategyMutation) SetNodeID(s string) {
	m.node_id = &s
}

// NodeID returns the value of the "node_id" field in the mutation.
func (m *StorageStrategyMutation) NodeID() (r string, exists bool) {
	v := m.node_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeID returns the old "node_id" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldNodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeID: %w", err)
	}
	return oldValue.NodeID, nil
}

// ResetNodeID resets all changes to the "node_id" field.
func (m *StorageStrategyMutation) ResetNodeID() {
	m.node_id = nil
}

// SetEndpoint sets the "endpoint" field.
func (m *StorageStrategyMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *StorageStrategyMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *StorageStrategyMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetRegion sets the "region" field.
func (m *StorageStrategyMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *StorageStrategyMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *StorageStrategyMutation) ResetRegion() {
	m.region = nil
}

// SetBucket sets the "bucket" field.
func (m *StorageStrategyMutation) SetBucket(s string) {
	m.bucket = &s
}

// Bucket returns the value of the "bucket" field in the mutation.
func (m *StorageStrategyMutation) Bucket() (r string, exists bool) {
	v := m.bucket
	if v == nil {
		return
	}
	return *v, true
}

// OldBucket returns the old "bucket" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldBucket(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucket is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucket: %w", err)
	}
	return oldValue.Bucket, nil
}

// ResetBucket resets all changes to the "bucket" field.
func (m *StorageStrategyMutation) ResetBucket() {
	m.bucket = nil
}

// SetAccessKey sets the "access_key" field.
func (m *StorageStrategyMutation) SetAccessKey(s string) {
	m.access_key = &s
}

// AccessKey returns the value of the "access_key" field in the mutation.
func (m *StorageStrategyMutation) AccessKey() (r string, exists bool) {
	v := m.access_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessKey returns the old "access_key" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldAccessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessKey: %w", err)
	}
	return oldValue.AccessKey, nil
}

// ResetAccessKey resets all changes to the "access_key" field.
func (m *StorageStrategyMutation) ResetAccessKey() {
	m.access_key = nil
}

// SetSecretKey sets the "secret_key" field.
func (m *StorageStrategyMutation) SetSecretKey(s string) {
	m.secret_key = &s
}

// SecretKey returns the value of the "secret_key" field in the mutation.
func (m *StorageStrategyMutation) SecretKey() (r string, exists bool) {
	v := m.secret_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "secret_key" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ResetSecretKey resets all changes to the "secret_key" field.
func (m *StorageStrategyMutation) ResetSecretKey() {
	m.secret_key = nil
}

// SetBasePath sets the "base_path" field.
func (m *StorageStrategyMutation) SetBasePath(s string) {
	m.base_path = &s
}

// BasePath returns the value of the "base_path" field in the mutation.
func (m *StorageStrategyMutation) BasePath() (r string, exists bool) {
	v := m.base_path
	if v == nil {
		return
	}
	return *v, true
}

// OldBasePath returns the old "base_path" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldBasePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBasePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBasePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBasePath: %w", err)
	}
	return oldValue.BasePath, nil
}

// ResetBasePath resets all changes to the "base_path" field.
func (m *StorageStrategyMutation) ResetBasePath() {
	m.base_path = nil
}

// SetDomain sets the "domain" field.
func (m *StorageStrategyMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *StorageStrategyMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *StorageStrategyMutation) ResetDomain() {
	m.domain = nil
}

// SetMaster sets the "master" field.
func (m *StorageStrategyMutation) SetMaster(b bool) {
	m.master = &b
}

// Master returns the value of the "master" field in the mutation.
func (m *StorageStrategyMutation) Master() (r bool, exists bool) {
	v := m.master
	if v == nil {
		return
	}
	return *v, true
}

// OldMaster returns the old "master" field's value of the StorageStrategy entity.
// If the StorageStrategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageStrategyMutation) OldMaster(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaster is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaster requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaster: %w", err)
	}
	return oldValue.Master, nil
}

// ResetMaster resets all changes to the "master" field.
func (m *StorageStrategyMutation) ResetMaster() {
	m.master = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *StorageStrategyMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *StorageStrategyMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *StorageStrategyMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *StorageStrategyMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *StorageStrategyMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *StorageStrategyMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *StorageStrategyMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the StorageStrategyMutation builder.
func (m *StorageStrategyMutation) Where(ps ...predicate.StorageStrategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StorageStrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StorageStrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StorageStrategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StorageStrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StorageStrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StorageStrategy).
func (m *StorageStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StorageStrategyMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, storagestrategy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storagestrategy.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, storagestrategy.FieldName)
	}
	if m._type != nil {
		fields = append(fields, storagestrategy.FieldType)
	}
	if m.node_id != nil {
		fields = append(fields, storagestrategy.FieldNodeID)
	}
	if m.endpoint != nil {
		fields = append(fields, storagestrategy.FieldEndpoint)
	}
	if m.region != nil {
		fields = append(fields, storagestrategy.FieldRegion)
	}
	if m.bucket != nil {
		fields = append(fields, storagestrategy.FieldBucket)
	}
	if m.access_key != nil {
		fields = append(fields, storagestrategy.FieldAccessKey)
	}
	if m.secret_key != nil {
		fields = append(fields, storagestrategy.FieldSecretKey)
	}
	if m.base_path != nil {
		fields = append(fields, storagestrategy.FieldBasePath)
	}
	if m.domain != nil {
		fields = append(fields, storagestrategy.FieldDomain)
	}
	if m.master != nil {
		fields = append(fields, storagestrategy.FieldMaster)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StorageStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storagestrategy.FieldCreatedAt:
		return m.CreatedAt()
	case storagestrategy.FieldUpdatedAt:
		return m.UpdatedAt()
	case storagestrategy.FieldName:
		return m.Name()
	case storagestrategy.FieldType:
		return m.GetType()
	case storagestrategy.FieldNodeID:
		return m.NodeID()
	case storagestrategy.FieldEndpoint:
		return m.Endpoint()
	case storagestrategy.FieldRegion:
		return m.Region()
	case storagestrategy.FieldBucket:
		return m.Bucket()
	case storagestrategy.FieldAccessKey:
		return m.AccessKey()
	case storagestrategy.FieldSecretKey:
		return m.SecretKey()
	case storagestrategy.FieldBasePath:
		return m.BasePath()
	case storagestrategy.FieldDomain:
		return m.Domain()
	case storagestrategy.FieldMaster:
		return m.Master()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StorageStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storagestrategy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storagestrategy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storagestrategy.FieldName:
		return m.OldName(ctx)
	case storagestrategy.FieldType:
		return m.OldType(ctx)
	case storagestrategy.FieldNodeID:
		return m.OldNodeID(ctx)
	case storagestrategy.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case storagestrategy.FieldRegion:
		return m.OldRegion(ctx)
	case storagestrategy.FieldBucket:
		return m.OldBucket(ctx)
	case storagestrategy.FieldAccessKey:
		return m.OldAccessKey(ctx)
	case storagestrategy.FieldSecretKey:
		return m.OldSecretKey(ctx)
	case storagestrategy.FieldBasePath:
		return m.OldBasePath(ctx)
	case storagestrategy.FieldDomain:
		return m.OldDomain(ctx)
	case storagestrategy.FieldMaster:
		return m.OldMaster(ctx)
	}
	return nil, fmt.Errorf("unknown StorageStrategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storagestrategy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storagestrategy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storagestrategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case storagestrategy.FieldType:
		v, ok := value.(storagestrategy.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case storagestrategy.FieldNodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeID(v)
		return nil
	case storagestrategy.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case storagestrategy.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case storagestrategy.FieldBucket:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucket(v)
		return nil
	case storagestrategy.FieldAccessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessKey(v)
		return nil
	case storagestrategy.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	case storagestrategy.FieldBasePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBasePath(v)
		return nil
	case storagestrategy.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case storagestrategy.FieldMaster:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaster(v)
		return nil
	}
	return fmt.Errorf("unknown StorageStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StorageStrategyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StorageStrategyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StorageStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StorageStrategyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StorageStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StorageStrategyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StorageStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StorageStrategyMutation) ResetField(name string) error {
	switch name {
	case storagestrategy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storagestrategy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storagestrategy.FieldName:
		m.ResetName()
		return nil
	case storagestrategy.FieldType:
		m.ResetType()
		return nil
	case storagestrategy.FieldNodeID:
		m.ResetNodeID()
		return nil
	case storagestrategy.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case storagestrategy.FieldRegion:
		m.ResetRegion()
		return nil
	case storagestrategy.FieldBucket:
		m.ResetBucket()
		return nil
	case storagestrategy.FieldAccessKey:
		m.ResetAccessKey()
		return nil
	case storagestrategy.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	case storagestrategy.FieldBasePath:
		m.ResetBasePath()
		return nil
	case storagestrategy.FieldDomain:
		m.ResetDomain()
		return nil
	case storagestrategy.FieldMaster:
		m.ResetMaster()
		return nil
	}
	return fmt.Errorf("unknown StorageStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StorageStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.files != nil {
		edges = append(edges, storagestrategy.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StorageStrategyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storagestrategy.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StorageStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfiles != nil {
		edges = append(edges, storagestrategy.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StorageStrategyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case storagestrategy.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StorageStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfiles {
		edges = append(edges, storagestrategy.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StorageStrategyMutation) EdgeCleared(name string) bool {
	switch name {
	case storagestrategy.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StorageStrategyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown StorageStrategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StorageStrategyMutation) ResetEdge(name string) error {
	switch name {
	case storagestrategy.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown StorageStrategy edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	description   *string
	slug          *string
	color         *string
	sort_order    *int
	addsort_order *int
	active        *bool
	clearedFields map[string]struct{}
	posts         map[int]struct{}
	removedposts  map[int]struct{}
	clearedposts  bool
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tag.FieldDescription)
}

// SetSlug sets the "slug" field.
func (m *TagMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TagMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *TagMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[tag.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *TagMutation) SlugCleared() bool {
	_, ok := m.clearedFields[tag.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *TagMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, tag.FieldSlug)
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *TagMutation) ClearColor() {
	m.color = nil
	m.clearedFields[tag.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *TagMutation) ColorCleared() bool {
	_, ok := m.clearedFields[tag.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, tag.FieldColor)
}

// SetSortOrder sets the "sort_order" field.
func (m *TagMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *TagMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *TagMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *TagMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *TagMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetActive sets the "active" field.
func (m *TagMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *TagMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *TagMutation) ResetActive() {
	m.active = nil
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *TagMutation) AddPostIDs(ids ...int) {
	if m.posts == nil {
		m.posts = make(map[int]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *TagMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *TagMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *TagMutation) RemovePostIDs(ids ...int) {
	if m.removedposts == nil {
		m.removedposts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *TagMutation) RemovedPostsIDs() (ids []int) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *TagMutation) PostsIDs() (ids []int) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *TagMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.slug != nil {
		fields = append(fields, tag.FieldSlug)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	if m.sort_order != nil {
		fields = append(fields, tag.FieldSortOrder)
	}
	if m.active != nil {
		fields = append(fields, tag.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldSlug:
		return m.Slug()
	case tag.FieldColor:
		return m.Color()
	case tag.FieldSortOrder:
		return m.SortOrder()
	case tag.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldSlug:
		return m.OldSlug(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	case tag.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case tag.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case tag.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case tag.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, tag.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tag.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDescription) {
		fields = append(fields, tag.FieldDescription)
	}
	if m.FieldCleared(tag.FieldSlug) {
		fields = append(fields, tag.FieldSlug)
	}
	if m.FieldCleared(tag.FieldColor) {
		fields = append(fields, tag.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDescription:
		m.ClearDescription()
		return nil
	case tag.FieldSlug:
		m.ClearSlug()
		return nil
	case tag.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldSlug:
		m.ResetSlug()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	case tag.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case tag.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.posts != nil {
		edges = append(edges, tag.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedposts != nil {
		edges = append(edges, tag.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedposts {
		edges = append(edges, tag.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// ThemeMutation represents an operation that mutates the Theme nodes in the graph.
type ThemeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	_type           *string
	name            *string
	display_name    *string
	description     *string
	author_name     *string
	author_email    *string
	logo            *string
	homepage        *string
	repo            *string
	issue           *string
	setting_name    *string
	config_map_name *string
	version         *string
	require         *string
	license         *string
	_path           *string
	external_url    *string
	enabled         *bool
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Theme, error)
	predicates      []predicate.Theme
}

var _ ent.Mutation = (*ThemeMutation)(nil)

// themeOption allows management of the mutation configuration using functional options.
type themeOption func(*ThemeMutation)

// newThemeMutation creates new mutation for the Theme entity.
func newThemeMutation(c config, op Op, opts ...themeOption) *ThemeMutation {
	m := &ThemeMutation{
		config:        c,
		op:            op,
		typ:           TypeTheme,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThemeID sets the ID field of the mutation.
func withThemeID(id int) themeOption {
	return func(m *ThemeMutation) {
		var (
			err   error
			once  sync.Once
			value *Theme
		)
		m.oldValue = func(ctx context.Context) (*Theme, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Theme.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTheme sets the old Theme of the mutation.
func withTheme(node *Theme) themeOption {
	return func(m *ThemeMutation) {
		m.oldValue = func(context.Context) (*Theme, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThemeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThemeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Theme entities.
func (m *ThemeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThemeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThemeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Theme.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ThemeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThemeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThemeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThemeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThemeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThemeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *ThemeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ThemeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ThemeMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *ThemeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ThemeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ThemeMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ThemeMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ThemeMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ThemeMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetDescription sets the "description" field.
func (m *ThemeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ThemeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ThemeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[theme.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ThemeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[theme.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ThemeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, theme.FieldDescription)
}

// SetAuthorName sets the "author_name" field.
func (m *ThemeMutation) SetAuthorName(s string) {
	m.author_name = &s
}

// AuthorName returns the value of the "author_name" field in the mutation.
func (m *ThemeMutation) AuthorName() (r string, exists bool) {
	v := m.author_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorName returns the old "author_name" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldAuthorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorName: %w", err)
	}
	return oldValue.AuthorName, nil
}

// ClearAuthorName clears the value of the "author_name" field.
func (m *ThemeMutation) ClearAuthorName() {
	m.author_name = nil
	m.clearedFields[theme.FieldAuthorName] = struct{}{}
}

// AuthorNameCleared returns if the "author_name" field was cleared in this mutation.
func (m *ThemeMutation) AuthorNameCleared() bool {
	_, ok := m.clearedFields[theme.FieldAuthorName]
	return ok
}

// ResetAuthorName resets all changes to the "author_name" field.
func (m *ThemeMutation) ResetAuthorName() {
	m.author_name = nil
	delete(m.clearedFields, theme.FieldAuthorName)
}

// SetAuthorEmail sets the "author_email" field.
func (m *ThemeMutation) SetAuthorEmail(s string) {
	m.author_email = &s
}

// AuthorEmail returns the value of the "author_email" field in the mutation.
func (m *ThemeMutation) AuthorEmail() (r string, exists bool) {
	v := m.author_email
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorEmail returns the old "author_email" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldAuthorEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorEmail: %w", err)
	}
	return oldValue.AuthorEmail, nil
}

// ClearAuthorEmail clears the value of the "author_email" field.
func (m *ThemeMutation) ClearAuthorEmail() {
	m.author_email = nil
	m.clearedFields[theme.FieldAuthorEmail] = struct{}{}
}

// AuthorEmailCleared returns if the "author_email" field was cleared in this mutation.
func (m *ThemeMutation) AuthorEmailCleared() bool {
	_, ok := m.clearedFields[theme.FieldAuthorEmail]
	return ok
}

// ResetAuthorEmail resets all changes to the "author_email" field.
func (m *ThemeMutation) ResetAuthorEmail() {
	m.author_email = nil
	delete(m.clearedFields, theme.FieldAuthorEmail)
}

// SetLogo sets the "logo" field.
func (m *ThemeMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *ThemeMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *ThemeMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[theme.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *ThemeMutation) LogoCleared() bool {
	_, ok := m.clearedFields[theme.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *ThemeMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, theme.FieldLogo)
}

// SetHomepage sets the "homepage" field.
func (m *ThemeMutation) SetHomepage(s string) {
	m.homepage = &s
}

// Homepage returns the value of the "homepage" field in the mutation.
func (m *ThemeMutation) Homepage() (r string, exists bool) {
	v := m.homepage
	if v == nil {
		return
	}
	return *v, true
}

// OldHomepage returns the old "homepage" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldHomepage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomepage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomepage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomepage: %w", err)
	}
	return oldValue.Homepage, nil
}

// ClearHomepage clears the value of the "homepage" field.
func (m *ThemeMutation) ClearHomepage() {
	m.homepage = nil
	m.clearedFields[theme.FieldHomepage] = struct{}{}
}

// HomepageCleared returns if the "homepage" field was cleared in this mutation.
func (m *ThemeMutation) HomepageCleared() bool {
	_, ok := m.clearedFields[theme.FieldHomepage]
	return ok
}

// ResetHomepage resets all changes to the "homepage" field.
func (m *ThemeMutation) ResetHomepage() {
	m.homepage = nil
	delete(m.clearedFields, theme.FieldHomepage)
}

// SetRepo sets the "repo" field.
func (m *ThemeMutation) SetRepo(s string) {
	m.repo = &s
}

// Repo returns the value of the "repo" field in the mutation.
func (m *ThemeMutation) Repo() (r string, exists bool) {
	v := m.repo
	if v == nil {
		return
	}
	return *v, true
}

// OldRepo returns the old "repo" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldRepo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepo: %w", err)
	}
	return oldValue.Repo, nil
}

// ClearRepo clears the value of the "repo" field.
func (m *ThemeMutation) ClearRepo() {
	m.repo = nil
	m.clearedFields[theme.FieldRepo] = struct{}{}
}

// RepoCleared returns if the "repo" field was cleared in this mutation.
func (m *ThemeMutation) RepoCleared() bool {
	_, ok := m.clearedFields[theme.FieldRepo]
	return ok
}

// ResetRepo resets all changes to the "repo" field.
func (m *ThemeMutation) ResetRepo() {
	m.repo = nil
	delete(m.clearedFields, theme.FieldRepo)
}

// SetIssue sets the "issue" field.
func (m *ThemeMutation) SetIssue(s string) {
	m.issue = &s
}

// Issue returns the value of the "issue" field in the mutation.
func (m *ThemeMutation) Issue() (r string, exists bool) {
	v := m.issue
	if v == nil {
		return
	}
	return *v, true
}

// OldIssue returns the old "issue" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldIssue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssue: %w", err)
	}
	return oldValue.Issue, nil
}

// ClearIssue clears the value of the "issue" field.
func (m *ThemeMutation) ClearIssue() {
	m.issue = nil
	m.clearedFields[theme.FieldIssue] = struct{}{}
}

// IssueCleared returns if the "issue" field was cleared in this mutation.
func (m *ThemeMutation) IssueCleared() bool {
	_, ok := m.clearedFields[theme.FieldIssue]
	return ok
}

// ResetIssue resets all changes to the "issue" field.
func (m *ThemeMutation) ResetIssue() {
	m.issue = nil
	delete(m.clearedFields, theme.FieldIssue)
}

// SetSettingName sets the "setting_name" field.
func (m *ThemeMutation) SetSettingName(s string) {
	m.setting_name = &s
}

// SettingName returns the value of the "setting_name" field in the mutation.
func (m *ThemeMutation) SettingName() (r string, exists bool) {
	v := m.setting_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSettingName returns the old "setting_name" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldSettingName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettingName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettingName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettingName: %w", err)
	}
	return oldValue.SettingName, nil
}

// ClearSettingName clears the value of the "setting_name" field.
func (m *ThemeMutation) ClearSettingName() {
	m.setting_name = nil
	m.clearedFields[theme.FieldSettingName] = struct{}{}
}

// SettingNameCleared returns if the "setting_name" field was cleared in this mutation.
func (m *ThemeMutation) SettingNameCleared() bool {
	_, ok := m.clearedFields[theme.FieldSettingName]
	return ok
}

// ResetSettingName resets all changes to the "setting_name" field.
func (m *ThemeMutation) ResetSettingName() {
	m.setting_name = nil
	delete(m.clearedFields, theme.FieldSettingName)
}

// SetConfigMapName sets the "config_map_name" field.
func (m *ThemeMutation) SetConfigMapName(s string) {
	m.config_map_name = &s
}

// ConfigMapName returns the value of the "config_map_name" field in the mutation.
func (m *ThemeMutation) ConfigMapName() (r string, exists bool) {
	v := m.config_map_name
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigMapName returns the old "config_map_name" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldConfigMapName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigMapName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigMapName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigMapName: %w", err)
	}
	return oldValue.ConfigMapName, nil
}

// ClearConfigMapName clears the value of the "config_map_name" field.
func (m *ThemeMutation) ClearConfigMapName() {
	m.config_map_name = nil
	m.clearedFields[theme.FieldConfigMapName] = struct{}{}
}

// ConfigMapNameCleared returns if the "config_map_name" field was cleared in this mutation.
func (m *ThemeMutation) ConfigMapNameCleared() bool {
	_, ok := m.clearedFields[theme.FieldConfigMapName]
	return ok
}

// ResetConfigMapName resets all changes to the "config_map_name" field.
func (m *ThemeMutation) ResetConfigMapName() {
	m.config_map_name = nil
	delete(m.clearedFields, theme.FieldConfigMapName)
}

// SetVersion sets the "version" field.
func (m *ThemeMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ThemeMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ThemeMutation) ResetVersion() {
	m.version = nil
}

// SetRequire sets the "require" field.
func (m *ThemeMutation) SetRequire(s string) {
	m.require = &s
}

// Require returns the value of the "require" field in the mutation.
func (m *ThemeMutation) Require() (r string, exists bool) {
	v := m.require
	if v == nil {
		return
	}
	return *v, true
}

// OldRequire returns the old "require" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldRequire(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequire is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequire requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequire: %w", err)
	}
	return oldValue.Require, nil
}

// ResetRequire resets all changes to the "require" field.
func (m *ThemeMutation) ResetRequire() {
	m.require = nil
}

// SetLicense sets the "license" field.
func (m *ThemeMutation) SetLicense(s string) {
	m.license = &s
}

// License returns the value of the "license" field in the mutation.
func (m *ThemeMutation) License() (r string, exists bool) {
	v := m.license
	if v == nil {
		return
	}
	return *v, true
}

// OldLicense returns the old "license" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldLicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicense: %w", err)
	}
	return oldValue.License, nil
}

// ClearLicense clears the value of the "license" field.
func (m *ThemeMutation) ClearLicense() {
	m.license = nil
	m.clearedFields[theme.FieldLicense] = struct{}{}
}

// LicenseCleared returns if the "license" field was cleared in this mutation.
func (m *ThemeMutation) LicenseCleared() bool {
	_, ok := m.clearedFields[theme.FieldLicense]
	return ok
}

// ResetLicense resets all changes to the "license" field.
func (m *ThemeMutation) ResetLicense() {
	m.license = nil
	delete(m.clearedFields, theme.FieldLicense)
}

// SetPath sets the "path" field.
func (m *ThemeMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ThemeMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *ThemeMutation) ClearPath() {
	m._path = nil
	m.clearedFields[theme.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *ThemeMutation) PathCleared() bool {
	_, ok := m.clearedFields[theme.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *ThemeMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, theme.FieldPath)
}

// SetExternalURL sets the "external_url" field.
func (m *ThemeMutation) SetExternalURL(s string) {
	m.external_url = &s
}

// ExternalURL returns the value of the "external_url" field in the mutation.
func (m *ThemeMutation) ExternalURL() (r string, exists bool) {
	v := m.external_url
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalURL returns the old "external_url" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldExternalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalURL: %w", err)
	}
	return oldValue.ExternalURL, nil
}

// ClearExternalURL clears the value of the "external_url" field.
func (m *ThemeMutation) ClearExternalURL() {
	m.external_url = nil
	m.clearedFields[theme.FieldExternalURL] = struct{}{}
}

// ExternalURLCleared returns if the "external_url" field was cleared in this mutation.
func (m *ThemeMutation) ExternalURLCleared() bool {
	_, ok := m.clearedFields[theme.FieldExternalURL]
	return ok
}

// ResetExternalURL resets all changes to the "external_url" field.
func (m *ThemeMutation) ResetExternalURL() {
	m.external_url = nil
	delete(m.clearedFields, theme.FieldExternalURL)
}

// SetEnabled sets the "enabled" field.
func (m *ThemeMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ThemeMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ThemeMutation) ResetEnabled() {
	m.enabled = nil
}

// Where appends a list predicates to the ThemeMutation builder.
func (m *ThemeMutation) Where(ps ...predicate.Theme) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThemeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThemeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Theme, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThemeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThemeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Theme).
func (m *ThemeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThemeMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, theme.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, theme.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, theme.FieldType)
	}
	if m.name != nil {
		fields = append(fields, theme.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, theme.FieldDisplayName)
	}
	if m.description != nil {
		fields = append(fields, theme.FieldDescription)
	}
	if m.author_name != nil {
		fields = append(fields, theme.FieldAuthorName)
	}
	if m.author_email != nil {
		fields = append(fields, theme.FieldAuthorEmail)
	}
	if m.logo != nil {
		fields = append(fields, theme.FieldLogo)
	}
	if m.homepage != nil {
		fields = append(fields, theme.FieldHomepage)
	}
	if m.repo != nil {
		fields = append(fields, theme.FieldRepo)
	}
	if m.issue != nil {
		fields = append(fields, theme.FieldIssue)
	}
	if m.setting_name != nil {
		fields = append(fields, theme.FieldSettingName)
	}
	if m.config_map_name != nil {
		fields = append(fields, theme.FieldConfigMapName)
	}
	if m.version != nil {
		fields = append(fields, theme.FieldVersion)
	}
	if m.require != nil {
		fields = append(fields, theme.FieldRequire)
	}
	if m.license != nil {
		fields = append(fields, theme.FieldLicense)
	}
	if m._path != nil {
		fields = append(fields, theme.FieldPath)
	}
	if m.external_url != nil {
		fields = append(fields, theme.FieldExternalURL)
	}
	if m.enabled != nil {
		fields = append(fields, theme.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThemeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case theme.FieldCreatedAt:
		return m.CreatedAt()
	case theme.FieldUpdatedAt:
		return m.UpdatedAt()
	case theme.FieldType:
		return m.GetType()
	case theme.FieldName:
		return m.Name()
	case theme.FieldDisplayName:
		return m.DisplayName()
	case theme.FieldDescription:
		return m.Description()
	case theme.FieldAuthorName:
		return m.AuthorName()
	case theme.FieldAuthorEmail:
		return m.AuthorEmail()
	case theme.FieldLogo:
		return m.Logo()
	case theme.FieldHomepage:
		return m.Homepage()
	case theme.FieldRepo:
		return m.Repo()
	case theme.FieldIssue:
		return m.Issue()
	case theme.FieldSettingName:
		return m.SettingName()
	case theme.FieldConfigMapName:
		return m.ConfigMapName()
	case theme.FieldVersion:
		return m.Version()
	case theme.FieldRequire:
		return m.Require()
	case theme.FieldLicense:
		return m.License()
	case theme.FieldPath:
		return m.Path()
	case theme.FieldExternalURL:
		return m.ExternalURL()
	case theme.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThemeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case theme.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case theme.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case theme.FieldType:
		return m.OldType(ctx)
	case theme.FieldName:
		return m.OldName(ctx)
	case theme.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case theme.FieldDescription:
		return m.OldDescription(ctx)
	case theme.FieldAuthorName:
		return m.OldAuthorName(ctx)
	case theme.FieldAuthorEmail:
		return m.OldAuthorEmail(ctx)
	case theme.FieldLogo:
		return m.OldLogo(ctx)
	case theme.FieldHomepage:
		return m.OldHomepage(ctx)
	case theme.FieldRepo:
		return m.OldRepo(ctx)
	case theme.FieldIssue:
		return m.OldIssue(ctx)
	case theme.FieldSettingName:
		return m.OldSettingName(ctx)
	case theme.FieldConfigMapName:
		return m.OldConfigMapName(ctx)
	case theme.FieldVersion:
		return m.OldVersion(ctx)
	case theme.FieldRequire:
		return m.OldRequire(ctx)
	case theme.FieldLicense:
		return m.OldLicense(ctx)
	case theme.FieldPath:
		return m.OldPath(ctx)
	case theme.FieldExternalURL:
		return m.OldExternalURL(ctx)
	case theme.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown Theme field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThemeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case theme.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case theme.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case theme.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case theme.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case theme.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case theme.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case theme.FieldAuthorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorName(v)
		return nil
	case theme.FieldAuthorEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorEmail(v)
		return nil
	case theme.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case theme.FieldHomepage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomepage(v)
		return nil
	case theme.FieldRepo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepo(v)
		return nil
	case theme.FieldIssue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssue(v)
		return nil
	case theme.FieldSettingName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettingName(v)
		return nil
	case theme.FieldConfigMapName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigMapName(v)
		return nil
	case theme.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case theme.FieldRequire:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequire(v)
		return nil
	case theme.FieldLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicense(v)
		return nil
	case theme.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case theme.FieldExternalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalURL(v)
		return nil
	case theme.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown Theme field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThemeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThemeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThemeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Theme numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThemeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(theme.FieldDescription) {
		fields = append(fields, theme.FieldDescription)
	}
	if m.FieldCleared(theme.FieldAuthorName) {
		fields = append(fields, theme.FieldAuthorName)
	}
	if m.FieldCleared(theme.FieldAuthorEmail) {
		fields = append(fields, theme.FieldAuthorEmail)
	}
	if m.FieldCleared(theme.FieldLogo) {
		fields = append(fields, theme.FieldLogo)
	}
	if m.FieldCleared(theme.FieldHomepage) {
		fields = append(fields, theme.FieldHomepage)
	}
	if m.FieldCleared(theme.FieldRepo) {
		fields = append(fields, theme.FieldRepo)
	}
	if m.FieldCleared(theme.FieldIssue) {
		fields = append(fields, theme.FieldIssue)
	}
	if m.FieldCleared(theme.FieldSettingName) {
		fields = append(fields, theme.FieldSettingName)
	}
	if m.FieldCleared(theme.FieldConfigMapName) {
		fields = append(fields, theme.FieldConfigMapName)
	}
	if m.FieldCleared(theme.FieldLicense) {
		fields = append(fields, theme.FieldLicense)
	}
	if m.FieldCleared(theme.FieldPath) {
		fields = append(fields, theme.FieldPath)
	}
	if m.FieldCleared(theme.FieldExternalURL) {
		fields = append(fields, theme.FieldExternalURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThemeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThemeMutation) ClearField(name string) error {
	switch name {
	case theme.FieldDescription:
		m.ClearDescription()
		return nil
	case theme.FieldAuthorName:
		m.ClearAuthorName()
		return nil
	case theme.FieldAuthorEmail:
		m.ClearAuthorEmail()
		return nil
	case theme.FieldLogo:
		m.ClearLogo()
		return nil
	case theme.FieldHomepage:
		m.ClearHomepage()
		return nil
	case theme.FieldRepo:
		m.ClearRepo()
		return nil
	case theme.FieldIssue:
		m.ClearIssue()
		return nil
	case theme.FieldSettingName:
		m.ClearSettingName()
		return nil
	case theme.FieldConfigMapName:
		m.ClearConfigMapName()
		return nil
	case theme.FieldLicense:
		m.ClearLicense()
		return nil
	case theme.FieldPath:
		m.ClearPath()
		return nil
	case theme.FieldExternalURL:
		m.ClearExternalURL()
		return nil
	}
	return fmt.Errorf("unknown Theme nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThemeMutation) ResetField(name string) error {
	switch name {
	case theme.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case theme.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case theme.FieldType:
		m.ResetType()
		return nil
	case theme.FieldName:
		m.ResetName()
		return nil
	case theme.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case theme.FieldDescription:
		m.ResetDescription()
		return nil
	case theme.FieldAuthorName:
		m.ResetAuthorName()
		return nil
	case theme.FieldAuthorEmail:
		m.ResetAuthorEmail()
		return nil
	case theme.FieldLogo:
		m.ResetLogo()
		return nil
	case theme.FieldHomepage:
		m.ResetHomepage()
		return nil
	case theme.FieldRepo:
		m.ResetRepo()
		return nil
	case theme.FieldIssue:
		m.ResetIssue()
		return nil
	case theme.FieldSettingName:
		m.ResetSettingName()
		return nil
	case theme.FieldConfigMapName:
		m.ResetConfigMapName()
		return nil
	case theme.FieldVersion:
		m.ResetVersion()
		return nil
	case theme.FieldRequire:
		m.ResetRequire()
		return nil
	case theme.FieldLicense:
		m.ResetLicense()
		return nil
	case theme.FieldPath:
		m.ResetPath()
		return nil
	case theme.FieldExternalURL:
		m.ResetExternalURL()
		return nil
	case theme.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown Theme field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThemeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThemeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThemeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThemeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThemeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThemeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThemeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Theme unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThemeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Theme edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	email                 *string
	email_verified        *bool
	name                  *string
	phone_number          *string
	phone_number_verified *bool
	password              *string
	clearedFields         map[string]struct{}
	role                  *int
	clearedrole           bool
	member                *int
	clearedmember         bool
	wallet                *int
	clearedwallet         bool
	done                  bool
	oldValue              func(context.Context) (*User, error)
	predicates            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user.FieldPhoneNumber)
}

// SetPhoneNumberVerified sets the "phone_number_verified" field.
func (m *UserMutation) SetPhoneNumberVerified(b bool) {
	m.phone_number_verified = &b
}

// PhoneNumberVerified returns the value of the "phone_number_verified" field in the mutation.
func (m *UserMutation) PhoneNumberVerified() (r bool, exists bool) {
	v := m.phone_number_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumberVerified returns the old "phone_number_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumberVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumberVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumberVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumberVerified: %w", err)
	}
	return oldValue.PhoneNumberVerified, nil
}

// ResetPhoneNumberVerified resets all changes to the "phone_number_verified" field.
func (m *UserMutation) ResetPhoneNumberVerified() {
	m.phone_number_verified = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *UserMutation) ClearRoleID() {
	m.role = nil
	m.clearedFields[user.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *UserMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[user.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserMutation) ResetRoleID() {
	m.role = nil
	delete(m.clearedFields, user.FieldRoleID)
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[user.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserMutation) RoleCleared() bool {
	return m.RoleIDCleared() || m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// SetMemberID sets the "member" edge to the Member entity by id.
func (m *UserMutation) SetMemberID(id int) {
	m.member = &id
}

// ClearMember clears the "member" edge to the Member entity.
func (m *UserMutation) ClearMember() {
	m.clearedmember = true
}

// MemberCleared reports if the "member" edge to the Member entity was cleared.
func (m *UserMutation) MemberCleared() bool {
	return m.clearedmember
}

// MemberID returns the "member" edge ID in the mutation.
func (m *UserMutation) MemberID() (id int, exists bool) {
	if m.member != nil {
		return *m.member, true
	}
	return
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *UserMutation) MemberIDs() (ids []int) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *UserMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// SetWalletID sets the "wallet" edge to the Wallet entity by id.
func (m *UserMutation) SetWalletID(id int) {
	m.wallet = &id
}

// ClearWallet clears the "wallet" edge to the Wallet entity.
func (m *UserMutation) ClearWallet() {
	m.clearedwallet = true
}

// WalletCleared reports if the "wallet" edge to the Wallet entity was cleared.
func (m *UserMutation) WalletCleared() bool {
	return m.clearedwallet
}

// WalletID returns the "wallet" edge ID in the mutation.
func (m *UserMutation) WalletID() (id int, exists bool) {
	if m.wallet != nil {
		return *m.wallet, true
	}
	return
}

// WalletIDs returns the "wallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WalletID instead. It exists only for internal usage by the builders.
func (m *UserMutation) WalletIDs() (ids []int) {
	if id := m.wallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWallet resets all changes to the "wallet" edge.
func (m *UserMutation) ResetWallet() {
	m.wallet = nil
	m.clearedwallet = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.phone_number_verified != nil {
		fields = append(fields, user.FieldPhoneNumberVerified)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldName:
		return m.Name()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldPhoneNumberVerified:
		return m.PhoneNumberVerified()
	case user.FieldPassword:
		return m.Password()
	case user.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldPhoneNumberVerified:
		return m.OldPhoneNumberVerified(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldPhoneNumberVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumberVerified(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPhoneNumber) {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.FieldCleared(user.FieldRoleID) {
		fields = append(fields, user.FieldRoleID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case user.FieldRoleID:
		m.ClearRoleID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldPhoneNumberVerified:
		m.ResetPhoneNumberVerified()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.role != nil {
		edges = append(edges, user.EdgeRole)
	}
	if m.member != nil {
		edges = append(edges, user.EdgeMember)
	}
	if m.wallet != nil {
		edges = append(edges, user.EdgeWallet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeWallet:
		if id := m.wallet; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrole {
		edges = append(edges, user.EdgeRole)
	}
	if m.clearedmember {
		edges = append(edges, user.EdgeMember)
	}
	if m.clearedwallet {
		edges = append(edges, user.EdgeWallet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRole:
		return m.clearedrole
	case user.EdgeMember:
		return m.clearedmember
	case user.EdgeWallet:
		return m.clearedwallet
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeRole:
		m.ClearRole()
		return nil
	case user.EdgeMember:
		m.ClearMember()
		return nil
	case user.EdgeWallet:
		m.ClearWallet()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRole:
		m.ResetRole()
		return nil
	case user.EdgeMember:
		m.ResetMember()
		return nil
	case user.EdgeWallet:
		m.ResetWallet()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VisitLogMutation represents an operation that mutates the VisitLog nodes in the graph.
type VisitLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	ip            *string
	user_agent    *string
	_path         *string
	os            *string
	browser       *string
	device        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VisitLog, error)
	predicates    []predicate.VisitLog
}

var _ ent.Mutation = (*VisitLogMutation)(nil)

// visitlogOption allows management of the mutation configuration using functional options.
type visitlogOption func(*VisitLogMutation)

// newVisitLogMutation creates new mutation for the VisitLog entity.
func newVisitLogMutation(c config, op Op, opts ...visitlogOption) *VisitLogMutation {
	m := &VisitLogMutation{
		config:        c,
		op:            op,
		typ:           TypeVisitLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVisitLogID sets the ID field of the mutation.
func withVisitLogID(id int) visitlogOption {
	return func(m *VisitLogMutation) {
		var (
			err   error
			once  sync.Once
			value *VisitLog
		)
		m.oldValue = func(ctx context.Context) (*VisitLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VisitLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVisitLog sets the old VisitLog of the mutation.
func withVisitLog(node *VisitLog) visitlogOption {
	return func(m *VisitLogMutation) {
		m.oldValue = func(context.Context) (*VisitLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VisitLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VisitLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VisitLog entities.
func (m *VisitLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VisitLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VisitLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VisitLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VisitLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VisitLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VisitLog entity.
// If the VisitLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VisitLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VisitLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VisitLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VisitLog entity.
// If the VisitLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VisitLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetIP sets the "ip" field.
func (m *VisitLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *VisitLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the VisitLog entity.
// If the VisitLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *VisitLogMutation) ResetIP() {
	m.ip = nil
}

// SetUserAgent sets the "user_agent" field.
func (m *VisitLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *VisitLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the VisitLog entity.
// If the VisitLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitLogMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *VisitLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[visitlog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *VisitLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[visitlog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *VisitLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, visitlog.FieldUserAgent)
}

// SetPath sets the "path" field.
func (m *VisitLogMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *VisitLogMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the VisitLog entity.
// If the VisitLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitLogMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *VisitLogMutation) ResetPath() {
	m._path = nil
}

// SetOs sets the "os" field.
func (m *VisitLogMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *VisitLogMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the VisitLog entity.
// If the VisitLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitLogMutation) OldOs(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ClearOs clears the value of the "os" field.
func (m *VisitLogMutation) ClearOs() {
	m.os = nil
	m.clearedFields[visitlog.FieldOs] = struct{}{}
}

// OsCleared returns if the "os" field was cleared in this mutation.
func (m *VisitLogMutation) OsCleared() bool {
	_, ok := m.clearedFields[visitlog.FieldOs]
	return ok
}

// ResetOs resets all changes to the "os" field.
func (m *VisitLogMutation) ResetOs() {
	m.os = nil
	delete(m.clearedFields, visitlog.FieldOs)
}

// SetBrowser sets the "browser" field.
func (m *VisitLogMutation) SetBrowser(s string) {
	m.browser = &s
}

// Browser returns the value of the "browser" field in the mutation.
func (m *VisitLogMutation) Browser() (r string, exists bool) {
	v := m.browser
	if v == nil {
		return
	}
	return *v, true
}

// OldBrowser returns the old "browser" field's value of the VisitLog entity.
// If the VisitLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitLogMutation) OldBrowser(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrowser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrowser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrowser: %w", err)
	}
	return oldValue.Browser, nil
}

// ClearBrowser clears the value of the "browser" field.
func (m *VisitLogMutation) ClearBrowser() {
	m.browser = nil
	m.clearedFields[visitlog.FieldBrowser] = struct{}{}
}

// BrowserCleared returns if the "browser" field was cleared in this mutation.
func (m *VisitLogMutation) BrowserCleared() bool {
	_, ok := m.clearedFields[visitlog.FieldBrowser]
	return ok
}

// ResetBrowser resets all changes to the "browser" field.
func (m *VisitLogMutation) ResetBrowser() {
	m.browser = nil
	delete(m.clearedFields, visitlog.FieldBrowser)
}

// SetDevice sets the "device" field.
func (m *VisitLogMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *VisitLogMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the VisitLog entity.
// If the VisitLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitLogMutation) OldDevice(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ClearDevice clears the value of the "device" field.
func (m *VisitLogMutation) ClearDevice() {
	m.device = nil
	m.clearedFields[visitlog.FieldDevice] = struct{}{}
}

// DeviceCleared returns if the "device" field was cleared in this mutation.
func (m *VisitLogMutation) DeviceCleared() bool {
	_, ok := m.clearedFields[visitlog.FieldDevice]
	return ok
}

// ResetDevice resets all changes to the "device" field.
func (m *VisitLogMutation) ResetDevice() {
	m.device = nil
	delete(m.clearedFields, visitlog.FieldDevice)
}

// Where appends a list predicates to the VisitLogMutation builder.
func (m *VisitLogMutation) Where(ps ...predicate.VisitLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VisitLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VisitLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VisitLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VisitLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VisitLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VisitLog).
func (m *VisitLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VisitLogMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, visitlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, visitlog.FieldUpdatedAt)
	}
	if m.ip != nil {
		fields = append(fields, visitlog.FieldIP)
	}
	if m.user_agent != nil {
		fields = append(fields, visitlog.FieldUserAgent)
	}
	if m._path != nil {
		fields = append(fields, visitlog.FieldPath)
	}
	if m.os != nil {
		fields = append(fields, visitlog.FieldOs)
	}
	if m.browser != nil {
		fields = append(fields, visitlog.FieldBrowser)
	}
	if m.device != nil {
		fields = append(fields, visitlog.FieldDevice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VisitLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case visitlog.FieldCreatedAt:
		return m.CreatedAt()
	case visitlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case visitlog.FieldIP:
		return m.IP()
	case visitlog.FieldUserAgent:
		return m.UserAgent()
	case visitlog.FieldPath:
		return m.Path()
	case visitlog.FieldOs:
		return m.Os()
	case visitlog.FieldBrowser:
		return m.Browser()
	case visitlog.FieldDevice:
		return m.Device()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VisitLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case visitlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case visitlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case visitlog.FieldIP:
		return m.OldIP(ctx)
	case visitlog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case visitlog.FieldPath:
		return m.OldPath(ctx)
	case visitlog.FieldOs:
		return m.OldOs(ctx)
	case visitlog.FieldBrowser:
		return m.OldBrowser(ctx)
	case visitlog.FieldDevice:
		return m.OldDevice(ctx)
	}
	return nil, fmt.Errorf("unknown VisitLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case visitlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case visitlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case visitlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case visitlog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case visitlog.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case visitlog.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case visitlog.FieldBrowser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrowser(v)
		return nil
	case visitlog.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	}
	return fmt.Errorf("unknown VisitLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VisitLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VisitLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VisitLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VisitLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(visitlog.FieldUserAgent) {
		fields = append(fields, visitlog.FieldUserAgent)
	}
	if m.FieldCleared(visitlog.FieldOs) {
		fields = append(fields, visitlog.FieldOs)
	}
	if m.FieldCleared(visitlog.FieldBrowser) {
		fields = append(fields, visitlog.FieldBrowser)
	}
	if m.FieldCleared(visitlog.FieldDevice) {
		fields = append(fields, visitlog.FieldDevice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VisitLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VisitLogMutation) ClearField(name string) error {
	switch name {
	case visitlog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case visitlog.FieldOs:
		m.ClearOs()
		return nil
	case visitlog.FieldBrowser:
		m.ClearBrowser()
		return nil
	case visitlog.FieldDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown VisitLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VisitLogMutation) ResetField(name string) error {
	switch name {
	case visitlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case visitlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case visitlog.FieldIP:
		m.ResetIP()
		return nil
	case visitlog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case visitlog.FieldPath:
		m.ResetPath()
		return nil
	case visitlog.FieldOs:
		m.ResetOs()
		return nil
	case visitlog.FieldBrowser:
		m.ResetBrowser()
		return nil
	case visitlog.FieldDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown VisitLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VisitLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VisitLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VisitLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VisitLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VisitLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VisitLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VisitLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VisitLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VisitLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VisitLog edge %s", name)
}

// WalletMutation represents an operation that mutates the Wallet nodes in the graph.
type WalletMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	balance          *int
	addbalance       *int
	frozen_amount    *int
	addfrozen_amount *int
	total_income     *int
	addtotal_income  *int
	total_expense    *int
	addtotal_expense *int
	password         *string
	active           *bool
	remark           *string
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Wallet, error)
	predicates       []predicate.Wallet
}

var _ ent.Mutation = (*WalletMutation)(nil)

// walletOption allows management of the mutation configuration using functional options.
type walletOption func(*WalletMutation)

// newWalletMutation creates new mutation for the Wallet entity.
func newWalletMutation(c config, op Op, opts ...walletOption) *WalletMutation {
	m := &WalletMutation{
		config:        c,
		op:            op,
		typ:           TypeWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletID sets the ID field of the mutation.
func withWalletID(id int) walletOption {
	return func(m *WalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Wallet
		)
		m.oldValue = func(ctx context.Context) (*Wallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Wallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWallet sets the old Wallet of the mutation.
func withWallet(node *Wallet) walletOption {
	return func(m *WalletMutation) {
		m.oldValue = func(context.Context) (*Wallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Wallet entities.
func (m *WalletMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WalletMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Wallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WalletMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WalletMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WalletMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WalletMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WalletMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WalletMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *WalletMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WalletMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WalletMutation) ResetUserID() {
	m.user = nil
}

// SetBalance sets the "balance" field.
func (m *WalletMutation) SetBalance(i int) {
	m.balance = &i
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *WalletMutation) Balance() (r int, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldBalance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds i to the "balance" field.
func (m *WalletMutation) AddBalance(i int) {
	if m.addbalance != nil {
		*m.addbalance += i
	} else {
		m.addbalance = &i
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *WalletMutation) AddedBalance() (r int, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *WalletMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetFrozenAmount sets the "frozen_amount" field.
func (m *WalletMutation) SetFrozenAmount(i int) {
	m.frozen_amount = &i
	m.addfrozen_amount = nil
}

// FrozenAmount returns the value of the "frozen_amount" field in the mutation.
func (m *WalletMutation) FrozenAmount() (r int, exists bool) {
	v := m.frozen_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozenAmount returns the old "frozen_amount" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldFrozenAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozenAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozenAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozenAmount: %w", err)
	}
	return oldValue.FrozenAmount, nil
}

// AddFrozenAmount adds i to the "frozen_amount" field.
func (m *WalletMutation) AddFrozenAmount(i int) {
	if m.addfrozen_amount != nil {
		*m.addfrozen_amount += i
	} else {
		m.addfrozen_amount = &i
	}
}

// AddedFrozenAmount returns the value that was added to the "frozen_amount" field in this mutation.
func (m *WalletMutation) AddedFrozenAmount() (r int, exists bool) {
	v := m.addfrozen_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrozenAmount resets all changes to the "frozen_amount" field.
func (m *WalletMutation) ResetFrozenAmount() {
	m.frozen_amount = nil
	m.addfrozen_amount = nil
}

// SetTotalIncome sets the "total_income" field.
func (m *WalletMutation) SetTotalIncome(i int) {
	m.total_income = &i
	m.addtotal_income = nil
}

// TotalIncome returns the value of the "total_income" field in the mutation.
func (m *WalletMutation) TotalIncome() (r int, exists bool) {
	v := m.total_income
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalIncome returns the old "total_income" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldTotalIncome(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalIncome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalIncome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalIncome: %w", err)
	}
	return oldValue.TotalIncome, nil
}

// AddTotalIncome adds i to the "total_income" field.
func (m *WalletMutation) AddTotalIncome(i int) {
	if m.addtotal_income != nil {
		*m.addtotal_income += i
	} else {
		m.addtotal_income = &i
	}
}

// AddedTotalIncome returns the value that was added to the "total_income" field in this mutation.
func (m *WalletMutation) AddedTotalIncome() (r int, exists bool) {
	v := m.addtotal_income
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalIncome resets all changes to the "total_income" field.
func (m *WalletMutation) ResetTotalIncome() {
	m.total_income = nil
	m.addtotal_income = nil
}

// SetTotalExpense sets the "total_expense" field.
func (m *WalletMutation) SetTotalExpense(i int) {
	m.total_expense = &i
	m.addtotal_expense = nil
}

// TotalExpense returns the value of the "total_expense" field in the mutation.
func (m *WalletMutation) TotalExpense() (r int, exists bool) {
	v := m.total_expense
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalExpense returns the old "total_expense" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldTotalExpense(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalExpense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalExpense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalExpense: %w", err)
	}
	return oldValue.TotalExpense, nil
}

// AddTotalExpense adds i to the "total_expense" field.
func (m *WalletMutation) AddTotalExpense(i int) {
	if m.addtotal_expense != nil {
		*m.addtotal_expense += i
	} else {
		m.addtotal_expense = &i
	}
}

// AddedTotalExpense returns the value that was added to the "total_expense" field in this mutation.
func (m *WalletMutation) AddedTotalExpense() (r int, exists bool) {
	v := m.addtotal_expense
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalExpense resets all changes to the "total_expense" field.
func (m *WalletMutation) ResetTotalExpense() {
	m.total_expense = nil
	m.addtotal_expense = nil
}

// SetPassword sets the "password" field.
func (m *WalletMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *WalletMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *WalletMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[wallet.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *WalletMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[wallet.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *WalletMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, wallet.FieldPassword)
}

// SetActive sets the "active" field.
func (m *WalletMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *WalletMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *WalletMutation) ResetActive() {
	m.active = nil
}

// SetRemark sets the "remark" field.
func (m *WalletMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *WalletMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Wallet entity.
// If the Wallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *WalletMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[wallet.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *WalletMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[wallet.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *WalletMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, wallet.FieldRemark)
}

// ClearUser clears the "user" edge to the User entity.
func (m *WalletMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[wallet.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WalletMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WalletMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WalletMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WalletMutation builder.
func (m *WalletMutation) Where(ps ...predicate.Wallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Wallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Wallet).
func (m *WalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, wallet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, wallet.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, wallet.FieldUserID)
	}
	if m.balance != nil {
		fields = append(fields, wallet.FieldBalance)
	}
	if m.frozen_amount != nil {
		fields = append(fields, wallet.FieldFrozenAmount)
	}
	if m.total_income != nil {
		fields = append(fields, wallet.FieldTotalIncome)
	}
	if m.total_expense != nil {
		fields = append(fields, wallet.FieldTotalExpense)
	}
	if m.password != nil {
		fields = append(fields, wallet.FieldPassword)
	}
	if m.active != nil {
		fields = append(fields, wallet.FieldActive)
	}
	if m.remark != nil {
		fields = append(fields, wallet.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldCreatedAt:
		return m.CreatedAt()
	case wallet.FieldUpdatedAt:
		return m.UpdatedAt()
	case wallet.FieldUserID:
		return m.UserID()
	case wallet.FieldBalance:
		return m.Balance()
	case wallet.FieldFrozenAmount:
		return m.FrozenAmount()
	case wallet.FieldTotalIncome:
		return m.TotalIncome()
	case wallet.FieldTotalExpense:
		return m.TotalExpense()
	case wallet.FieldPassword:
		return m.Password()
	case wallet.FieldActive:
		return m.Active()
	case wallet.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case wallet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case wallet.FieldUserID:
		return m.OldUserID(ctx)
	case wallet.FieldBalance:
		return m.OldBalance(ctx)
	case wallet.FieldFrozenAmount:
		return m.OldFrozenAmount(ctx)
	case wallet.FieldTotalIncome:
		return m.OldTotalIncome(ctx)
	case wallet.FieldTotalExpense:
		return m.OldTotalExpense(ctx)
	case wallet.FieldPassword:
		return m.OldPassword(ctx)
	case wallet.FieldActive:
		return m.OldActive(ctx)
	case wallet.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Wallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case wallet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case wallet.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case wallet.FieldBalance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case wallet.FieldFrozenAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozenAmount(v)
		return nil
	case wallet.FieldTotalIncome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalIncome(v)
		return nil
	case wallet.FieldTotalExpense:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalExpense(v)
		return nil
	case wallet.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case wallet.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case wallet.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, wallet.FieldBalance)
	}
	if m.addfrozen_amount != nil {
		fields = append(fields, wallet.FieldFrozenAmount)
	}
	if m.addtotal_income != nil {
		fields = append(fields, wallet.FieldTotalIncome)
	}
	if m.addtotal_expense != nil {
		fields = append(fields, wallet.FieldTotalExpense)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wallet.FieldBalance:
		return m.AddedBalance()
	case wallet.FieldFrozenAmount:
		return m.AddedFrozenAmount()
	case wallet.FieldTotalIncome:
		return m.AddedTotalIncome()
	case wallet.FieldTotalExpense:
		return m.AddedTotalExpense()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wallet.FieldBalance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case wallet.FieldFrozenAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozenAmount(v)
		return nil
	case wallet.FieldTotalIncome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalIncome(v)
		return nil
	case wallet.FieldTotalExpense:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalExpense(v)
		return nil
	}
	return fmt.Errorf("unknown Wallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wallet.FieldPassword) {
		fields = append(fields, wallet.FieldPassword)
	}
	if m.FieldCleared(wallet.FieldRemark) {
		fields = append(fields, wallet.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletMutation) ClearField(name string) error {
	switch name {
	case wallet.FieldPassword:
		m.ClearPassword()
		return nil
	case wallet.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Wallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletMutation) ResetField(name string) error {
	switch name {
	case wallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case wallet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case wallet.FieldUserID:
		m.ResetUserID()
		return nil
	case wallet.FieldBalance:
		m.ResetBalance()
		return nil
	case wallet.FieldFrozenAmount:
		m.ResetFrozenAmount()
		return nil
	case wallet.FieldTotalIncome:
		m.ResetTotalIncome()
		return nil
	case wallet.FieldTotalExpense:
		m.ResetTotalExpense()
		return nil
	case wallet.FieldPassword:
		m.ResetPassword()
		return nil
	case wallet.FieldActive:
		m.ResetActive()
		return nil
	case wallet.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Wallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, wallet.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wallet.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, wallet.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletMutation) EdgeCleared(name string) bool {
	switch name {
	case wallet.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletMutation) ClearEdge(name string) error {
	switch name {
	case wallet.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Wallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletMutation) ResetEdge(name string) error {
	switch name {
	case wallet.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Wallet edge %s", name)
}

// WebHookMutation represents an operation that mutates the WebHook nodes in the graph.
type WebHookMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	url           *string
	event         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WebHook, error)
	predicates    []predicate.WebHook
}

var _ ent.Mutation = (*WebHookMutation)(nil)

// webhookOption allows management of the mutation configuration using functional options.
type webhookOption func(*WebHookMutation)

// newWebHookMutation creates new mutation for the WebHook entity.
func newWebHookMutation(c config, op Op, opts ...webhookOption) *WebHookMutation {
	m := &WebHookMutation{
		config:        c,
		op:            op,
		typ:           TypeWebHook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWebHookID sets the ID field of the mutation.
func withWebHookID(id int) webhookOption {
	return func(m *WebHookMutation) {
		var (
			err   error
			once  sync.Once
			value *WebHook
		)
		m.oldValue = func(ctx context.Context) (*WebHook, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WebHook.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWebHook sets the old WebHook of the mutation.
func withWebHook(node *WebHook) webhookOption {
	return func(m *WebHookMutation) {
		m.oldValue = func(context.Context) (*WebHook, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WebHookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WebHookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WebHook entities.
func (m *WebHookMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WebHookMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WebHookMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WebHook.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WebHookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WebHookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WebHook entity.
// If the WebHook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebHookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WebHookMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WebHookMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WebHookMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WebHook entity.
// If the WebHook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebHookMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WebHookMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *WebHookMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WebHookMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WebHook entity.
// If the WebHook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebHookMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WebHookMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *WebHookMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *WebHookMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the WebHook entity.
// If the WebHook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebHookMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *WebHookMutation) ResetURL() {
	m.url = nil
}

// SetEvent sets the "event" field.
func (m *WebHookMutation) SetEvent(s string) {
	m.event = &s
}

// Event returns the value of the "event" field in the mutation.
func (m *WebHookMutation) Event() (r string, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEvent returns the old "event" field's value of the WebHook entity.
// If the WebHook object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WebHookMutation) OldEvent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvent: %w", err)
	}
	return oldValue.Event, nil
}

// ResetEvent resets all changes to the "event" field.
func (m *WebHookMutation) ResetEvent() {
	m.event = nil
}

// Where appends a list predicates to the WebHookMutation builder.
func (m *WebHookMutation) Where(ps ...predicate.WebHook) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WebHookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WebHookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WebHook, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WebHookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WebHookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WebHook).
func (m *WebHookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WebHookMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, webhook.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, webhook.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, webhook.FieldName)
	}
	if m.url != nil {
		fields = append(fields, webhook.FieldURL)
	}
	if m.event != nil {
		fields = append(fields, webhook.FieldEvent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WebHookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case webhook.FieldCreatedAt:
		return m.CreatedAt()
	case webhook.FieldUpdatedAt:
		return m.UpdatedAt()
	case webhook.FieldName:
		return m.Name()
	case webhook.FieldURL:
		return m.URL()
	case webhook.FieldEvent:
		return m.Event()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WebHookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case webhook.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case webhook.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case webhook.FieldName:
		return m.OldName(ctx)
	case webhook.FieldURL:
		return m.OldURL(ctx)
	case webhook.FieldEvent:
		return m.OldEvent(ctx)
	}
	return nil, fmt.Errorf("unknown WebHook field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebHookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case webhook.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case webhook.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case webhook.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case webhook.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case webhook.FieldEvent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvent(v)
		return nil
	}
	return fmt.Errorf("unknown WebHook field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WebHookMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WebHookMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WebHookMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WebHook numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WebHookMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WebHookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WebHookMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WebHook nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WebHookMutation) ResetField(name string) error {
	switch name {
	case webhook.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case webhook.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case webhook.FieldName:
		m.ResetName()
		return nil
	case webhook.FieldURL:
		m.ResetURL()
		return nil
	case webhook.FieldEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown WebHook field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WebHookMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WebHookMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WebHookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WebHookMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WebHookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WebHookMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WebHookMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WebHook unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WebHookMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WebHook edge %s", name)
}
